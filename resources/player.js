/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@mux/mux-player@2.5.0/dist/mux-player.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";
(() => {
	var e = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, t = (t, i, a) => (e(t, i, "read from private field"), a ? a.call(t) : i.get(t)), i = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, a = (t, i, a, r) => (e(t, i, "write to private field"), r ? r.call(t, a) : i.set(t, a), a),
		r = (t, i, a) => (e(t, i, "access private method"), a), n = class {
			addEventListener() {
			}

			removeEventListener() {
			}

			dispatchEvent(e) {
				return !0
			}
		};
	if ("undefined" == typeof DocumentFragment) {
		class e extends n {
		}

		globalThis.DocumentFragment = e
	}
	var s, o = class extends n {
	}, l = {
		get(e) {
		}, define(e, t, i) {
		}, upgrade(e) {
		}, whenDefined: e => Promise.resolve(o)
	};
	s = new WeakMap;
	var d = {
			document: {
				createElement: function (e, t) {
					return new o
				}
			}, DocumentFragment: DocumentFragment, customElements: l, CustomEvent: class {
				constructor(e, t = {}) {
					i(this, s, void 0), a(this, s, null == t ? void 0 : t.detail)
				}

				get detail() {
					return t(this, s)
				}

				initCustomEvent() {
				}
			}, EventTarget: n, HTMLElement: o, HTMLVideoElement: class extends n {
			}
		}, u = "undefined" == typeof window || void 0 === globalThis.customElements, h = u ? d : globalThis,
		c = u ? d.document : globalThis.document, m = {
			MEDIA_PLAY_REQUEST: "mediaplayrequest",
			MEDIA_PAUSE_REQUEST: "mediapauserequest",
			MEDIA_MUTE_REQUEST: "mediamuterequest",
			MEDIA_UNMUTE_REQUEST: "mediaunmuterequest",
			MEDIA_VOLUME_REQUEST: "mediavolumerequest",
			MEDIA_SEEK_REQUEST: "mediaseekrequest",
			MEDIA_AIRPLAY_REQUEST: "mediaairplayrequest",
			MEDIA_ENTER_FULLSCREEN_REQUEST: "mediaenterfullscreenrequest",
			MEDIA_EXIT_FULLSCREEN_REQUEST: "mediaexitfullscreenrequest",
			MEDIA_PREVIEW_REQUEST: "mediapreviewrequest",
			MEDIA_ENTER_PIP_REQUEST: "mediaenterpiprequest",
			MEDIA_EXIT_PIP_REQUEST: "mediaexitpiprequest",
			MEDIA_ENTER_CAST_REQUEST: "mediaentercastrequest",
			MEDIA_EXIT_CAST_REQUEST: "mediaexitcastrequest",
			MEDIA_SHOW_TEXT_TRACKS_REQUEST: "mediashowtexttracksrequest",
			MEDIA_HIDE_TEXT_TRACKS_REQUEST: "mediahidetexttracksrequest",
			MEDIA_SHOW_SUBTITLES_REQUEST: "mediashowsubtitlesrequest",
			MEDIA_DISABLE_SUBTITLES_REQUEST: "mediadisablesubtitlesrequest",
			MEDIA_TOGGLE_SUBTITLES_REQUEST: "mediatogglesubtitlesrequest",
			MEDIA_PLAYBACK_RATE_REQUEST: "mediaplaybackraterequest",
			MEDIA_RENDITION_REQUEST: "mediarenditionrequest",
			MEDIA_AUDIO_TRACK_REQUEST: "mediaaudiotrackrequest",
			MEDIA_SEEK_TO_LIVE_REQUEST: "mediaseektoliverequest",
			REGISTER_MEDIA_STATE_RECEIVER: "registermediastatereceiver",
			UNREGISTER_MEDIA_STATE_RECEIVER: "unregistermediastatereceiver"
		}, f = {MEDIA_CHROME_ATTRIBUTES: "mediachromeattributes", MEDIA_CONTROLLER: "mediacontroller"}, p = {
			MEDIA_AIRPLAY_UNAVAILABLE: "mediaAirplayUnavailable",
			MEDIA_FULLSCREEN_UNAVAILABLE: "mediaFullscreenUnavailable",
			MEDIA_PIP_UNAVAILABLE: "mediaPipUnavailable",
			MEDIA_CAST_UNAVAILABLE: "mediaCastUnavailable",
			MEDIA_RENDITION_UNAVAILABLE: "mediaRenditionUnavailable",
			MEDIA_AUDIO_TRACK_UNAVAILABLE: "mediaAudioTrackUnavailable",
			MEDIA_PAUSED: "mediaPaused",
			MEDIA_HAS_PLAYED: "mediaHasPlayed",
			MEDIA_ENDED: "mediaEnded",
			MEDIA_MUTED: "mediaMuted",
			MEDIA_VOLUME_LEVEL: "mediaVolumeLevel",
			MEDIA_VOLUME: "mediaVolume",
			MEDIA_VOLUME_UNAVAILABLE: "mediaVolumeUnavailable",
			MEDIA_IS_PIP: "mediaIsPip",
			MEDIA_IS_CASTING: "mediaIsCasting",
			MEDIA_IS_AIRPLAYING: "mediaIsAirplaying",
			MEDIA_SUBTITLES_LIST: "mediaSubtitlesList",
			MEDIA_SUBTITLES_SHOWING: "mediaSubtitlesShowing",
			MEDIA_IS_FULLSCREEN: "mediaIsFullscreen",
			MEDIA_PLAYBACK_RATE: "mediaPlaybackRate",
			MEDIA_CURRENT_TIME: "mediaCurrentTime",
			MEDIA_DURATION: "mediaDuration",
			MEDIA_SEEKABLE: "mediaSeekable",
			MEDIA_PREVIEW_TIME: "mediaPreviewTime",
			MEDIA_PREVIEW_IMAGE: "mediaPreviewImage",
			MEDIA_PREVIEW_COORDS: "mediaPreviewCoords",
			MEDIA_PREVIEW_CHAPTER: "mediaPreviewChapter",
			MEDIA_LOADING: "mediaLoading",
			MEDIA_BUFFERED: "mediaBuffered",
			MEDIA_STREAM_TYPE: "mediaStreamType",
			MEDIA_TARGET_LIVE_WINDOW: "mediaTargetLiveWindow",
			MEDIA_TIME_IS_LIVE: "mediaTimeIsLive",
			MEDIA_RENDITION_LIST: "mediaRenditionList",
			MEDIA_RENDITION_SELECTED: "mediaRenditionSelected",
			MEDIA_AUDIO_TRACK_LIST: "mediaAudioTrackList",
			MEDIA_AUDIO_TRACK_ENABLED: "mediaAudioTrackEnabled",
			MEDIA_CHAPTERS_CUES: "mediaChaptersCues"
		}, g = Object.entries(p), v = g.reduce(((e, [t, i]) => (e[t] = `${i.toLowerCase()}`, e)), {}),
		E = g.reduce(((e, [t, i]) => (e[t] = `${i.toLowerCase()}`, e)), {
			USER_INACTIVE: "userinactivechange",
			BREAKPOINTS_CHANGE: "breakpointchange",
			BREAKPOINTS_COMPUTED: "breakpointscomputed"
		}), b = (Object.entries(E).reduce(((e, [t, i]) => {
			let a = v[t];
			return a && (e[i] = a), e
		}), {userinactivechange: "userinactive"}), Object.entries(v).reduce(((e, [t, i]) => {
			let a = E[t];
			return a && (e[i] = a), e
		}), {userinactive: "userinactivechange"})), y = {
			SUBTITLES: "subtitles",
			CAPTIONS: "captions",
			DESCRIPTIONS: "descriptions",
			CHAPTERS: "chapters",
			METADATA: "metadata"
		}, T = "disabled", A = "showing", _ = "mouse", k = "touch", S = "unavailable", w = "unsupported",
		L = {LIVE: "live", ON_DEMAND: "on-demand", UNKNOWN: "unknown"}, R = "fullscreen", I = {
			AUDIO_PLAYER: () => "audio player",
			VIDEO_PLAYER: () => "video player",
			VOLUME: () => "volume",
			SEEK: () => "seek",
			CLOSED_CAPTIONS: () => "closed captions",
			PLAYBACK_RATE: ({playbackRate: e = 1} = {}) => `current playback rate ${e}`,
			PLAYBACK_TIME: () => "playback time",
			MEDIA_LOADING: () => "media loading",
			SETTINGS: () => "settings",
			AUDIO_TRACKS: () => "audio tracks",
			QUALITY: () => "quality"
		}, D = {
			PLAY: () => "play",
			PAUSE: () => "pause",
			MUTE: () => "mute",
			UNMUTE: () => "unmute",
			ENTER_AIRPLAY: () => "start airplay",
			EXIT_AIRPLAY: () => "stop airplay",
			ENTER_CAST: () => "start casting",
			EXIT_CAST: () => "stop casting",
			ENTER_FULLSCREEN: () => "enter fullscreen mode",
			EXIT_FULLSCREEN: () => "exit fullscreen mode",
			ENTER_PIP: () => "enter picture in picture mode",
			EXIT_PIP: () => "exit picture in picture mode",
			SEEK_FORWARD_N_SECS: ({seekOffset: e = 30} = {}) => `seek forward ${e} seconds`,
			SEEK_BACK_N_SECS: ({seekOffset: e = 30} = {}) => `seek back ${e} seconds`,
			SEEK_LIVE: () => "seek to live",
			PLAYING_LIVE: () => "playing live"
		};

	function C(e) {
		return null == e ? void 0 : e.split(/\s+/).map(M)
	}

	function x(e) {
		if (e) {
			let {id: t, width: i, height: a} = e;
			return [t, i, a].filter((e => null != e)).join(":")
		}
	}

	function M(e) {
		if (e) {
			let [t, i, a] = e.split(":");
			return {id: t, width: i, height: a}
		}
	}

	function O(e) {
		return null == e ? void 0 : e.split(/\s+/).map(N)
	}

	function P(e) {
		if (e) {
			let {id: t, kind: i, language: a, label: r} = e;
			return [t, i, a, r].filter((e => null != e)).join(":")
		}
	}

	function N(e) {
		if (e) {
			let [t, i, a, r] = e.split(":");
			return {id: t, kind: i, language: a, label: r}
		}
	}

	function U(e) {
		return e.replace(/[-_]([a-z])/g, ((e, t) => t.toUpperCase()))
	}

	function F(e) {
		return "string" == typeof e && (!isNaN(e) && !isNaN(parseFloat(e)))
	}

	var B = e => new Promise((t => setTimeout(t, e))),
		$ = [{singular: "hour", plural: "hours"}, {singular: "minute", plural: "minutes"}, {
			singular: "second",
			plural: "seconds"
		}], H = e => {
			if (!function (e) {
				return "number" == typeof e && !Number.isNaN(e) && Number.isFinite(e)
			}(e)) return "";
			let t = Math.abs(e), i = t !== e, a = new Date(0, 0, 0, 0, 0, t, 0);
			return `${[a.getHours(), a.getMinutes(), a.getSeconds()].map(((e, t) => e && ((e, t) => `${e} ${1 === e ? $[t].singular : $[t].plural}`)(e, t))).filter((e => e)).join(", ")}${i ? " remaining" : ""}`
		};

	function W(e, t) {
		let i = !1;
		e < 0 && (i = !0, e = 0 - e), e = e < 0 ? 0 : e;
		let a = Math.floor(e % 60), r = Math.floor(e / 60 % 60), n = Math.floor(e / 3600), s = Math.floor(t / 60 % 60),
			o = Math.floor(t / 3600);
		return (isNaN(e) || e === 1 / 0) && (n = r = a = "0"), n = n > 0 || o > 0 ? n + ":" : "", r = ((n || s >= 10) && r < 10 ? "0" + r : r) + ":", a = a < 10 ? "0" + a : a, (i ? "-" : "") + n + r + a
	}

	Object.freeze({
		length: 0, start(e) {
			let t = e >>> 0;
			if (t >= this.length) throw new DOMException(`Failed to execute 'start' on 'TimeRanges': The index provided (${t}) is greater than or equal to the maximum bound (${this.length}).`);
			return 0
		}, end(e) {
			let t = e >>> 0;
			if (t >= this.length) throw new DOMException(`Failed to execute 'end' on 'TimeRanges': The index provided (${t}) is greater than or equal to the maximum bound (${this.length}).`);
			return 0
		}
	});
	var G = class {
			addEventListener() {
			}

			removeEventListener() {
			}

			dispatchEvent() {
				return !0
			}
		}, V = class extends G {
		}, K = {
			createElement: function () {
				return new q.HTMLElement
			}, createElementNS: function () {
				return new q.HTMLElement
			}, addEventListener() {
			}, removeEventListener() {
			}, dispatchEvent: e => !1
		}, q = {
			ResizeObserver: class {
				observe() {
				}

				unobserve() {
				}

				disconnect() {
				}
			}, document: K, Node: V, HTMLElement: class extends V {
			}, DocumentFragment: class extends G {
			}, customElements: {
				get: function () {
				}, define: function () {
				}, whenDefined: function () {
				}
			}, localStorage: {
				getItem: e => null, setItem(e, t) {
				}, removeItem(e) {
				}
			}, CustomEvent: function () {
			}, getComputedStyle: function () {
			}, navigator: {
				languages: [], get userAgent() {
					return ""
				}
			}, matchMedia: e => ({matches: !1, media: e})
		}, Y = "undefined" == typeof window || void 0 === window.customElements,
		j = Object.keys(q).every((e => e in globalThis)), z = Y && !j ? q : globalThis,
		X = Y && !j ? K : globalThis.document, Q = new WeakMap, Z = e => {
			let t = Q.get(e);
			return t || Q.set(e, t = new Set), t
		}, J = new z.ResizeObserver((e => {
			for (let t of e) for (let e of Z(t.target)) e(t)
		}));

	function ee(e, t) {
		Z(e).add(t), J.observe(e)
	}

	function te(e, t) {
		let i = Z(e);
		i.delete(t), i.size || J.unobserve(e)
	}

	function ie(e) {
		var t;
		return null != (t = ae(e)) ? t : oe(e, "media-controller")
	}

	function ae(e) {
		var t;
		let {MEDIA_CONTROLLER: i} = f, a = e.getAttribute(i);
		if (a) return null == (t = de(e)) ? void 0 : t.getElementById(a)
	}

	var re = (e, t, i = ".value") => {
			let a = e.querySelector(i);
			a && (a.textContent = t)
		}, ne = (e, t) => ((e, t) => {
			let i = `slot[name="${t}"]`, a = e.shadowRoot.querySelector(i);
			return a ? a.children : []
		})(e, t)[0], se = (e, t) => !(!e || !t) && (!(null == e || !e.contains(t)) || se(e, t.getRootNode().host)),
		oe = (e, t) => {
			if (!e) return null;
			return e.closest(t) || oe(e.getRootNode().host, t)
		};

	function le(e = document) {
		var t;
		let i = null == e ? void 0 : e.activeElement;
		return i ? null != (t = le(i.shadowRoot)) ? t : i : null
	}

	function de(e) {
		var t;
		let i = null == (t = null == e ? void 0 : e.getRootNode) ? void 0 : t.call(e);
		return i instanceof ShadowRoot || i instanceof Document ? i : null
	}

	function ue(e, t) {
		return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
	}

	function he(e, t) {
		let i = function (e, t) {
			var i;
			let a;
			for (a of e.querySelectorAll("style")) {
				let e;
				try {
					e = null == (i = a.sheet) ? void 0 : i.cssRules
				} catch {
					continue
				}
				for (let i of null != e ? e : []) if (t(i.selectorText)) return i
			}
		}(e, (e => e === t));
		return i || ce(e, t)
	}

	function ce(e, t) {
		var i, a;
		let r = null != (i = e.querySelectorAll("style")) ? i : [], n = null == r ? void 0 : r[r.length - 1];
		return null != n && n.sheet ? (null == n || n.sheet.insertRule(`${t}{}`, n.sheet.cssRules.length), null == (a = n.sheet.cssRules) ? void 0 : a[n.sheet.cssRules.length - 1]) : (console.warn("Media Chrome: No style sheet found on style tag of", e), {
			style: {
				setProperty: () => {
				}, removeProperty: () => "", getPropertyValue: () => ""
			}
		})
	}

	function me(e, t, i = Number.NaN) {
		let a = e.getAttribute(t);
		return null != a ? +a : i
	}

	function fe(e, t, i) {
		let a = +i;
		null == i || Number.isNaN(a) ? e.hasAttribute(t) && e.removeAttribute(t) : me(e, t, void 0) !== a && e.setAttribute(t, `${a}`)
	}

	function pe(e, t) {
		return e.hasAttribute(t)
	}

	function ge(e, t, i) {
		null != i ? pe(e, t) != i && e.toggleAttribute(t, i) : e.hasAttribute(t) && e.removeAttribute(t)
	}

	function ve(e, t, i = null) {
		var a;
		return null != (a = e.getAttribute(t)) ? a : i
	}

	function Ee(e, t, i) {
		if (null == i) return void (e.hasAttribute(t) && e.removeAttribute(t));
		let a = `${i}`;
		ve(e, t, void 0) !== a && e.setAttribute(t, a)
	}

	var be, ye = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, Te = (e, t, i) => (ye(e, t, "read from private field"), i ? i.call(e) : t.get(e)),
		Ae = (e, t, i, a) => (ye(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		_e = X.createElement("template");
	_e.innerHTML = "\n<style>\n  :host {\n    display: var(--media-control-display, var(--media-gesture-receiver-display, inline-block));\n    box-sizing: border-box;\n  }\n</style>\n";
	var ke = class extends z.HTMLElement {
		constructor(e = {}) {
			if (super(), ((e, t, i) => {
				if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
				t instanceof WeakSet ? t.add(e) : t.set(e, i)
			})(this, be, void 0), !this.shadowRoot) {
				let t = this.attachShadow({mode: "open"}), i = _e.content.cloneNode(!0);
				this.nativeEl = i;
				let a = e.slotTemplate;
				a || (a = X.createElement("template"), a.innerHTML = `<slot>${e.defaultContent || ""}</slot>`), this.nativeEl.appendChild(a.content.cloneNode(!0)), t.appendChild(i)
			}
		}

		static get observedAttributes() {
			return [f.MEDIA_CONTROLLER, v.MEDIA_PAUSED]
		}

		get mediaPaused() {
			return pe(this, v.MEDIA_PAUSED)
		}

		set mediaPaused(e) {
			ge(this, v.MEDIA_PAUSED, e)
		}

		attributeChangedCallback(e, t, i) {
			var a, r, n, s, o;
			e === f.MEDIA_CONTROLLER && (t && (null == (r = null == (a = Te(this, be)) ? void 0 : a.unassociateElement) || r.call(a, this), Ae(this, be, null)), i && this.isConnected && (Ae(this, be, null == (n = this.getRootNode()) ? void 0 : n.getElementById(i)), null == (o = null == (s = Te(this, be)) ? void 0 : s.associateElement) || o.call(s, this)))
		}

		connectedCallback() {
			var e, t, i, a;
			this.tabIndex = -1, this.setAttribute("aria-hidden", "true"), Ae(this, be, function (e) {
				var t;
				let i = e.getAttribute(f.MEDIA_CONTROLLER);
				return i ? null == (t = e.getRootNode()) ? void 0 : t.getElementById(i) : oe(e, "media-controller")
			}(this)), this.getAttribute(f.MEDIA_CONTROLLER) && (null == (t = null == (e = Te(this, be)) ? void 0 : e.associateElement) || t.call(e, this)), null == (i = Te(this, be)) || i.addEventListener("pointerdown", this), null == (a = Te(this, be)) || a.addEventListener("click", this)
		}

		disconnectedCallback() {
			var e, t, i, a;
			this.getAttribute(f.MEDIA_CONTROLLER) && (null == (t = null == (e = Te(this, be)) ? void 0 : e.unassociateElement) || t.call(e, this)), null == (i = Te(this, be)) || i.removeEventListener("pointerdown", this), null == (a = Te(this, be)) || a.removeEventListener("click", this), Ae(this, be, null)
		}

		handleEvent(e) {
			var t;
			let i = null == (t = e.composedPath()) ? void 0 : t[0];
			if (["video", "media-controller"].includes(null == i ? void 0 : i.localName)) if ("pointerdown" === e.type) this._pointerType = e.pointerType; else if ("click" === e.type) {
				let {clientX: t, clientY: i} = e, {left: a, top: r, width: n, height: s} = this.getBoundingClientRect(),
					o = t - a, l = i - r;
				if (o < 0 || l < 0 || o > n || l > s || 0 === n && 0 === s) return;
				let {pointerType: d = this._pointerType} = e;
				if (this._pointerType = void 0, d === k) return void this.handleTap(e);
				if (d === _) return void this.handleMouseClick(e)
			}
		}

		handleTap(e) {
		}

		handleMouseClick(e) {
			let t = this.mediaPaused ? m.MEDIA_PLAY_REQUEST : m.MEDIA_PAUSE_REQUEST;
			this.dispatchEvent(new z.CustomEvent(t, {composed: !0, bubbles: !0}))
		}
	};
	be = new WeakMap, z.customElements.get("media-gesture-receiver") || z.customElements.define("media-gesture-receiver", ke);
	var Se, we, Le, Re, Ie, De, Ce, xe, Me, Oe, Pe, Ne, Ue = Object.defineProperty, Fe = (e, t, i) => (((e, t, i) => {
			t in e ? Ue(e, t, {enumerable: !0, configurable: !0, writable: !0, value: i}) : e[t] = i
		})(e, "symbol" != typeof t ? t + "" : t, i), i), Be = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, $e = (e, t, i) => (Be(e, t, "read from private field"), i ? i.call(e) : t.get(e)), He = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, We = (e, t, i, a) => (Be(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		Ge = (e, t, i) => (Be(e, t, "access private method"), i), Ve = {
			AUDIO: "audio",
			AUTOHIDE: "autohide",
			BREAKPOINTS: "breakpoints",
			GESTURES_DISABLED: "gesturesdisabled",
			KEYBOARD_CONTROL: "keyboardcontrol",
			NO_AUTOHIDE: "noautohide",
			USER_INACTIVE: "userinactive"
		}, Ke = X.createElement("template");
	Ke.innerHTML = `\n  <style>\n    \n    :host([${v.MEDIA_IS_FULLSCREEN}]) ::slotted([slot=media]) {\n      outline: none;\n    }\n\n    :host {\n      box-sizing: border-box;\n      position: relative;\n      display: inline-block;\n      line-height: 0;\n      background-color: var(--media-background-color, #000);\n    }\n\n    :host(:not([${Ve.AUDIO}])) [part~=layer]:not([part~=media-layer]) {\n      position: absolute;\n      top: 0;\n      left: 0;\n      bottom: 0;\n      right: 0;\n      display: flex;\n      flex-flow: column nowrap;\n      align-items: start;\n      pointer-events: none;\n      background: none;\n    }\n\n    slot[name=media] {\n      display: var(--media-slot-display, contents);\n    }\n\n    \n    :host([${Ve.AUDIO}]) slot[name=media] {\n      display: var(--media-slot-display, none);\n    }\n\n    \n    :host([${Ve.AUDIO}]) [part~=layer][part~=gesture-layer] {\n      height: 0;\n      display: block;\n    }\n\n    \n    :host(:not([${Ve.AUDIO}])[${Ve.GESTURES_DISABLED}]) ::slotted([slot=gestures-chrome]),\n    :host(:not([${Ve.AUDIO}])[${Ve.GESTURES_DISABLED}]) media-gesture-receiver[slot=gestures-chrome] {\n      display: none;\n    }\n\n    \n    ::slotted(:not([slot=media]):not([slot=poster]):not(media-loading-indicator):not([hidden])) {\n      pointer-events: auto;\n    }\n\n    :host(:not([${Ve.AUDIO}])) *[part~=layer][part~=centered-layer] {\n      align-items: center;\n      justify-content: center;\n    }\n\n    :host(:not([${Ve.AUDIO}])) ::slotted(media-gesture-receiver[slot=gestures-chrome]),\n    :host(:not([${Ve.AUDIO}])) media-gesture-receiver[slot=gestures-chrome] {\n      align-self: stretch;\n      flex-grow: 1;\n    }\n\n    slot[name=middle-chrome] {\n      display: inline;\n      flex-grow: 1;\n      pointer-events: none;\n      background: none;\n    }\n\n    \n    ::slotted([slot=media]),\n    ::slotted([slot=poster]) {\n      width: 100%;\n      height: 100%;\n    }\n\n    \n    :host(:not([${Ve.AUDIO}])) .spacer {\n      flex-grow: 1;\n    }\n\n    \n    :host(:-webkit-full-screen) {\n      \n      width: 100% !important;\n      height: 100% !important;\n    }\n\n    \n    ::slotted(:not([slot=media]):not([slot=poster]):not([${Ve.NO_AUTOHIDE}]):not([hidden])) {\n      opacity: 1;\n      transition: opacity 0.25s;\n    }\n\n    \n    :host([${Ve.USER_INACTIVE}]:not([${v.MEDIA_PAUSED}]):not([${v.MEDIA_IS_AIRPLAYING}]):not([${v.MEDIA_IS_CASTING}]):not([${Ve.AUDIO}])) ::slotted(:not([slot=media]):not([slot=poster]):not([${Ve.NO_AUTOHIDE}])) {\n      opacity: 0;\n      transition: opacity 1s;\n    }\n\n    :host([${Ve.USER_INACTIVE}]:not([${v.MEDIA_PAUSED}]):not([${v.MEDIA_IS_CASTING}]):not([${Ve.AUDIO}])) ::slotted([slot=media]) {\n      cursor: none;\n    }\n\n    ::slotted(media-control-bar)  {\n      align-self: stretch;\n    }\n\n    \n    :host(:not([${Ve.AUDIO}])[${v.MEDIA_HAS_PLAYED}]) slot[name=poster] {\n      display: none;\n    }\n\n    ::slotted([role="menu"]) {\n      align-self: end;\n    }\n\n    ::slotted([role="dialog"]) {\n      align-self: center;\n    }\n  </style>\n\n  <slot name="media" part="layer media-layer"></slot>\n  <slot name="poster" part="layer poster-layer"></slot>\n  <slot name="gestures-chrome" part="layer gesture-layer">\n    <media-gesture-receiver slot="gestures-chrome"></media-gesture-receiver>\n  </slot>\n  <span part="layer vertical-layer">\n    <slot name="top-chrome" part="top chrome"></slot>\n    <slot name="middle-chrome" part="middle chrome"></slot>\n    <slot name="centered-chrome" part="layer centered-layer center centered chrome"></slot>\n    \n    <slot part="bottom chrome"></slot>\n  </span>\n`;
	var qe = Object.values(v), Ye = "sm:384 md:576 lg:768 xl:960";

	function je(e) {
		!function (e, t) {
			var i;
			if (!e.isConnected) return;
			let a = null != (i = e.getAttribute(Ve.BREAKPOINTS)) ? i : Ye, r = function (e) {
				let t = e.split(/\s+/);
				return Object.fromEntries(t.map((e => e.split(":"))))
			}(a), n = function (e, t) {
				return Object.keys(e).filter((i => t >= e[i]))
			}(r, t), s = !1;
			if (Object.keys(r).forEach((t => {
				n.includes(t) ? e.hasAttribute(`breakpoint${t}`) || (e.setAttribute(`breakpoint${t}`, ""), s = !0) : e.hasAttribute(`breakpoint${t}`) && (e.removeAttribute(`breakpoint${t}`), s = !0)
			})), s) {
				let t = new CustomEvent(E.BREAKPOINTS_CHANGE, {detail: n});
				e.dispatchEvent(t)
			}
		}(e.target, e.contentRect.width)
	}

	var ze = class extends z.HTMLElement {
		constructor() {
			super(), He(this, Le), He(this, Ie), He(this, Ce), He(this, Me), He(this, Pe), He(this, Se, 0), He(this, we, void 0), Fe(this, "breakpointsComputed", !1), this.shadowRoot || (this.attachShadow({mode: "open"}), this.shadowRoot.appendChild(Ke.content.cloneNode(!0)));
			new MutationObserver((e => {
				let t = this.media;
				for (let i of e) "childList" === i.type && (i.removedNodes.forEach((e => {
					if ("media" == e.slot && i.target == this) {
						let a = i.previousSibling && i.previousSibling.previousElementSibling;
						if (a && t) {
							let t = "media" !== a.slot;
							for (; null !== (a = a.previousSibling);) "media" == a.slot && (t = !1);
							t && this.mediaUnsetCallback(e)
						} else this.mediaUnsetCallback(e)
					}
				})), t && i.addedNodes.forEach((e => {
					e === t && this.handleMediaUpdated(t)
				})))
			})).observe(this, {childList: !0, subtree: !0});
			let e = !1;
			ee(this, (t => {
				e || (setTimeout((() => {
					je(t), e = !1, this.breakpointsComputed || (this.breakpointsComputed = !0, this.dispatchEvent(new CustomEvent(E.BREAKPOINTS_COMPUTED, {
						bubbles: !0,
						composed: !0
					})))
				}), 0), e = !0)
			}));
			let t = this.querySelector(":scope > slot[slot=media]");
			t && t.addEventListener("slotchange", (() => {
				t.assignedElements({flatten: !0}).length ? this.handleMediaUpdated(this.media) : $e(this, we) && this.mediaUnsetCallback($e(this, we))
			}))
		}

		static get observedAttributes() {
			return [Ve.AUTOHIDE, Ve.GESTURES_DISABLED].concat(qe).filter((e => ![v.MEDIA_RENDITION_LIST, v.MEDIA_AUDIO_TRACK_LIST, v.MEDIA_CHAPTERS_CUES].includes(e)))
		}

		get media() {
			let e = this.querySelector(":scope > [slot=media]");
			return "SLOT" == (null == e ? void 0 : e.nodeName) && (e = e.assignedElements({flatten: !0})[0]), e
		}

		get autohide() {
			return void 0 === this._autohide ? 2 : this._autohide
		}

		set autohide(e) {
			e = Number(e), this._autohide = isNaN(e) ? 0 : e
		}

		attributeChangedCallback(e, t, i) {
			e.toLowerCase() == Ve.AUTOHIDE && (this.autohide = i)
		}

		async handleMediaUpdated(e) {
			e && (We(this, we, e), e.localName.includes("-") && await z.customElements.whenDefined(e.localName), this.mediaSetCallback(e))
		}

		connectedCallback() {
			var e;
			let t = null != this.getAttribute(Ve.AUDIO) ? I.AUDIO_PLAYER() : I.VIDEO_PLAYER();
			this.setAttribute("role", "region"), this.setAttribute("aria-label", t), this.handleMediaUpdated(this.media), this.setAttribute(Ve.USER_INACTIVE, ""), this.addEventListener("pointerdown", this), this.addEventListener("pointermove", this), this.addEventListener("pointerup", this), this.addEventListener("mouseleave", this), this.addEventListener("keyup", this), null == (e = z.window) || e.addEventListener("mouseup", this)
		}

		disconnectedCallback() {
			var e;
			this.media && this.mediaUnsetCallback(this.media), null == (e = z.window) || e.removeEventListener("mouseup", this)
		}

		mediaSetCallback(e) {
		}

		mediaUnsetCallback(e) {
			We(this, we, null)
		}

		handleEvent(e) {
			switch (e.type) {
				case"pointerdown":
					We(this, Se, e.timeStamp);
					break;
				case"pointermove":
					Ge(this, Le, Re).call(this, e);
					break;
				case"pointerup":
					Ge(this, Ie, De).call(this, e);
					break;
				case"mouseleave":
					Ge(this, Ce, xe).call(this);
					break;
				case"mouseup":
					this.removeAttribute(Ve.KEYBOARD_CONTROL);
					break;
				case"keyup":
					Ge(this, Pe, Ne).call(this), this.setAttribute(Ve.KEYBOARD_CONTROL, "")
			}
		}
	};
	Se = new WeakMap, we = new WeakMap, Le = new WeakSet, Re = function (e) {
		"mouse" !== e.pointerType && e.timeStamp - $e(this, Se) < 250 || (Ge(this, Me, Oe).call(this), clearTimeout(this._inactiveTimeout), [this, this.media].includes(e.target) && Ge(this, Pe, Ne).call(this))
	}, Ie = new WeakSet, De = function (e) {
		if ("touch" === e.pointerType) {
			let t = !this.hasAttribute(Ve.USER_INACTIVE);
			[this, this.media].includes(e.target) && t ? Ge(this, Ce, xe).call(this) : Ge(this, Pe, Ne).call(this)
		} else e.composedPath().some((e => ["media-play-button", "media-fullscreen-button"].includes(null == e ? void 0 : e.localName))) && Ge(this, Pe, Ne).call(this)
	}, Ce = new WeakSet, xe = function () {
		if (this.autohide < 0 || this.hasAttribute(Ve.USER_INACTIVE)) return;
		this.setAttribute(Ve.USER_INACTIVE, "");
		let e = new z.CustomEvent(E.USER_INACTIVE, {composed: !0, bubbles: !0, detail: !0});
		this.dispatchEvent(e)
	}, Me = new WeakSet, Oe = function () {
		if (!this.hasAttribute(Ve.USER_INACTIVE)) return;
		this.removeAttribute(Ve.USER_INACTIVE);
		let e = new z.CustomEvent(E.USER_INACTIVE, {composed: !0, bubbles: !0, detail: !1});
		this.dispatchEvent(e)
	}, Pe = new WeakSet, Ne = function () {
		Ge(this, Me, Oe).call(this), clearTimeout(this._inactiveTimeout), !(this.autohide < 0) && (this._inactiveTimeout = setTimeout((() => {
			Ge(this, Ce, xe).call(this)
		}), 1e3 * this.autohide))
	}, z.customElements.get("media-container") || z.customElements.define("media-container", ze);
	var Xe, Qe, Ze, Je, et, tt, it = (e, t, i) => {
		if (!t.has(e)) throw TypeError("Cannot " + i)
	}, at = (e, t, i) => (it(e, t, "read from private field"), i ? i.call(e) : t.get(e)), rt = (e, t, i) => {
		if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
		t instanceof WeakSet ? t.add(e) : t.set(e, i)
	}, nt = (e, t, i, a) => (it(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i), st = class {
		constructor(e, t, {defaultValue: i} = {defaultValue: void 0}) {
			rt(this, et), rt(this, Xe, void 0), rt(this, Qe, void 0), rt(this, Ze, void 0), rt(this, Je, new Set), nt(this, Xe, e), nt(this, Qe, t), nt(this, Ze, new Set(i))
		}

		get length() {
			return at(this, et, tt).size
		}

		get value() {
			var e;
			return null != (e = [...at(this, et, tt)].join(" ")) ? e : ""
		}

		set value(e) {
			var t;
			e !== this.value && (nt(this, Je, new Set), this.add(...null != (t = null == e ? void 0 : e.split(" ")) ? t : []))
		}

		[Symbol.iterator]() {
			return at(this, et, tt).values()
		}

		toString() {
			return this.value
		}

		item(e) {
			return [...at(this, et, tt)][e]
		}

		values() {
			return at(this, et, tt).values()
		}

		forEach(e) {
			at(this, et, tt).forEach(e)
		}

		add(...e) {
			var t, i;
			e.forEach((e => at(this, Je).add(e))), ("" !== this.value || null != (t = at(this, Xe)) && t.hasAttribute(`${at(this, Qe)}`)) && (null == (i = at(this, Xe)) || i.setAttribute(`${at(this, Qe)}`, `${this.value}`))
		}

		remove(...e) {
			var t;
			e.forEach((e => at(this, Je).delete(e))), null == (t = at(this, Xe)) || t.setAttribute(`${at(this, Qe)}`, `${this.value}`)
		}

		contains(e) {
			return at(this, et, tt).has(e)
		}

		toggle(e, t) {
			return void 0 !== t ? t ? (this.add(e), !0) : (this.remove(e), !1) : this.contains(e) ? (this.remove(e), !1) : (this.add(e), !0)
		}

		replace(e, t) {
			return this.remove(e), this.add(t), e === t
		}
	};
	Xe = new WeakMap, Qe = new WeakMap, Ze = new WeakMap, Je = new WeakMap, et = new WeakSet, tt = function () {
		return at(this, Je).size ? at(this, Je) : at(this, Ze)
	};
	var ot = (e = "") => {
			let [t, i, a] = e.split(":");
			return t = "cc" === t ? "captions" : "subtitles", {
				kind: t,
				language: i,
				label: a ? decodeURIComponent(a) : void 0
			}
		}, lt = (e = "", t = {}) => ((e = "") => e.split(/\s+/))(e).map((e => {
			let i = ot(e);
			return {...t, ...i}
		})),
		dt = e => e ? Array.isArray(e) ? e.map((e => "string" == typeof e ? ot(e) : e)) : "string" == typeof e ? lt(e) : [e] : [],
		ut = ({
			      kind: e,
			      label: t,
			      language: i
		      } = {kind: "subtitles"}) => t ? `${"captions" === e ? "cc" : "sb"}:${i}:${encodeURIComponent(t)}` : i,
		ht = (e = []) => Array.prototype.map.call(e, ut).join(" "), ct = e => {
			let t = Object.entries(e).map((([e, t]) => ((e, t) => i => i[e] === t)(e, t)));
			return e => t.every((t => t(e)))
		}, mt = (e, t = [], i = []) => {
			let a = dt(i).map(ct);
			Array.from(t).filter((e => a.some((t => t(e))))).forEach((t => {
				t.mode = e
			}))
		}, ft = (e, t = (() => !0)) => {
			if (null == e || !e.textTracks) return [];
			let i = "function" == typeof t ? t : ct(t);
			return Array.from(e.textTracks).filter(i)
		}, pt = e => {
			var t;
			return !(null == (t = e.mediaSubtitlesShowing) || !t.length) || e.hasAttribute(v.MEDIA_SUBTITLES_SHOWING)
		}, gt = {
			enter: "requestFullscreen",
			exit: "exitFullscreen",
			rootEvents: ["fullscreenchange"],
			mediaEvents: [],
			element: "fullscreenElement",
			error: "fullscreenerror",
			enabled: "fullscreenEnabled"
		};
	void 0 === X.fullscreenElement && (gt.enter = "webkitRequestFullScreen", gt.exit = null != X.webkitExitFullscreen ? "webkitExitFullscreen" : "webkitCancelFullScreen", gt.rootEvents = ["webkitfullscreenchange"], gt.mediaEvents = ["webkitbeginfullscreen", "webkitendfullscreen"], gt.element = "webkitFullscreenElement", gt.error = "webkitfullscreenerror", gt.enabled = "webkitFullscreenEnabled");
	var vt, Et, bt, yt, Tt, At, _t, kt, St, wt, Lt, Rt, It, Dt, Ct = () => {
			var e, t;
			return vt || (vt = null == (t = null == (e = X) ? void 0 : e.createElement) ? void 0 : t.call(e, "video"))
		}, xt = /.*Version\/.*Safari\/.*/.test(z.navigator.userAgent),
		Mt = (e = Ct()) => (!z.matchMedia("(display-mode: standalone)").matches || !xt) && "function" == typeof (null == e ? void 0 : e.requestPictureInPicture),
		Ot = (e = Ct()) => {
			let t = X[gt.enabled];
			return !t && e && (t = "webkitSupportsFullscreen" in e), t
		}, Pt = Ot(), Nt = Mt(), Ut = !!z.WebKitPlaybackTargetAvailabilityEvent, Ft = !!z.chrome,
		Bt = e => ft(e.media, (e => [y.SUBTITLES, y.CAPTIONS].includes(e.kind))).sort(((e, t) => e.kind >= t.kind ? 1 : -1)),
		$t = e => ft(e.media, (e => e.mode === A && [y.SUBTITLES, y.CAPTIONS].includes(e.kind))), Ht = (e, t) => {
			let i = Bt(e), a = $t(e), r = !!a.length;
			if (i.length) if (!1 === t || r && !0 !== t) mt(T, i, a); else if (!0 === t || !r && !1 !== t) {
				let t = i[0], {options: r} = e;
				if (null == r || !r.noSubtitlesLangPref) {
					let e = globalThis.localStorage.getItem("media-chrome-pref-subtitles-lang"),
						a = e ? [e, ...globalThis.navigator.languages] : globalThis.navigator.languages,
						r = i.filter((e => a.some((t => e.language.toLowerCase().startsWith(t.split("-")[0]))))).sort(((e, t) => a.findIndex((t => e.language.toLowerCase().startsWith(t.split("-")[0]))) - a.findIndex((e => t.language.toLowerCase().startsWith(e.split("-")[0])))));
					r[0] && (t = r[0])
				}
				let {language: n, label: s, kind: o} = t;
				mt(T, i, a), mt(A, i, [{language: n, label: s, kind: o}])
			}
		},
		Wt = (e, t) => e === t || typeof e == typeof t && (!("number" != typeof e || !Number.isNaN(e) || !Number.isNaN(t)) || "object" == typeof e && (Array.isArray(e) ? Gt(e, t) : Object.entries(e).every((([e, i]) => e in t && Wt(i, t[e]))))),
		Gt = (e, t) => {
			let i = Array.isArray(e), a = Array.isArray(t);
			return i === a && (!i && !a || e.length === t.length && e.every(((e, i) => Wt(e, t[i]))))
		}, Vt = Object.values(L), Kt = (async (e = Ct()) => {
			if (!e) return !1;
			let t = e.volume;
			return e.volume = t / 2 + .1, await B(0), e.volume !== t
		})().then((e => Et = e)), qt = {
			mediaPaused: {
				get(e) {
					var t;
					let {media: i} = e;
					return null == (t = null == i ? void 0 : i.paused) || t
				}, set(e, t) {
					var i;
					let {media: a} = t;
					a && (e ? a.pause() : null == (i = a.play()) || i.catch((() => {
					})))
				}, mediaEvents: ["play", "playing", "pause", "emptied"]
			},
			mediaHasPlayed: {
				get(e, t) {
					let {media: i} = e;
					return !!i && (t ? "playing" === t.type : !i.paused)
				}, mediaEvents: ["playing", "emptied"]
			},
			mediaEnded: {
				get(e) {
					var t;
					let {media: i} = e;
					return null != (t = null == i ? void 0 : i.ended) && t
				}, mediaEvents: ["seeked", "ended", "emptied"]
			},
			mediaPlaybackRate: {
				get(e) {
					var t;
					let {media: i} = e;
					return null != (t = null == i ? void 0 : i.playbackRate) ? t : 1
				}, set(e, t) {
					let {media: i} = t;
					i && Number.isFinite(+e) && (i.playbackRate = +e)
				}, mediaEvents: ["ratechange", "loadstart"]
			},
			mediaMuted: {
				get(e) {
					var t;
					let {media: i} = e;
					return null != (t = null == i ? void 0 : i.muted) && t
				}, set(e, t) {
					let {media: i} = t;
					i && (i.muted = e)
				}, mediaEvents: ["volumechange"]
			},
			mediaVolume: {
				get(e) {
					var t;
					let {media: i} = e;
					return null != (t = null == i ? void 0 : i.volume) ? t : 1
				}, set(e, t) {
					let {media: i} = t;
					if (i) {
						try {
							null == e ? z.localStorage.removeItem("media-chrome-pref-volume") : z.localStorage.setItem("media-chrome-pref-volume", e.toString())
						} catch {
						}
						Number.isFinite(+e) && (i.volume = +e)
					}
				}, mediaEvents: ["volumechange"], stateOwnersUpdateHandlers: [(e, t) => {
					let {options: {noVolumePref: i}} = t;
					if (!i) try {
						let i = z.localStorage.getItem("media-chrome-pref-volume");
						if (null == i) return;
						qt.mediaVolume.set(+i, t), e(i)
					} catch (e) {
						console.debug("Error getting volume pref", e)
					}
				}]
			},
			mediaVolumeLevel: {
				get(e) {
					let {media: t} = e;
					return void 0 === (null == t ? void 0 : t.volume) ? "high" : t.muted || 0 === t.volume ? "off" : t.volume < .5 ? "low" : t.volume < .75 ? "medium" : "high"
				}, mediaEvents: ["volumechange"]
			},
			mediaCurrentTime: {
				get(e) {
					var t;
					let {media: i} = e;
					return null != (t = null == i ? void 0 : i.currentTime) ? t : 0
				}, set(e, t) {
					let {media: i} = t;
					!i || 0 === i.readyState || (i.currentTime = e)
				}, mediaEvents: ["timeupdate", "loadedmetadata"]
			},
			mediaDuration: {
				get(e) {
					let {media: t, options: {defaultDuration: i} = {}} = e;
					return !i || t && t.duration && !Number.isNaN(t.duration) && Number.isFinite(t.duration) ? Number.isFinite(null == t ? void 0 : t.duration) ? t.duration : Number.NaN : i
				}, mediaEvents: ["durationchange", "loadedmetadata", "emptied"]
			},
			mediaLoading: {
				get(e) {
					let {media: t} = e;
					return (null == t ? void 0 : t.readyState) < 3
				}, mediaEvents: ["waiting", "playing", "emptied"]
			},
			mediaSeekable: {
				get(e) {
					var t;
					let {media: i} = e;
					if (null == (t = null == i ? void 0 : i.seekable) || !t.length) return;
					let a = i.seekable.start(0), r = i.seekable.end(i.seekable.length - 1);
					return a || r ? [Number(a.toFixed(3)), Number(r.toFixed(3))] : void 0
				}, mediaEvents: ["loadedmetadata", "emptied", "progress", "seekablechange"]
			},
			mediaBuffered: {
				get(e) {
					var t;
					let {media: i} = e, a = null != (t = null == i ? void 0 : i.buffered) ? t : [];
					return Array.from(a).map(((e, t) => [Number(a.start(t).toFixed(3)), Number(a.end(t).toFixed(3))]))
				}, mediaEvents: ["progress", "emptied"]
			},
			mediaStreamType: {
				get(e) {
					let {media: t, options: {defaultStreamType: i} = {}} = e,
						a = [L.LIVE, L.ON_DEMAND].includes(i) ? i : void 0;
					if (!t) return a;
					let {streamType: r} = t;
					if (Vt.includes(r)) return r === L.UNKNOWN ? a : r;
					let n = t.duration;
					return n === 1 / 0 ? L.LIVE : Number.isFinite(n) ? L.ON_DEMAND : a
				}, mediaEvents: ["emptied", "durationchange", "loadedmetadata", "streamtypechange"]
			},
			mediaTargetLiveWindow: {
				get(e) {
					let {media: t} = e;
					if (!t) return Number.NaN;
					let {targetLiveWindow: i} = t, a = qt.mediaStreamType.get(e);
					return null != i && !Number.isNaN(i) || a !== L.LIVE ? i : 0
				},
				mediaEvents: ["emptied", "durationchange", "loadedmetadata", "streamtypechange", "targetlivewindowchange"]
			},
			mediaTimeIsLive: {
				get(e) {
					let {media: t, options: {liveEdgeOffset: i = 10} = {}} = e;
					if (!t) return !1;
					if ("number" == typeof t.liveEdgeStart) return !Number.isNaN(t.liveEdgeStart) && t.currentTime >= t.liveEdgeStart;
					if (qt.mediaStreamType.get(e) !== L.LIVE) return !1;
					let a = t.seekable;
					if (!a) return !0;
					if (!a.length) return !1;
					let r = a.end(a.length - 1) - i;
					return t.currentTime >= r
				}, mediaEvents: ["playing", "timeupdate", "progress", "waiting", "emptied"]
			},
			mediaSubtitlesList: {
				get: e => Bt(e).map((({kind: e, label: t, language: i}) => ({
					kind: e,
					label: t,
					language: i
				}))), mediaEvents: ["loadstart"], textTracksEvents: ["addtrack", "removetrack"]
			},
			mediaSubtitlesShowing: {
				get: e => $t(e).map((({kind: e, label: t, language: i}) => ({
					kind: e,
					label: t,
					language: i
				}))),
				mediaEvents: ["loadstart"],
				textTracksEvents: ["addtrack", "removetrack", "change"],
				stateOwnersUpdateHandlers: [(e, t) => {
					var i, a;
					let {media: r, options: n} = t;
					if (!r) return;
					let s = e => {
						var i;
						!n.defaultSubtitles || e && ![y.CAPTIONS, y.SUBTITLES].includes(null == (i = null == e ? void 0 : e.track) ? void 0 : i.kind) || Ht(t, !0)
					};
					return null == (i = r.textTracks) || i.addEventListener("addtrack", s), null == (a = r.textTracks) || a.addEventListener("removetrack", s), s(), () => {
						var e, t;
						null == (e = r.textTracks) || e.removeEventListener("addtrack", s), null == (t = r.textTracks) || t.removeEventListener("removetrack", s)
					}
				}]
			},
			mediaChaptersCues: {
				get(e) {
					var t;
					let {media: i} = e;
					if (!i) return [];
					let [a] = ft(i, {kind: y.CHAPTERS});
					return Array.from(null != (t = null == a ? void 0 : a.cues) ? t : []).map((({
						                                                                            text: e,
						                                                                            startTime: t,
						                                                                            endTime: i
					                                                                            }) => ({
						text: e,
						startTime: t,
						endTime: i
					})))
				},
				mediaEvents: ["loadstart", "loadedmetadata"],
				textTracksEvents: ["addtrack", "removetrack", "change"],
				stateOwnersUpdateHandlers: [(e, t) => {
					let {media: i} = t;
					if (!i) return;
					let a = i.querySelector('track[kind="chapters"][default][src]');
					return null == a || a.addEventListener("load", e), () => {
						null == a || a.removeEventListener("load", e)
					}
				}]
			},
			mediaIsPip: {
				get(e) {
					var t, i;
					let {media: a, documentElement: r} = e;
					if (!a || !r || !r.pictureInPictureElement) return !1;
					if (r.pictureInPictureElement === a) return !0;
					if (r.pictureInPictureElement instanceof HTMLMediaElement) return !(null == (t = a.localName) || !t.includes("-")) && se(a, r.pictureInPictureElement);
					if (r.pictureInPictureElement.localName.includes("-")) {
						let e = r.pictureInPictureElement.shadowRoot;
						for (; null != e && e.pictureInPictureElement;) {
							if (e.pictureInPictureElement === a) return !0;
							e = null == (i = e.pictureInPictureElement) ? void 0 : i.shadowRoot
						}
					}
					return !1
				}, set(e, t) {
					let {media: i} = t;
					if (i) if (e) {
						if (!X.pictureInPictureEnabled) return void console.warn("MediaChrome: Picture-in-picture is not enabled");
						if (!i.requestPictureInPicture) return void console.warn("MediaChrome: The current media does not support picture-in-picture");
						let e = () => {
							console.warn("MediaChrome: The media is not ready for picture-in-picture. It must have a readyState > 0.")
						};
						i.requestPictureInPicture().catch((t => {
							if (11 !== t.code) throw t;
							if (i.src) {
								if (0 !== i.readyState || "none" !== i.preload) throw t;
								{
									let t = () => {
										i.removeEventListener("loadedmetadata", a), i.preload = "none"
									}, a = () => {
										i.requestPictureInPicture().catch(e), t()
									};
									i.addEventListener("loadedmetadata", a), i.preload = "metadata", setTimeout((() => {
										0 === i.readyState && e(), t()
									}), 1e3)
								}
							} else console.warn("MediaChrome: The media is not ready for picture-in-picture. It must have a src set.")
						}))
					} else X.pictureInPictureElement && X.exitPictureInPicture()
				}, mediaEvents: ["enterpictureinpicture", "leavepictureinpicture"]
			},
			mediaRenditionList: {
				get(e) {
					var t;
					let {media: i} = e;
					return [...null != (t = null == i ? void 0 : i.videoRenditions) ? t : []].map((e => ({...e})))
				}, mediaEvents: ["emptied", "loadstart"], videoRenditionsEvents: ["addrendition", "removerendition"]
			},
			mediaRenditionSelected: {
				get(e) {
					var t, i, a;
					let {media: r} = e;
					return null == (a = null == (i = null == r ? void 0 : r.videoRenditions) ? void 0 : i[null == (t = r.videoRenditions) ? void 0 : t.selectedIndex]) ? void 0 : a.id
				}, set(e, t) {
					let {media: i} = t;
					if (null == i || !i.videoRenditions) return void console.warn("MediaController: Rendition selection not supported by this media.");
					let a = e, r = Array.prototype.findIndex.call(i.videoRenditions, (e => e.id == a));
					i.videoRenditions.selectedIndex != r && (i.videoRenditions.selectedIndex = r)
				}, mediaEvents: ["emptied"], videoRenditionsEvents: ["addrendition", "removerendition", "change"]
			},
			mediaAudioTrackList: {
				get(e) {
					var t;
					let {media: i} = e;
					return [...null != (t = null == i ? void 0 : i.audioTracks) ? t : []]
				}, mediaEvents: ["emptied", "loadstart"], audioTracksEvents: ["addtrack", "removetrack"]
			},
			mediaAudioTrackEnabled: {
				get(e) {
					var t, i;
					let {media: a} = e;
					return null == (i = [...null != (t = null == a ? void 0 : a.audioTracks) ? t : []].find((e => e.enabled))) ? void 0 : i.id
				}, set(e, t) {
					let {media: i} = t;
					if (null == i || !i.audioTracks) return void console.warn("MediaChrome: Audio track selection not supported by this media.");
					let a = e;
					for (let e of i.audioTracks) e.enabled = a == e.id
				}, mediaEvents: ["emptied"], audioTracksEvents: ["addtrack", "removetrack", "change"]
			},
			mediaIsFullscreen: {
				get(e) {
					var t;
					let {media: i, documentElement: a, fullscreenElement: r = i} = e;
					if (!i || !a) return !1;
					if (!a[gt.element]) return "webkitDisplayingFullscreen" in i && "webkitPresentationMode" in i && (i.webkitDisplayingFullscreen && i.webkitPresentationMode === R);
					if (a[gt.element] === r) return !0;
					if (a[gt.element].localName.includes("-")) {
						let e = a[gt.element].shadowRoot;
						if (!(gt.element in e)) return se(a[gt.element], r);
						for (; null != e && e[gt.element];) {
							if (e[gt.element] === r) return !0;
							e = null == (t = e[gt.element]) ? void 0 : t.shadowRoot
						}
					}
					return !1
				}, set(e, t) {
					var i, a;
					let {media: r, fullscreenElement: n, documentElement: s} = t;
					if (e || null == s || !s[gt.exit]) if (null != n && n[gt.enter]) {
						let e = null == (a = n[gt.enter]) ? void 0 : a.call(n);
						e instanceof Promise && e.catch((() => {
						}))
					} else null != r && r.webkitEnterFullscreen ? r.webkitEnterFullscreen() : null != r && r.requestFullscreen && r.requestFullscreen(); else {
						let e = null == (i = null == s ? void 0 : s[gt.exit]) ? void 0 : i.call(s);
						e instanceof Promise && e.catch((() => {
						}))
					}
				}, rootEvents: gt.rootEvents, mediaEvents: gt.mediaEvents
			},
			mediaIsCasting: {
				get(e) {
					var t;
					let {media: i} = e;
					return !(null == i || !i.remote || "disconnected" === (null == (t = i.remote) ? void 0 : t.state)) && !!i.remote.state
				}, set(e, t) {
					var i, a;
					let {media: r} = t;
					if (r && (!e || "disconnected" === (null == (i = r.remote) ? void 0 : i.state)) && (e || "connected" === (null == (a = r.remote) ? void 0 : a.state))) {
						if ("function" != typeof r.remote.prompt) return void console.warn("MediaChrome: Casting is not supported in this environment");
						r.remote.prompt().catch((() => {
						}))
					}
				}, remoteEvents: ["connect", "connecting", "disconnect"]
			},
			mediaIsAirplaying: {
				get: () => !1, set(e, t) {
					let {media: i} = t;
					if (i) {
						if (!i.webkitShowPlaybackTargetPicker || !z.WebKitPlaybackTargetAvailabilityEvent) return void console.warn("MediaChrome: received a request to select AirPlay but AirPlay is not supported in this environment");
						i.webkitShowPlaybackTargetPicker()
					}
				}, mediaEvents: ["webkitcurrentplaybacktargetiswirelesschanged"]
			},
			mediaFullscreenUnavailable: {
				get(e) {
					let {media: t} = e;
					if (!Pt || !Ot(t)) return w
				}
			},
			mediaPipUnavailable: {
				get(e) {
					let {media: t} = e;
					if (!Nt || !Mt(t)) return w
				}
			},
			mediaVolumeUnavailable: {
				get(e) {
					let {media: t} = e;
					if (!1 === Et || null == (null == t ? void 0 : t.volume)) return w
				}, stateOwnersUpdateHandlers: [e => {
					null == Et && Kt.then((t => e(t ? void 0 : w)))
				}]
			},
			mediaCastUnavailable: {
				get(e, {availability: t = "not-available"} = {}) {
					var i;
					let {media: a} = e;
					return Ft && null != (i = null == a ? void 0 : a.remote) && i.state ? null != t && "available" !== t ? S : void 0 : w
				}, stateOwnersUpdateHandlers: [(e, t) => {
					var i;
					let {media: a} = t;
					return a ? (a.disableRemotePlayback || a.hasAttribute("disableremoteplayback") || null == (i = null == a ? void 0 : a.remote) || i.watchAvailability((t => {
						e({availability: t ? "available" : "not-available"})
					})).catch((t => {
						"NotSupportedError" === t.name ? e({availability: null}) : e({availability: "not-available"})
					})), () => {
						var e;
						null == (e = null == a ? void 0 : a.remote) || e.cancelWatchAvailability().catch((() => {
						}))
					}) : void 0
				}]
			},
			mediaAirplayUnavailable: {
				get: (e, t) => Ut ? "not-available" === (null == t ? void 0 : t.availability) ? S : void 0 : w,
				mediaEvents: ["webkitplaybacktargetavailabilitychanged"],
				stateOwnersUpdateHandlers: [(e, t) => {
					var i;
					let {media: a} = t;
					return a ? (a.disableRemotePlayback || a.hasAttribute("disableremoteplayback") || null == (i = null == a ? void 0 : a.remote) || i.watchAvailability((t => {
						e({availability: t ? "available" : "not-available"})
					})).catch((t => {
						"NotSupportedError" === t.name ? e({availability: null}) : e({availability: "not-available"})
					})), () => {
						var e;
						null == (e = null == a ? void 0 : a.remote) || e.cancelWatchAvailability().catch((() => {
						}))
					}) : void 0
				}]
			},
			mediaRenditionUnavailable: {
				get(e) {
					var t;
					let {media: i} = e;
					return null != i && i.videoRenditions ? null != (t = i.videoRenditions) && t.length ? void 0 : S : w
				}, mediaEvents: ["emptied", "loadstart"], videoRenditionsEvents: ["addrendition", "removerendition"]
			},
			mediaAudioTrackUnavailable: {
				get(e) {
					var t, i;
					let {media: a} = e;
					return null != a && a.audioTracks ? (null != (i = null == (t = a.audioTracks) ? void 0 : t.length) ? i : 0) <= 1 ? S : void 0 : w
				}, mediaEvents: ["emptied", "loadstart"], audioTracksEvents: ["addtrack", "removetrack"]
			}
		}, Yt = {
			[m.MEDIA_PREVIEW_REQUEST](e, t, {detail: i}) {
				var a, r, n;
				let s, o, {media: l} = t, d = null != i ? i : void 0;
				if (l && null != d) {
					let [e] = ft(l, {kind: y.METADATA, label: "thumbnails"}),
						t = Array.prototype.find.call(null != (a = null == e ? void 0 : e.cues) ? a : [], ((e, t, i) => 0 === t ? e.endTime > d : t === i.length - 1 ? e.startTime <= d : e.startTime <= d && e.endTime > d));
					if (t) {
						let e = /'^(?:[a-z]+:)?\/\//i.test(t.text) || null == (r = null == l ? void 0 : l.querySelector('track[label="thumbnails"]')) ? void 0 : r.src,
							i = new URL(t.text, e);
						o = new URLSearchParams(i.hash).get("#xywh").split(",").map((e => +e)), s = i.href
					}
				}
				let u = e.mediaDuration.get(t),
					h = null == (n = e.mediaChaptersCues.get(t).find(((e, t, i) => t === i.length - 1 && u === e.endTime ? e.startTime <= d && e.endTime >= d : e.startTime <= d && e.endTime > d))) ? void 0 : n.text;
				return null != i && null == h && (h = ""), {
					mediaPreviewTime: d,
					mediaPreviewImage: s,
					mediaPreviewCoords: o,
					mediaPreviewChapter: h
				}
			}, [m.MEDIA_PAUSE_REQUEST](e, t) {
				e.mediaPaused.set(!0, t)
			}, [m.MEDIA_PLAY_REQUEST](e, t) {
				var i;
				if (e.mediaStreamType.get(t) === L.LIVE) {
					let a = !(e.mediaTargetLiveWindow.get(t) > 0), r = null == (i = e.mediaSeekable.get(t)) ? void 0 : i[1];
					a && r && e.mediaCurrentTime.set(r, t)
				}
				e.mediaPaused.set(!1, t)
			}, [m.MEDIA_PLAYBACK_RATE_REQUEST](e, t, {detail: i}) {
				let a = i;
				e.mediaPlaybackRate.set(a, t)
			}, [m.MEDIA_MUTE_REQUEST](e, t) {
				e.mediaMuted.set(!0, t)
			}, [m.MEDIA_UNMUTE_REQUEST](e, t) {
				e.mediaVolume.get(t) || e.mediaVolume.set(.25, t), e.mediaMuted.set(!1, t)
			}, [m.MEDIA_VOLUME_REQUEST](e, t, {detail: i}) {
				let a = i;
				a && e.mediaMuted.get(t) && e.mediaMuted.set(!1, t), e.mediaVolume.set(a, t)
			}, [m.MEDIA_SEEK_REQUEST](e, t, {detail: i}) {
				let a = i;
				e.mediaCurrentTime.set(a, t)
			}, [m.MEDIA_SEEK_TO_LIVE_REQUEST](e, t) {
				var i;
				let a = null == (i = e.mediaSeekable.get(t)) ? void 0 : i[1];
				Number.isNaN(Number(a)) && e.mediaCurrentTime.set(a, t)
			}, [m.MEDIA_SHOW_SUBTITLES_REQUEST](e, t, {detail: i}) {
				var a;
				let {options: r} = t, n = Bt(t), s = dt(i), o = null == (a = s[0]) ? void 0 : a.language;
				o && !r.noSubtitlesLangPref && z.localStorage.setItem("media-chrome-pref-subtitles-lang", o), mt(A, n, s)
			}, [m.MEDIA_DISABLE_SUBTITLES_REQUEST](e, t, {detail: i}) {
				let a = Bt(t);
				mt(T, a, null != i ? i : [])
			}, [m.MEDIA_TOGGLE_SUBTITLES_REQUEST](e, t, {detail: i}) {
				Ht(t, i)
			}, [m.MEDIA_RENDITION_REQUEST](e, t, {detail: i}) {
				let a = i;
				e.mediaRenditionSelected.set(a, t)
			}, [m.MEDIA_AUDIO_TRACK_REQUEST](e, t, {detail: i}) {
				let a = i;
				e.mediaAudioTrackEnabled.set(a, t)
			}, [m.MEDIA_ENTER_PIP_REQUEST](e, t) {
				e.mediaIsFullscreen.get(t) && e.mediaIsFullscreen.set(!1, t), e.mediaIsPip.set(!0, t)
			}, [m.MEDIA_EXIT_PIP_REQUEST](e, t) {
				e.mediaIsPip.set(!1, t)
			}, [m.MEDIA_ENTER_FULLSCREEN_REQUEST](e, t) {
				e.mediaIsPip.get(t) && e.mediaIsPip.set(!1, t), e.mediaIsFullscreen.set(!0, t)
			}, [m.MEDIA_EXIT_FULLSCREEN_REQUEST](e, t) {
				e.mediaIsFullscreen.set(!1, t)
			}, [m.MEDIA_ENTER_CAST_REQUEST](e, t) {
				e.mediaIsFullscreen.get(t) && e.mediaIsFullscreen.set(!1, t), e.mediaIsCasting.set(!0, t)
			}, [m.MEDIA_EXIT_CAST_REQUEST](e, t) {
				e.mediaIsCasting.set(!1, t)
			}, [m.MEDIA_AIRPLAY_REQUEST](e, t) {
				e.mediaIsAirplaying.set(!0, t)
			}
		}, jt = ({
			         media: e,
			         fullscreenElement: t,
			         documentElement: i,
			         stateMediator: a = qt,
			         requestMap: r = Yt,
			         options: n = {},
			         monitorStateOwnersOnlyWithSubscriptions: s = !0
		         }) => {
			let o, l = [], d = {options: {...n}}, u = Object.freeze({
				mediaPreviewTime: void 0,
				mediaPreviewImage: void 0,
				mediaPreviewCoords: void 0,
				mediaPreviewChapter: void 0
			}), h = e => {
				null != e && (Wt(e, u) || (u = Object.freeze({...u, ...e}), l.forEach((e => e(u)))))
			}, c = () => {
				let e = Object.entries(a).reduce(((e, [t, {get: i}]) => (e[t] = i(d), e)), {});
				h(e)
			}, m = {}, f = async (e, t) => {
				var i, r, n, u, f, p, g, v, E, b, y, T, A, _, k, S;
				let w = !!o;
				if (o = {...d, ...null != o ? o : {}, ...e}, w) return;
				await (async (...e) => {
					await Promise.all(e.filter((e => e)).map((async e => {
						if (!("localName" in e && e instanceof z.HTMLElement)) return;
						let t = e.localName;
						if (!t.includes("-")) return;
						let i = z.customElements.get(t);
						i && e instanceof i || (await z.customElements.whenDefined(t), z.customElements.upgrade(e))
					})))
				})(...Object.values(e));
				let L = l.length > 0 && 0 === t && s, R = d.media !== o.media,
					I = (null == (i = d.media) ? void 0 : i.textTracks) !== (null == (r = o.media) ? void 0 : r.textTracks),
					D = (null == (n = d.media) ? void 0 : n.videoRenditions) !== (null == (u = o.media) ? void 0 : u.videoRenditions),
					C = (null == (f = d.media) ? void 0 : f.audioTracks) !== (null == (p = o.media) ? void 0 : p.audioTracks),
					x = (null == (g = d.media) ? void 0 : g.remote) !== (null == (v = o.media) ? void 0 : v.remote),
					M = d.documentElement !== o.documentElement, O = !!d.media && (R || L),
					P = !(null == (E = d.media) || !E.textTracks) && (I || L),
					N = !(null == (b = d.media) || !b.videoRenditions) && (D || L),
					U = !(null == (y = d.media) || !y.audioTracks) && (C || L),
					F = !(null == (T = d.media) || !T.remote) && (x || L), B = !!d.documentElement && (M || L),
					$ = O || P || N || U || F || B, H = 0 === l.length && 1 === t && s, W = !!o.media && (R || H),
					G = !(null == (A = o.media) || !A.textTracks) && (I || H),
					V = !(null == (_ = o.media) || !_.videoRenditions) && (D || H),
					K = !(null == (k = o.media) || !k.audioTracks) && (C || H),
					q = !(null == (S = o.media) || !S.remote) && (x || H), Y = !!o.documentElement && (M || H),
					j = W || G || V || K || q || Y;
				if (!$ && !j) return Object.entries(o).forEach((([e, t]) => {
					d[e] = t
				})), c(), void (o = void 0);
				Object.entries(a).forEach((([e, {
					get: t,
					mediaEvents: i = [],
					textTracksEvents: a = [],
					videoRenditionsEvents: r = [],
					audioTracksEvents: n = [],
					remoteEvents: s = [],
					rootEvents: l = [],
					stateOwnersUpdateHandlers: u = []
				}]) => {
					m[e] || (m[e] = {});
					let c, f = i => {
						let a = t(d, i);
						h({[e]: a})
					};
					c = m[e].mediaEvents, i.forEach((t => {
						c && O && (d.media.removeEventListener(t, c), m[e].mediaEvents = void 0), W && (o.media.addEventListener(t, f), m[e].mediaEvents = f)
					})), c = m[e].textTracksEvents, a.forEach((t => {
						var i, a;
						c && P && (null == (i = d.media.textTracks) || i.removeEventListener(t, c), m[e].textTracksEvents = void 0), G && (null == (a = o.media.textTracks) || a.addEventListener(t, f), m[e].textTracksEvents = f)
					})), c = m[e].videoRenditionsEvents, r.forEach((t => {
						var i, a;
						c && N && (null == (i = d.media.videoRenditions) || i.removeEventListener(t, c), m[e].videoRenditionsEvents = void 0), V && (null == (a = o.media.videoRenditions) || a.addEventListener(t, f), m[e].videoRenditionsEvents = f)
					})), c = m[e].audioTracksEvents, n.forEach((t => {
						var i, a;
						c && U && (null == (i = d.media.audioTracks) || i.removeEventListener(t, c), m[e].audioTracksEvents = void 0), K && (null == (a = o.media.audioTracks) || a.addEventListener(t, f), m[e].audioTracksEvents = f)
					})), c = m[e].remoteEvents, s.forEach((t => {
						var i, a;
						c && F && (null == (i = d.media.remote) || i.removeEventListener(t, c), m[e].remoteEvents = void 0), q && (null == (a = o.media.remote) || a.addEventListener(t, f), m[e].remoteEvents = f)
					})), c = m[e].rootEvents, l.forEach((t => {
						c && B && (d.documentElement.removeEventListener(t, c), m[e].rootEvents = void 0), Y && (o.documentElement.addEventListener(t, f), m[e].rootEvents = f)
					}));
					let p = m[e].stateOwnersUpdateHandlers;
					u.forEach((t => {
						p && $ && p(), j && (m[e].stateOwnersUpdateHandlers = t(f, o))
					}))
				})), Object.entries(o).forEach((([e, t]) => {
					d[e] = t
				})), c(), o = void 0
			};
			return f({media: e, fullscreenElement: t, documentElement: i, options: n}), {
				dispatch(e) {
					let {type: t, detail: i} = e;
					r[t] ? h(r[t](a, d, e)) : "mediaelementchangerequest" === t ? f({media: i}) : "fullscreenelementchangerequest" === t ? f({fullscreenElement: i}) : "documentelementchangerequest" === t ? f({documentElement: i}) : "optionschangerequest" === t && Object.entries(null != i ? i : {}).forEach((([e, t]) => {
						d.options[e] = t
					}))
				}, getState: () => u, subscribe: e => (f({}, l.length + 1), l.push(e), e(u), () => {
					let t = l.indexOf(e);
					t >= 0 && (f({}, l.length - 1), l.splice(t, 1))
				})
			}
		}, zt = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, Xt = (e, t, i) => (zt(e, t, "read from private field"), i ? i.call(e) : t.get(e)), Qt = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, Zt = (e, t, i, a) => (zt(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		Jt = (e, t, i) => (zt(e, t, "access private method"), i),
		ei = ["ArrowLeft", "ArrowRight", "Enter", " ", "f", "m", "k", "c"], ti = "defaultsubtitles",
		ii = "defaultstreamtype", ai = "defaultduration", ri = "fullscreenelement", ni = "hotkeys", si = "keysused",
		oi = "liveedgeoffset", li = "nohotkeys", di = "novolumepref", ui = "nosubtitleslangpref", hi = "nodefaultstore",
		ci = "keyboardforwardseekoffset", mi = "keyboardbackwardseekoffset", fi = class extends ze {
			constructor() {
				super(), Qt(this, St), Qt(this, Lt), Qt(this, It), Qt(this, bt, new st(this, ni)), Qt(this, yt, void 0), Qt(this, Tt, void 0), Qt(this, At, void 0), Qt(this, _t, void 0), Qt(this, kt, (e => {
					var t;
					null == (t = Xt(this, Tt)) || t.dispatch(e)
				})), this.mediaStateReceivers = [], this.associatedElementSubscriptions = new Map, this.associateElement(this);
				let e = {};
				Zt(this, At, (t => {
					Object.entries(t).forEach((([t, i]) => {
						if (t in e && e[t] === i) return;
						this.propagateMediaState(t, i);
						let a = t.toLowerCase(), r = new z.CustomEvent(b[a], {composed: !0, detail: i});
						this.dispatchEvent(r)
					})), e = t
				})), this.enableHotkeys()
			}

			static get observedAttributes() {
				return super.observedAttributes.concat(li, ni, ii, ti, ai)
			}

			get mediaStore() {
				return Xt(this, Tt)
			}

			set mediaStore(e) {
				var t, i;
				Xt(this, Tt) && (null == (t = Xt(this, _t)) || t.call(this), Zt(this, _t, void 0)), Zt(this, Tt, e), Xt(this, Tt) || this.hasAttribute(hi) ? Zt(this, _t, null == (i = Xt(this, Tt)) ? void 0 : i.subscribe(Xt(this, At))) : Jt(this, St, wt).call(this)
			}

			get fullscreenElement() {
				var e;
				return null != (e = Xt(this, yt)) ? e : this
			}

			set fullscreenElement(e) {
				var t;
				this.hasAttribute(ri) && this.removeAttribute(ri), Zt(this, yt, e), null == (t = Xt(this, Tt)) || t.dispatch({
					type: "fullscreenelementchangerequest",
					detail: this.fullscreenElement
				})
			}

			get hotkeys() {
				return Xt(this, bt)
			}

			attributeChangedCallback(e, t, i) {
				var a, r, n, s, o, l;
				if (super.attributeChangedCallback(e, t, i), e === li) i !== t && "" === i ? (this.hasAttribute(ni) && console.warn("Media Chrome: Both `hotkeys` and `nohotkeys` have been set. All hotkeys will be disabled."), this.disableHotkeys()) : i !== t && null === i && this.enableHotkeys(); else if (e === ni) Xt(this, bt).value = i; else if (e === ti && i !== t) null == (a = Xt(this, Tt)) || a.dispatch({
					type: "optionschangerequest",
					detail: {defaultSubtitles: this.hasAttribute(ti)}
				}); else if (e === ii) null == (n = Xt(this, Tt)) || n.dispatch({
					type: "optionschangerequest",
					detail: {defaultStreamType: null != (r = this.getAttribute(ii)) ? r : void 0}
				}); else if (e === oi) null == (s = Xt(this, Tt)) || s.dispatch({
					type: "optionschangerequest",
					detail: {liveEdgeOffset: this.hasAttribute(oi) ? +this.getAttribute(oi) : void 0}
				}); else if (e === ri) {
					let e = i ? null == (o = this.getRootNode()) ? void 0 : o.getElementById(i) : void 0;
					Zt(this, yt, e), null == (l = Xt(this, Tt)) || l.dispatch({
						type: "fullscreenelementchangerequest",
						detail: this.fullscreenElement
					})
				}
			}

			connectedCallback() {
				var e, t;
				!Xt(this, Tt) && !this.hasAttribute(hi) && Jt(this, St, wt).call(this), null == (e = Xt(this, Tt)) || e.dispatch({
					type: "documentelementchangerequest",
					detail: X
				}), super.connectedCallback(), Xt(this, Tt) && !Xt(this, _t) && Zt(this, _t, null == (t = Xt(this, Tt)) ? void 0 : t.subscribe(Xt(this, At))), this.enableHotkeys()
			}

			disconnectedCallback() {
				var e, t, i, a;
				null == (e = super.disconnectedCallback) || e.call(this), Xt(this, Tt) && (null == (t = Xt(this, Tt)) || t.dispatch({
					type: "documentelementchangerequest",
					detail: void 0
				}), null == (i = Xt(this, Tt)) || i.dispatch({
					type: m.MEDIA_TOGGLE_SUBTITLES_REQUEST,
					detail: !1
				})), Xt(this, _t) && (null == (a = Xt(this, _t)) || a.call(this), Zt(this, _t, void 0))
			}

			mediaSetCallback(e) {
				var t;
				super.mediaSetCallback(e), null == (t = Xt(this, Tt)) || t.dispatch({
					type: "mediaelementchangerequest",
					detail: e
				}), e.hasAttribute("tabindex") || (e.tabIndex = -1)
			}

			mediaUnsetCallback(e) {
				var t;
				super.mediaUnsetCallback(e), null == (t = Xt(this, Tt)) || t.dispatch({
					type: "mediaelementchangerequest",
					detail: void 0
				})
			}

			propagateMediaState(e, t) {
				Ai(this.mediaStateReceivers, e, t)
			}

			associateElement(e) {
				if (!e) return;
				let {associatedElementSubscriptions: t} = this;
				if (t.has(e)) return;
				let i = this.registerMediaStateReceiver.bind(this), a = this.unregisterMediaStateReceiver.bind(this),
					r = _i(e, i, a);
				Object.values(m).forEach((t => {
					e.addEventListener(t, Xt(this, kt))
				})), t.set(e, r)
			}

			unassociateElement(e) {
				if (!e) return;
				let {associatedElementSubscriptions: t} = this;
				t.has(e) && (t.get(e)(), t.delete(e), Object.values(m).forEach((t => {
					e.removeEventListener(t, Xt(this, kt))
				})))
			}

			registerMediaStateReceiver(e) {
				if (!e) return;
				let t = this.mediaStateReceivers;
				t.indexOf(e) > -1 || (t.push(e), Xt(this, Tt) && Object.entries(Xt(this, Tt).getState()).forEach((([t, i]) => {
					Ai([e], t, i)
				})))
			}

			unregisterMediaStateReceiver(e) {
				let t = this.mediaStateReceivers, i = t.indexOf(e);
				i < 0 || t.splice(i, 1)
			}

			enableHotkeys() {
				this.addEventListener("keydown", Jt(this, It, Dt))
			}

			disableHotkeys() {
				this.removeEventListener("keydown", Jt(this, It, Dt)), this.removeEventListener("keyup", Jt(this, Lt, Rt))
			}

			keyboardShortcutHandler(e) {
				var t, i, a, r, n, s;
				if ((null != (r = null != (a = null == (t = e.target.getAttribute(si)) ? void 0 : t.split(" ")) ? a : null == (i = e.target) ? void 0 : i.keysUsed) ? r : []).map((e => "Space" === e ? " " : e)).filter(Boolean).includes(e.key)) return;
				let o, l, d;
				if (!(Xt(this, bt).contains(`no${e.key.toLowerCase()}`) || " " === e.key && Xt(this, bt).contains("nospace"))) switch (e.key) {
					case" ":
					case"k":
						o = Xt(this, Tt).getState().mediaPaused ? m.MEDIA_PLAY_REQUEST : m.MEDIA_PAUSE_REQUEST, this.dispatchEvent(new z.CustomEvent(o, {
							composed: !0,
							bubbles: !0
						}));
						break;
					case"m":
						o = "off" === this.mediaStore.getState().mediaVolumeLevel ? m.MEDIA_UNMUTE_REQUEST : m.MEDIA_MUTE_REQUEST, this.dispatchEvent(new z.CustomEvent(o, {
							composed: !0,
							bubbles: !0
						}));
						break;
					case"f":
						o = this.mediaStore.getState().mediaIsFullscreen ? m.MEDIA_EXIT_FULLSCREEN_REQUEST : m.MEDIA_ENTER_FULLSCREEN_REQUEST, this.dispatchEvent(new z.CustomEvent(o, {
							composed: !0,
							bubbles: !0
						}));
						break;
					case"c":
						this.dispatchEvent(new z.CustomEvent(m.MEDIA_TOGGLE_SUBTITLES_REQUEST, {
							composed: !0,
							bubbles: !0
						}));
						break;
					case"ArrowLeft": {
						let e = this.hasAttribute(mi) ? +this.getAttribute(mi) : 10;
						l = Math.max((null != (n = this.mediaStore.getState().mediaCurrentTime) ? n : 0) - e, 0), d = new z.CustomEvent(m.MEDIA_SEEK_REQUEST, {
							composed: !0,
							bubbles: !0,
							detail: l
						}), this.dispatchEvent(d);
						break
					}
					case"ArrowRight": {
						let e = this.hasAttribute(ci) ? +this.getAttribute(ci) : 10;
						l = Math.max((null != (s = this.mediaStore.getState().mediaCurrentTime) ? s : 0) + e, 0), d = new z.CustomEvent(m.MEDIA_SEEK_REQUEST, {
							composed: !0,
							bubbles: !0,
							detail: l
						}), this.dispatchEvent(d);
						break
					}
				}
			}
		};
	bt = new WeakMap, yt = new WeakMap, Tt = new WeakMap, At = new WeakMap, _t = new WeakMap, kt = new WeakMap, St = new WeakSet, wt = function () {
		var e;
		this.mediaStore = jt({
			media: this.media,
			fullscreenElement: this.fullscreenElement,
			options: {
				defaultSubtitles: this.hasAttribute(ti),
				defaultDuration: this.hasAttribute(ai) ? +this.getAttribute(ai) : void 0,
				defaultStreamType: null != (e = this.getAttribute(ii)) ? e : void 0,
				liveEdgeOffset: this.hasAttribute(oi) ? +this.getAttribute(oi) : void 0,
				noVolumePref: this.hasAttribute(di),
				noSubtitlesLangPref: this.hasAttribute(ui)
			}
		})
	}, Lt = new WeakSet, Rt = function (e) {
		let {key: t} = e;
		ei.includes(t) ? this.keyboardShortcutHandler(e) : this.removeEventListener("keyup", Jt(this, Lt, Rt))
	}, It = new WeakSet, Dt = function (e) {
		let {metaKey: t, altKey: i, key: a} = e;
		t || i || !ei.includes(a) ? this.removeEventListener("keyup", Jt(this, Lt, Rt)) : ([" ", "ArrowLeft", "ArrowRight"].includes(a) && !(Xt(this, bt).contains(`no${a.toLowerCase()}`) || " " === a && Xt(this, bt).contains("nospace")) && e.preventDefault(), this.addEventListener("keyup", Jt(this, Lt, Rt), {once: !0}))
	};
	var pi = Object.values(v), gi = Object.values(p), vi = e => {
		var t, i, a, r;
		let {observedAttributes: n} = e.constructor;
		!n && null != (t = e.nodeName) && t.includes("-") && (z.customElements.upgrade(e), ({observedAttributes: n} = e.constructor));
		let s = null == (r = null == (a = null == (i = null == e ? void 0 : e.getAttribute) ? void 0 : i.call(e, f.MEDIA_CHROME_ATTRIBUTES)) ? void 0 : a.split) ? void 0 : r.call(a, /\s+/);
		return Array.isArray(n || s) ? (n || s).filter((e => pi.includes(e))) : []
	}, Ei = e => (e => {
		var t, i;
		return null != (t = e.nodeName) && t.includes("-") && z.customElements.get(null == (i = e.nodeName) ? void 0 : i.toLowerCase()) && !(e instanceof z.customElements.get(e.nodeName.toLowerCase())) && z.customElements.upgrade(e), gi.some((t => t in e))
	})(e) || !!vi(e).length, bi = e => {
		var t;
		return null == (t = null == e ? void 0 : e.join) ? void 0 : t.call(e, ":")
	}, yi = {
		[v.MEDIA_SUBTITLES_LIST]: ht,
		[v.MEDIA_SUBTITLES_SHOWING]: ht,
		[v.MEDIA_SEEKABLE]: bi,
		[v.MEDIA_BUFFERED]: e => null == e ? void 0 : e.map(bi).join(" "),
		[v.MEDIA_PREVIEW_COORDS]: e => null == e ? void 0 : e.join(" "),
		[v.MEDIA_RENDITION_LIST]: function (e) {
			return null == e ? void 0 : e.map(x).join(" ")
		},
		[v.MEDIA_AUDIO_TRACK_LIST]: function (e) {
			return null == e ? void 0 : e.map(P).join(" ")
		}
	}, Ti = (e, t) => {
		if ((e => {
			var t;
			return !(null == (t = e.closest) || !t.call(e, '*[slot="media"]'))
		})(e)) return;
		let i = (e, t) => {
			var i, a;
			Ei(e) && t(e);
			let {children: r = []} = null != e ? e : {};
			[...r, ...null != (a = null == (i = null == e ? void 0 : e.shadowRoot) ? void 0 : i.children) ? a : []].forEach((e => Ti(e, t)))
		}, a = null == e ? void 0 : e.nodeName.toLowerCase();
		!a.includes("-") || Ei(e) ? i(e, t) : z.customElements.whenDefined(a).then((() => {
			i(e, t)
		}))
	}, Ai = (e, t, i) => {
		e.forEach((e => {
			if (t in e) return void (e[t] = i);
			let a = vi(e), r = t.toLowerCase();
			a.includes(r) && (async (e, t, i) => {
				var a, r;
				if (e.isConnected || await B(0), "boolean" == typeof i || null == i) return ge(e, t, i);
				if ("number" == typeof i) return fe(e, t, i);
				if ("string" == typeof i) return Ee(e, t, i);
				if (Array.isArray(i) && !i.length) return e.removeAttribute(t);
				let n = null != (r = null == (a = yi[t]) ? void 0 : a.call(yi, i)) ? r : i;
				e.setAttribute(t, n)
			})(e, r, i)
		}))
	}, _i = (e, t, i) => {
		Ti(e, t);
		let a = e => {
			var i;
			let a = null != (i = null == e ? void 0 : e.composedPath()[0]) ? i : e.target;
			t(a)
		}, r = e => {
			var t;
			let a = null != (t = null == e ? void 0 : e.composedPath()[0]) ? t : e.target;
			i(a)
		};
		e.addEventListener(m.REGISTER_MEDIA_STATE_RECEIVER, a), e.addEventListener(m.UNREGISTER_MEDIA_STATE_RECEIVER, r);
		let n = [], s = e => {
			let a = e.target;
			"media" !== a.name && (n.forEach((e => Ti(e, i))), n = [...a.assignedElements({flatten: !0})], n.forEach((e => Ti(e, t))))
		};
		e.addEventListener("slotchange", s);
		let o = new MutationObserver((e => {
			e.forEach((e => {
				let {addedNodes: a = [], removedNodes: r = [], type: n, target: s, attributeName: o} = e;
				"childList" === n ? (Array.prototype.forEach.call(a, (e => Ti(e, t))), Array.prototype.forEach.call(r, (e => Ti(e, i)))) : "attributes" === n && o === f.MEDIA_CHROME_ATTRIBUTES && (Ei(s) ? t(s) : i(s))
			}))
		}));
		return o.observe(e, {childList: !0, attributes: !0, subtree: !0}), () => {
			Ti(e, i), e.removeEventListener("slotchange", s), o.disconnect(), e.removeEventListener(m.REGISTER_MEDIA_STATE_RECEIVER, a), e.removeEventListener(m.UNREGISTER_MEDIA_STATE_RECEIVER, r)
		}
	};
	z.customElements.get("media-controller") || z.customElements.define("media-controller", fi);
	var ki, Si, wi, Li, Ri = fi, Ii = Object.defineProperty, Di = (e, t, i) => (((e, t, i) => {
			t in e ? Ii(e, t, {enumerable: !0, configurable: !0, writable: !0, value: i}) : e[t] = i
		})(e, "symbol" != typeof t ? t + "" : t, i), i), Ci = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, xi = (e, t, i) => (Ci(e, t, "read from private field"), i ? i.call(e) : t.get(e)), Mi = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, Oi = (e, t, i, a) => (Ci(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		Pi = X.createElement("template");
	Pi.innerHTML = "\n<style>\n  :host {\n    font: var(--media-font,\n      var(--media-font-weight, bold)\n      var(--media-font-size, 14px) /\n      var(--media-text-content-height, var(--media-control-height, 24px))\n      var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));\n    color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));\n    background: var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7)));\n    padding: var(--media-button-padding, var(--media-control-padding, 10px));\n    justify-content: var(--media-button-justify-content, center);\n    display: inline-flex;\n    align-items: center;\n    vertical-align: middle;\n    box-sizing: border-box;\n    transition: background .15s linear;\n    pointer-events: auto;\n    cursor: pointer;\n    -webkit-tap-highlight-color: transparent;\n  }\n\n  \n  :host(:focus-visible) {\n    box-shadow: inset 0 0 0 2px rgb(27 127 204 / .9);\n    outline: 0;\n  }\n  \n  :host(:where(:focus)) {\n    box-shadow: none;\n    outline: 0;\n  }\n\n  :host(:hover) {\n    background: var(--media-control-hover-background, rgba(50 50 70 / .7));\n  }\n\n  svg, img, ::slotted(svg), ::slotted(img) {\n    width: var(--media-button-icon-width);\n    height: var(--media-button-icon-height, var(--media-control-height, 24px));\n    transform: var(--media-button-icon-transform);\n    transition: var(--media-button-icon-transition);\n    fill: var(--media-icon-color, var(--media-primary-color, rgb(238 238 238)));\n    vertical-align: middle;\n    max-width: 100%;\n    max-height: 100%;\n    min-width: 100%;\n  }\n</style>\n";
	var Ni = class extends z.HTMLElement {
		constructor(e = {}) {
			if (super(), Mi(this, ki, void 0), Di(this, "preventClick", !1), Mi(this, Si, (e => {
				this.preventClick || this.handleClick(e)
			})), Mi(this, wi, (e => {
				let {key: t} = e;
				this.keysUsed.includes(t) ? this.preventClick || this.handleClick(e) : this.removeEventListener("keyup", xi(this, wi))
			})), Mi(this, Li, (e => {
				let {metaKey: t, altKey: i, key: a} = e;
				t || i || !this.keysUsed.includes(a) ? this.removeEventListener("keyup", xi(this, wi)) : this.addEventListener("keyup", xi(this, wi), {once: !0})
			})), !this.shadowRoot) {
				this.attachShadow({mode: "open"});
				let t = Pi.content.cloneNode(!0);
				this.nativeEl = t;
				let i = e.slotTemplate;
				i || (i = X.createElement("template"), i.innerHTML = `<slot>${e.defaultContent || ""}</slot>`), this.nativeEl.appendChild(i.content.cloneNode(!0)), this.shadowRoot.appendChild(t)
			}
		}

		static get observedAttributes() {
			return ["disabled", f.MEDIA_CONTROLLER]
		}

		get keysUsed() {
			return ["Enter", " "]
		}

		enable() {
			this.addEventListener("click", xi(this, Si)), this.addEventListener("keydown", xi(this, Li)), this.tabIndex = 0
		}

		disable() {
			this.removeEventListener("click", xi(this, Si)), this.removeEventListener("keydown", xi(this, Li)), this.removeEventListener("keyup", xi(this, wi)), this.tabIndex = -1
		}

		attributeChangedCallback(e, t, i) {
			var a, r, n, s, o;
			e === f.MEDIA_CONTROLLER ? (t && (null == (r = null == (a = xi(this, ki)) ? void 0 : a.unassociateElement) || r.call(a, this), Oi(this, ki, null)), i && this.isConnected && (Oi(this, ki, null == (n = this.getRootNode()) ? void 0 : n.getElementById(i)), null == (o = null == (s = xi(this, ki)) ? void 0 : s.associateElement) || o.call(s, this))) : "disabled" === e && i !== t && (null == i ? this.enable() : this.disable())
		}

		connectedCallback() {
			var e, t, i;
			let {style: a} = he(this.shadowRoot, ":host");
			a.setProperty("display", `var(--media-control-display, var(--${this.localName}-display, inline-flex))`), this.hasAttribute("disabled") || this.enable(), this.setAttribute("role", "button");
			let r = this.getAttribute(f.MEDIA_CONTROLLER);
			r && (Oi(this, ki, null == (e = this.getRootNode()) ? void 0 : e.getElementById(r)), null == (i = null == (t = xi(this, ki)) ? void 0 : t.associateElement) || i.call(t, this))
		}

		disconnectedCallback() {
			var e, t;
			this.disable(), null == (t = null == (e = xi(this, ki)) ? void 0 : e.unassociateElement) || t.call(e, this), Oi(this, ki, null)
		}

		handleClick(e) {
		}
	};
	ki = new WeakMap, Si = new WeakMap, wi = new WeakMap, Li = new WeakMap, z.customElements.get("media-chrome-button") || z.customElements.define("media-chrome-button", Ni);
	var Ui = '<svg aria-hidden="true" viewBox="0 0 26 24">\n  <path d="M22.13 3H3.87a.87.87 0 0 0-.87.87v13.26a.87.87 0 0 0 .87.87h3.4L9 16H5V5h16v11h-4l1.72 2h3.4a.87.87 0 0 0 .87-.87V3.87a.87.87 0 0 0-.86-.87Zm-8.75 11.44a.5.5 0 0 0-.76 0l-4.91 5.73a.5.5 0 0 0 .38.83h9.82a.501.501 0 0 0 .38-.83l-4.91-5.73Z"/>\n</svg>\n',
		Fi = X.createElement("template");
	Fi.innerHTML = `\n  <style>\n  :host([${v.MEDIA_IS_AIRPLAYING}]) slot:not([name=exit]):not([name=icon]) {\n    display: none !important;\n  }\n\n  \n  :host(:not([${v.MEDIA_IS_AIRPLAYING}])) slot:not([name=enter]):not([name=icon]) {\n    display: none !important;\n  }\n  </style>\n\n  <slot name="icon">\n    <slot name="enter">${Ui}</slot>\n    <slot name="exit">${Ui}</slot>\n  </slot>\n`;
	var Bi = e => {
		let t = e.mediaIsAirplaying ? D.EXIT_AIRPLAY() : D.ENTER_AIRPLAY();
		e.setAttribute("aria-label", t)
	};

	function $i({anchor: e, floating: t, placement: i}) {
		let a = function ({anchor: e, floating: t}) {
			return {anchor: Hi(e, t.offsetParent), floating: {x: 0, y: 0, width: t.offsetWidth, height: t.offsetHeight}}
		}({anchor: e, floating: t}), {x: r, y: n} = function ({anchor: e, floating: t}, i) {
			let a, r = "x" === function (e) {
					return ["top", "bottom"].includes(Wi(e)) ? "y" : "x"
				}(i) ? "y" : "x", n = "y" === r ? "height" : "width", s = Wi(i), o = e.x + e.width / 2 - t.width / 2,
				l = e.y + e.height / 2 - t.height / 2, d = e[n] / 2 - t[n] / 2;
			switch (s) {
				case"top":
					a = {x: o, y: e.y - t.height};
					break;
				case"bottom":
					a = {x: o, y: e.y + e.height};
					break;
				case"right":
					a = {x: e.x + e.width, y: l};
					break;
				case"left":
					a = {x: e.x - t.width, y: l};
					break;
				default:
					a = {x: e.x, y: e.y}
			}
			switch (i.split("-")[1]) {
				case"start":
					a[r] -= d;
					break;
				case"end":
					a[r] += d
			}
			return a
		}(a, i);
		return {x: r, y: n}
	}

	function Hi(e, t) {
		let i = e.getBoundingClientRect(), a = t.getBoundingClientRect();
		return {x: i.x - a.x, y: i.y - a.y, width: i.width, height: i.height}
	}

	function Wi(e) {
		return e.split("-")[0]
	}

	z.customElements.get("media-airplay-button") || z.customElements.define("media-airplay-button", class extends Ni {
		constructor(e = {}) {
			super({slotTemplate: Fi, ...e})
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_IS_AIRPLAYING, v.MEDIA_AIRPLAY_UNAVAILABLE]
		}

		get mediaIsAirplaying() {
			return pe(this, v.MEDIA_IS_AIRPLAYING)
		}

		set mediaIsAirplaying(e) {
			ge(this, v.MEDIA_IS_AIRPLAYING, e)
		}

		get mediaAirplayUnavailable() {
			return ve(this, v.MEDIA_AIRPLAY_UNAVAILABLE)
		}

		set mediaAirplayUnavailable(e) {
			Ee(this, v.MEDIA_AIRPLAY_UNAVAILABLE, e)
		}

		connectedCallback() {
			super.connectedCallback(), Bi(this)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_IS_AIRPLAYING && Bi(this)
		}

		handleClick() {
			let e = new z.CustomEvent(m.MEDIA_AIRPLAY_REQUEST, {composed: !0, bubbles: !0});
			this.dispatchEvent(e)
		}
	});
	var Gi, Vi, Ki, qi, Yi, ji, zi, Xi, Qi, Zi, Ji, ea, ta, ia, aa, ra, na, sa, oa, la, da, ua, ha, ca, ma, fa, pa, ga,
		va, Ea, ba, ya, Ta, Aa, _a, ka, Sa, wa, La, Ra, Ia, Da, Ca, xa, Ma, Oa = Object.defineProperty,
		Pa = (e, t, i) => (((e, t, i) => {
			t in e ? Oa(e, t, {enumerable: !0, configurable: !0, writable: !0, value: i}) : e[t] = i
		})(e, "symbol" != typeof t ? t + "" : t, i), i), Na = class extends Event {
			constructor({action: e = "auto", relatedTarget: t, ...i}) {
				super("invoke", i), Pa(this, "action"), Pa(this, "relatedTarget"), this.action = e, this.relatedTarget = t
			}
		}, Ua = class extends Event {
			constructor({newState: e, oldState: t, ...i}) {
				super("toggle", i), Pa(this, "newState"), Pa(this, "oldState"), this.newState = e, this.oldState = t
			}
		}, Fa = Object.defineProperty, Ba = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, $a = (e, t, i) => (Ba(e, t, "read from private field"), i ? i.call(e) : t.get(e)), Ha = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, Wa = (e, t, i, a) => (Ba(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		Ga = (e, t, i) => (Ba(e, t, "access private method"), i);

	function Va({type: e, text: t, value: i, checked: a}) {
		let r = X.createElement("media-chrome-menu-item");
		r.type = null != e ? e : "", r.part.add("menu-item"), e && r.part.add(e), r.value = i, r.checked = a;
		let n = X.createElement("span");
		return n.textContent = t, r.append(n), r
	}

	function Ka(e, t) {
		let i = e.querySelector(`:scope > [slot="${t}"]`);
		if ("SLOT" == (null == i ? void 0 : i.nodeName) && (i = i.assignedElements({flatten: !0})[0]), i) return i = i.cloneNode(!0), i;
		let a = e.shadowRoot.querySelector(`[name="${t}"] > svg`);
		return a ? a.cloneNode(!0) : ""
	}

	var qa = X.createElement("template");
	qa.innerHTML = '\n  <style>\n    :host {\n      font: var(--media-font,\n        var(--media-font-weight, normal)\n        var(--media-font-size, 14px) /\n        var(--media-text-content-height, var(--media-control-height, 24px))\n        var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));\n      color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));\n      background: var(--media-menu-background, var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .8))));\n      border-radius: var(--media-menu-border-radius);\n      border: var(--media-menu-border, none);\n      display: var(--media-menu-display, inline-flex);\n      transition: var(--media-menu-transition-in,\n        visibility 0s,\n        opacity .2s ease-out,\n        transform .15s ease-out,\n        left .2s ease-in-out,\n        min-width .2s ease-in-out,\n        min-height .2s ease-in-out\n      ) !important;\n      \n      visibility: var(--media-menu-visibility, visible);\n      opacity: var(--media-menu-opacity, 1);\n      max-height: var(--media-menu-max-height, var(--_menu-max-height, 300px));\n      transform: var(--media-menu-transform-in, translateY(0) scale(1));\n      flex-direction: column;\n      \n      min-height: 0;\n      position: relative;\n      box-sizing: border-box;\n    }\n\n    :host([hidden]) {\n      transition: var(--media-menu-transition-out,\n        visibility .15s ease-in,\n        opacity .15s ease-in,\n        transform .15s ease-in\n      ) !important;\n      visibility: var(--media-menu-hidden-visibility, hidden);\n      opacity: var(--media-menu-hidden-opacity, 0);\n      max-height: var(--media-menu-hidden-max-height,\n        var(--media-menu-max-height, var(--_menu-max-height, 300px)));\n      transform: var(--media-menu-transform-out, translateY(2px) scale(.99));\n      pointer-events: none;\n    }\n\n    :host([slot="submenu"]) {\n      background: none;\n      width: 100%;\n      min-height: 100%;\n      position: absolute;\n      bottom: 0;\n      right: -100%;\n    }\n\n    #container {\n      display: flex;\n      flex-direction: column;\n      min-height: 0;\n      transition: transform .2s ease-out;\n      transform: translate(0, 0);\n    }\n\n    #container.has-expanded {\n      transition: transform .2s ease-in;\n      transform: translate(-100%, 0);\n    }\n\n    slot[name="header"] {\n      display: flex;\n      padding: .4em .7em;\n      border-bottom: 1px solid rgb(255 255 255 / .25);\n      cursor: default;\n    }\n\n    slot[name="header"][hidden] {\n      display: none;\n    }\n\n    button[part~="back"] {\n      background: none;\n      color: inherit;\n      border: none;\n      padding: 0;\n      font: inherit;\n      cursor: pointer;\n      outline: inherit;\n      display: inline-flex;\n      align-items: center;\n      cursor: pointer;\n    }\n\n    svg[part~="back"] {\n      height: var(--media-menu-icon-height, var(--media-control-height, 24px));\n      fill: var(--media-icon-color, var(--media-primary-color, rgb(238 238 238)));\n      display: block;\n      margin-right: .5ch;\n    }\n\n    slot:not([name]) {\n      gap: var(--media-menu-gap);\n      flex-direction: var(--media-menu-flex-direction, column);\n      overflow: var(--media-menu-overflow, hidden auto);\n      display: flex;\n      min-height: 0;\n    }\n\n    :host([role="menu"]) slot:not([name]) {\n      padding-block: .4em;\n    }\n\n    slot:not([name])::slotted([role="menu"]) {\n      background: none;\n    }\n\n    media-chrome-menu-item > span {\n      margin-right: .5ch;\n      max-width: var(--media-menu-item-max-width);\n      text-overflow: ellipsis;\n      overflow: hidden;\n    }\n  </style>\n  <style id="layout-row" media="width:0">\n\n    slot[name="header"] {\n      padding: .4em .5em;\n    }\n\n    slot:not([name]) {\n      gap: var(--media-menu-gap, .25em);\n      flex-direction: var(--media-menu-flex-direction, row);\n      padding-inline: .5em;\n    }\n\n    media-chrome-menu-item {\n      padding: .3em .5em;\n    }\n\n    media-chrome-menu-item[aria-checked="true"] {\n      background: var(--media-menu-item-checked-background, rgb(255 255 255 / .2));\n    }\n\n    \n    media-chrome-menu-item::part(checked-indicator) {\n      display: var(--media-menu-item-checked-indicator-display, none);\n    }\n  </style>\n  <div id="container">\n    <slot name="header" hidden>\n      <button part="back button" aria-label="Back to previous menu">\n        <slot name="back-icon">\n          <svg aria-hidden="true" viewBox="0 0 20 24" part="back indicator">\n            <path d="m11.88 17.585.742-.669-4.2-4.665 4.2-4.666-.743-.669-4.803 5.335 4.803 5.334Z"/>\n          </svg>\n        </slot>\n        <slot name="title"></slot>\n      </button>\n    </slot>\n    <slot></slot>\n  </div>\n  <slot name="checked-indicator" hidden></slot>\n';
	var Ya, ja = "style", za = "hidden", Xa = "disabled", Qa = "anchor", Za = class extends z.HTMLElement {
		constructor() {
			super(), Ha(this, Qi), Ha(this, ea), Ha(this, ia), Ha(this, ra), Ha(this, sa), Ha(this, ua), Ha(this, ca), Ha(this, fa), Ha(this, ga), Ha(this, Ea), Ha(this, ya), Ha(this, Aa), Ha(this, ka), Ha(this, wa), Ha(this, Ra), Ha(this, Da), Ha(this, xa), Ha(this, Gi, void 0), Ha(this, Vi, void 0), Ha(this, Ki, void 0), Ha(this, qi, ""), Ha(this, Yi, null), Ha(this, ji, new Set), Ha(this, zi, void 0), Ha(this, Xi, !1), Ha(this, Ji, (() => {
				let e = $a(this, ji), t = new Set(this.items);
				for (let i of e) t.has(i) || this.dispatchEvent(new CustomEvent("removemenuitem", {detail: i}));
				for (let i of t) e.has(i) || this.dispatchEvent(new CustomEvent("addmenuitem", {detail: i}));
				Wa(this, ji, t)
			})), Ha(this, la, (() => {
				Ga(this, ua, ha).call(this, !1), Ga(this, ca, ma).call(this, !1)
			})), Ha(this, da, (() => {
				Ga(this, ua, ha).call(this, !1)
			})), this.shadowRoot || (this.attachShadow({mode: "open"}), this.nativeEl = this.constructor.template.content.cloneNode(!0), this.shadowRoot.append(this.nativeEl)), this.container = this.shadowRoot.querySelector("#container"), this.defaultSlot = this.shadowRoot.querySelector("slot:not([name])"), this.shadowRoot.addEventListener("slotchange", this), Wa(this, zi, new MutationObserver($a(this, Ji))), $a(this, zi).observe(this.defaultSlot, {childList: !0})
		}

		static get observedAttributes() {
			return [Xa, za, ja, Qa, f.MEDIA_CONTROLLER]
		}

		get anchor() {
			return this.getAttribute("anchor")
		}

		set anchor(e) {
			this.setAttribute("anchor", `${e}`)
		}

		get anchorElement() {
			var e;
			return this.anchor ? null == (e = de(this)) ? void 0 : e.querySelector(`#${this.anchor}`) : null
		}

		get items() {
			return this.defaultSlot.assignedElements({flatten: !0}).filter(Ja)
		}

		get radioGroupItems() {
			return this.items.filter((e => "menuitemradio" === e.role))
		}

		get checkedItems() {
			return this.items.filter((e => e.checked))
		}

		get value() {
			var e, t;
			return null != (t = null == (e = this.checkedItems[0]) ? void 0 : e.value) ? t : ""
		}

		set value(e) {
			let t = this.items.find((t => t.value === e));
			t && Ga(this, xa, Ma).call(this, t)
		}

		get keysUsed() {
			return ["Enter", "Escape", "Tab", " ", "ArrowDown", "ArrowUp", "Home", "End"]
		}

		static formatMenuItemText(e) {
			return e
		}

		enable() {
			this.addEventListener("click", this), this.addEventListener("focusout", this), this.addEventListener("keydown", this), this.addEventListener("invoke", this), this.addEventListener("toggle", this)
		}

		disable() {
			this.removeEventListener("click", this), this.removeEventListener("focusout", this), this.removeEventListener("keyup", this), this.removeEventListener("invoke", this), this.removeEventListener("toggle", this)
		}

		handleEvent(e) {
			switch (e.type) {
				case"slotchange":
					Ga(this, Qi, Zi).call(this, e);
					break;
				case"invoke":
					Ga(this, ia, aa).call(this, e);
					break;
				case"click":
					Ga(this, fa, pa).call(this, e);
					break;
				case"toggle":
					Ga(this, Ea, ba).call(this, e);
					break;
				case"focusout":
					Ga(this, Aa, _a).call(this, e);
					break;
				case"keydown":
					Ga(this, ka, Sa).call(this, e)
			}
		}

		connectedCallback() {
			var e, t;
			Ga(this, ea, ta).call(this), this.hasAttribute("disabled") || this.enable(), this.role || (this.role = "menu"), Wa(this, Gi, ae(this)), null == (t = null == (e = $a(this, Gi)) ? void 0 : e.associateElement) || t.call(e, this), this.hidden || (ee(er(this), $a(this, la)), ee(this, $a(this, da)))
		}

		disconnectedCallback() {
			var e, t;
			te(er(this), $a(this, la)), te(this, $a(this, da)), this.disable(), null == (t = null == (e = $a(this, Gi)) ? void 0 : e.unassociateElement) || t.call(e, this), Wa(this, Gi, null)
		}

		attributeChangedCallback(e, t, i) {
			var a, r, n, s;
			e === za && i !== t ? ($a(this, Xi) || Wa(this, Xi, !0), this.hidden ? Ga(this, sa, oa).call(this) : Ga(this, ra, na).call(this), this.dispatchEvent(new Ua({
				oldState: this.hidden ? "open" : "closed",
				newState: this.hidden ? "closed" : "open",
				bubbles: !0
			}))) : e === f.MEDIA_CONTROLLER ? (t && (null == (r = null == (a = $a(this, Gi)) ? void 0 : a.unassociateElement) || r.call(a, this), Wa(this, Gi, null)), i && this.isConnected && (Wa(this, Gi, ae(this)), null == (s = null == (n = $a(this, Gi)) ? void 0 : n.associateElement) || s.call(n, this))) : e === Xa && i !== t ? null == i ? this.enable() : this.disable() : e === ja && i !== t && Ga(this, ea, ta).call(this)
		}

		formatMenuItemText(e, t) {
			return this.constructor.formatMenuItemText(e, t)
		}

		focus() {
			if (Wa(this, Vi, le()), this.items.length) return Ga(this, Da, Ca).call(this, this.items[0]), void this.items[0].focus();
			let e = this.querySelector('[autofocus], [tabindex]:not([tabindex="-1"]), [role="menu"]');
			null == e || e.focus()
		}

		handleSelect(e) {
			var t;
			let i = Ga(this, wa, La).call(this, e);
			i && (Ga(this, xa, Ma).call(this, i, "checkbox" === i.type), $a(this, Ki) && !this.hidden && (null == (t = $a(this, Vi)) || t.focus(), this.hidden = !0))
		}

		handleMove(e) {
			var t, i;
			let {key: a} = e, r = this.items,
				n = null != (i = null != (t = Ga(this, wa, La).call(this, e)) ? t : Ga(this, Ra, Ia).call(this)) ? i : r[0],
				s = r.indexOf(n), o = Math.max(0, s);
			"ArrowDown" === a ? o++ : "ArrowUp" === a ? o-- : "Home" === e.key ? o = 0 : "End" === e.key && (o = r.length - 1), o < 0 && (o = r.length - 1), o > r.length - 1 && (o = 0), Ga(this, Da, Ca).call(this, r[o]), r[o].focus()
		}
	};

	function Ja(e) {
		return ["menuitem", "menuitemradio", "menuitemcheckbox"].includes(null == e ? void 0 : e.role)
	}

	function er(e) {
		var t;
		return null != (t = e.getAttribute("bounds") ? oe(e, `#${e.getAttribute("bounds")}`) : ie(e) || e.parentElement) ? t : e
	}

	Gi = new WeakMap, Vi = new WeakMap, Ki = new WeakMap, qi = new WeakMap, Yi = new WeakMap, ji = new WeakMap, zi = new WeakMap, Xi = new WeakMap, Qi = new WeakSet, Zi = function (e) {
		let t = e.target;
		for (let e of t.assignedNodes({flatten: !0})) 3 === e.nodeType && "" === e.textContent.trim() && e.remove();
		if (["header", "title"].includes(t.name)) {
			this.shadowRoot.querySelector('slot[name="header"]').hidden = 0 === t.assignedNodes().length
		}
		t.name || $a(this, Ji).call(this)
	}, Ji = new WeakMap, ea = new WeakSet, ta = function () {
		var e;
		let t = this.shadowRoot.querySelector("#layout-row"),
			i = null == (e = getComputedStyle(this).getPropertyValue("--media-menu-layout")) ? void 0 : e.trim();
		t.setAttribute("media", "row" === i ? "" : "width:0")
	}, ia = new WeakSet, aa = function (e) {
		Wa(this, Ki, e.relatedTarget), se(this, e.relatedTarget) || (this.hidden = !this.hidden)
	}, ra = new WeakSet, na = function () {
		var e;
		null == (e = $a(this, Ki)) || e.setAttribute("aria-expanded", "true"), requestAnimationFrame((() => Ga(this, ua, ha).call(this, !1))), this.addEventListener("transitionend", (() => this.focus()), {once: !0}), ee(er(this), $a(this, la)), ee(this, $a(this, da))
	}, sa = new WeakSet, oa = function () {
		var e;
		null == (e = $a(this, Ki)) || e.setAttribute("aria-expanded", "false"), te(er(this), $a(this, la)), te(this, $a(this, da))
	}, la = new WeakMap, da = new WeakMap, ua = new WeakSet, ha = function (e, t) {
		if (this.hasAttribute("mediacontroller") && !this.anchor || this.hidden || !this.anchorElement) return;
		let {x: i, y: a} = $i({anchor: this.anchorElement, floating: this, placement: "top-start"});
		null != t || (t = this.offsetWidth);
		let r = er(this).getBoundingClientRect(), n = this.anchorElement.getBoundingClientRect(), s = r.width - i - t,
			o = r.height - a - this.offsetHeight, l = r.height - n.height, {style: d} = he(this.shadowRoot, ":host");
		e || d.setProperty("--media-menu-transition-in", "none"), d.setProperty("position", "absolute"), d.setProperty("right", `${Math.max(0, s)}px`), d.setProperty("bottom", `${o}px`), d.setProperty("--_menu-max-height", `${l}px`), d.removeProperty("--media-menu-transition-in")
	}, ca = new WeakSet, ma = function (e) {
		let t = this.querySelector('[role="menuitem"][aria-haspopup][aria-expanded="true"]'),
			i = null == t ? void 0 : t.querySelector('[role="menu"]'), {style: a} = he(this.shadowRoot, ":host");
		if (e || a.setProperty("--media-menu-transition-in", "none"), i) {
			let a = i.offsetHeight, r = Math.max(i.offsetWidth, t.offsetWidth);
			this.style.setProperty("min-width", `${r}px`), this.style.setProperty("min-height", `${a}px`), Ga(this, ua, ha).call(this, e, r)
		} else this.style.removeProperty("min-width"), this.style.removeProperty("min-height"), Ga(this, ua, ha).call(this, e);
		a.removeProperty("--media-menu-transition-in")
	}, fa = new WeakSet, pa = function (e) {
		var t;
		if (e.stopPropagation(), e.composedPath().includes($a(this, ga, va))) return null == (t = $a(this, Vi)) || t.focus(), void (this.hidden = !0);
		let i = Ga(this, wa, La).call(this, e);
		!i || i.hasAttribute("disabled") || (Ga(this, Da, Ca).call(this, i), this.handleSelect(e))
	}, ga = new WeakSet, va = function () {
		var e;
		return null == (e = this.shadowRoot.querySelector('slot[name="header"]').assignedElements({flatten: !0})) ? void 0 : e.find((e => e.part.contains("back") && e.part.contains("button")))
	}, Ea = new WeakSet, ba = function (e) {
		if (e.target === this) return;
		Ga(this, ya, Ta).call(this);
		let t = Array.from(this.querySelectorAll('[role="menuitem"][aria-haspopup]'));
		for (let i of t) i.invokeTargetElement != e.target && "open" == e.newState && "true" == i.getAttribute("aria-expanded") && !i.invokeTargetElement.hidden && i.invokeTargetElement.dispatchEvent(new Na({relatedTarget: i}));
		for (let e of t) e.setAttribute("aria-expanded", `${!e.submenuElement.hidden}`);
		Ga(this, ca, ma).call(this, !0)
	}, ya = new WeakSet, Ta = function () {
		let e = this.querySelector('[role="menuitem"] > [role="menu"]:not([hidden])');
		this.container.classList.toggle("has-expanded", !!e)
	}, Aa = new WeakSet, _a = function (e) {
		var t;
		se(this, e.relatedTarget) || ($a(this, Xi) && (null == (t = $a(this, Vi)) || t.focus()), $a(this, Ki) && $a(this, Ki) !== e.relatedTarget && !this.hidden && (this.hidden = !0))
	}, ka = new WeakSet, Sa = function (e) {
		var t, i, a, r, n;
		let {key: s, ctrlKey: o, altKey: l, metaKey: d} = e;
		if (!(o || l || d) && this.keysUsed.includes(s)) if (e.preventDefault(), e.stopPropagation(), "Tab" === s) {
			if ($a(this, Xi)) return void (this.hidden = !0);
			e.shiftKey ? null == (i = null == (t = this.previousElementSibling) ? void 0 : t.focus) || i.call(t) : null == (r = null == (a = this.nextElementSibling) ? void 0 : a.focus) || r.call(a), this.blur()
		} else "Escape" === s ? (null == (n = $a(this, Vi)) || n.focus(), $a(this, Xi) && (this.hidden = !0)) : "Enter" === s || " " === s ? this.handleSelect(e) : this.handleMove(e)
	}, wa = new WeakSet, La = function (e) {
		return e.composedPath().find((e => ["menuitemradio", "menuitemcheckbox"].includes(e.role)))
	}, Ra = new WeakSet, Ia = function () {
		return this.items.find((e => 0 === e.tabIndex))
	}, Da = new WeakSet, Ca = function (e) {
		for (let t of this.items) t.tabIndex = t === e ? 0 : -1
	}, xa = new WeakSet, Ma = function (e, t) {
		let i = [...this.checkedItems];
		"radio" === e.type && this.radioGroupItems.forEach((e => e.checked = !1)), e.checked = !t || !e.checked, this.checkedItems.some(((e, t) => e != i[t])) && this.dispatchEvent(new Event("change", {
			bubbles: !0,
			composed: !0
		}))
	}, ((e, t, i) => {
		t in e ? Fa(e, t, {enumerable: !0, configurable: !0, writable: !0, value: i}) : e[t] = i
	})(Za, "symbol" != typeof (Ya = "template") ? Ya + "" : Ya, qa), z.customElements.get("media-chrome-menu") || z.customElements.define("media-chrome-menu", Za);
	var tr, ir, ar, rr, nr, sr, or = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, lr = (e, t, i) => (or(e, t, "read from private field"), i ? i.call(e) : t.get(e)), dr = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, ur = (e, t, i, a) => (or(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		hr = (e, t, i) => (or(e, t, "access private method"), i);
	tr = new WeakMap, ir = new WeakMap, ar = new WeakSet, rr = function () {
		if (lr(this, ir) === JSON.stringify(this.mediaAudioTrackList)) return;
		ur(this, ir, JSON.stringify(this.mediaAudioTrackList));
		let e = this.mediaAudioTrackList;
		this.defaultSlot.textContent = "";
		for (let t of e) {
			let e = Va({
				type: "radio",
				text: this.formatMenuItemText(t.label, t),
				value: `${t.id}`,
				checked: t.enabled
			});
			e.prepend(Ka(this, "checked-indicator")), this.defaultSlot.append(e)
		}
	}, nr = new WeakSet, sr = function () {
		if (null == this.value) return;
		let e = new z.CustomEvent(m.MEDIA_AUDIO_TRACK_REQUEST, {composed: !0, bubbles: !0, detail: this.value});
		this.dispatchEvent(e)
	}, z.customElements.get("media-audio-track-menu") || z.customElements.define("media-audio-track-menu", class extends Za {
		constructor() {
			super(...arguments), dr(this, ar), dr(this, nr), dr(this, tr, []), dr(this, ir, void 0)
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_AUDIO_TRACK_LIST, v.MEDIA_AUDIO_TRACK_ENABLED, v.MEDIA_AUDIO_TRACK_UNAVAILABLE]
		}

		get anchorElement() {
			return "auto" !== this.anchor ? super.anchorElement : ie(this).querySelector("media-audio-track-menu-button")
		}

		get mediaAudioTrackList() {
			return lr(this, tr)
		}

		set mediaAudioTrackList(e) {
			ur(this, tr, e), hr(this, ar, rr).call(this)
		}

		get mediaAudioTrackEnabled() {
			return ve(this, v.MEDIA_AUDIO_TRACK_ENABLED)
		}

		set mediaAudioTrackEnabled(e) {
			Ee(this, v.MEDIA_AUDIO_TRACK_ENABLED, e)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_AUDIO_TRACK_ENABLED && t !== i ? this.value = i : e === v.MEDIA_AUDIO_TRACK_LIST && t !== i && (ur(this, tr, O(i)), hr(this, ar, rr).call(this))
		}

		connectedCallback() {
			super.connectedCallback(), this.addEventListener("change", hr(this, nr, sr))
		}

		disconnectedCallback() {
			super.disconnectedCallback(), this.removeEventListener("change", hr(this, nr, sr))
		}
	});
	var cr = class extends Ni {
		get invokeTarget() {
			return this.getAttribute("invoketarget")
		}

		set invokeTarget(e) {
			this.setAttribute("invoketarget", `${e}`)
		}

		get invokeTargetElement() {
			var e;
			return this.invokeTarget ? null == (e = de(this)) ? void 0 : e.querySelector(`#${this.invokeTarget}`) : null
		}

		connectedCallback() {
			super.connectedCallback(), this.invokeTargetElement && this.setAttribute("aria-haspopup", "menu")
		}

		handleClick() {
			this.invokeTargetElement.dispatchEvent(new Na({relatedTarget: this}))
		}
	};
	z.customElements.get("media-chrome-menu-button") || z.customElements.define("media-chrome-menu-button", cr);
	var mr = X.createElement("template");
	mr.innerHTML = '\n  <slot name="icon"><svg aria-hidden="true" viewBox="0 0 24 24">\n  <path d="M11 17H9.5V7H11v10Zm-3-3H6.5v-4H8v4Zm6-5h-1.5v6H14V9Zm3 7h-1.5V8H17v8Z"/>\n  <path d="M22 12c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10Zm-2 0a8 8 0 1 0-16 0 8 8 0 0 0 16 0Z"/>\n</svg></slot>\n';
	z.customElements.get("media-audio-track-menu-button") || z.customElements.define("media-audio-track-menu-button", class extends cr {
		constructor() {
			super({slotTemplate: mr})
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_AUDIO_TRACK_ENABLED, v.MEDIA_AUDIO_TRACK_UNAVAILABLE]
		}

		get invokeTargetElement() {
			return null != this.invokeTarget ? super.invokeTargetElement : ie(this).querySelector("media-audio-track-menu")
		}

		get mediaAudioTrackEnabled() {
			return ve(this, v.MEDIA_AUDIO_TRACK_ENABLED)
		}

		set mediaAudioTrackEnabled(e) {
			Ee(this, v.MEDIA_AUDIO_TRACK_ENABLED, e)
		}

		connectedCallback() {
			super.connectedCallback(), this.setAttribute("aria-label", I.AUDIO_TRACKS())
		}
	});
	var fr = X.createElement("template");
	fr.innerHTML = '\n  <style>\n    :host([aria-checked="true"]) slot[name=off] {\n      display: none !important;\n    }\n\n    \n    :host(:not([aria-checked="true"])) slot[name=on] {\n      display: none !important;\n    }\n  </style>\n\n  <slot name="icon">\n    <slot name="on"><svg aria-hidden="true" viewBox="0 0 26 24">\n  <path d="M22.83 5.68a2.58 2.58 0 0 0-2.3-2.5c-3.62-.24-11.44-.24-15.06 0a2.58 2.58 0 0 0-2.3 2.5c-.23 4.21-.23 8.43 0 12.64a2.58 2.58 0 0 0 2.3 2.5c3.62.24 11.44.24 15.06 0a2.58 2.58 0 0 0 2.3-2.5c.23-4.21.23-8.43 0-12.64Zm-11.39 9.45a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.92 3.92 0 0 1 .92-2.77 3.18 3.18 0 0 1 2.43-1 2.94 2.94 0 0 1 2.13.78c.364.359.62.813.74 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.17 1.61 1.61 0 0 0-1.29.58 2.79 2.79 0 0 0-.5 1.89 3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.48 1.48 0 0 0 1-.37 2.1 2.1 0 0 0 .59-1.14l1.4.44a3.23 3.23 0 0 1-1.07 1.69Zm7.22 0a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.88 3.88 0 0 1 .93-2.77 3.14 3.14 0 0 1 2.42-1 3 3 0 0 1 2.16.82 2.8 2.8 0 0 1 .73 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.21 1.61 1.61 0 0 0-1.29.58A2.79 2.79 0 0 0 15 12a3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.44 1.44 0 0 0 1-.37 2.1 2.1 0 0 0 .6-1.15l1.4.44a3.17 3.17 0 0 1-1.1 1.7Z"/>\n</svg></slot>\n    <slot name="off"><svg aria-hidden="true" viewBox="0 0 26 24">\n  <path d="M17.73 14.09a1.4 1.4 0 0 1-1 .37 1.579 1.579 0 0 1-1.27-.58A3 3 0 0 1 15 12a2.8 2.8 0 0 1 .5-1.85 1.63 1.63 0 0 1 1.29-.57 1.47 1.47 0 0 1 1.51 1.2l1.43-.34A2.89 2.89 0 0 0 19 9.07a3 3 0 0 0-2.14-.78 3.14 3.14 0 0 0-2.42 1 3.91 3.91 0 0 0-.93 2.78 3.74 3.74 0 0 0 .92 2.66 3.07 3.07 0 0 0 2.34 1 3.07 3.07 0 0 0 1.91-.57 3.17 3.17 0 0 0 1.07-1.74l-1.4-.45c-.083.43-.3.822-.62 1.12Zm-7.22 0a1.43 1.43 0 0 1-1 .37 1.58 1.58 0 0 1-1.27-.58A3 3 0 0 1 7.76 12a2.8 2.8 0 0 1 .5-1.85 1.63 1.63 0 0 1 1.29-.57 1.47 1.47 0 0 1 1.51 1.2l1.43-.34a2.81 2.81 0 0 0-.74-1.32 2.94 2.94 0 0 0-2.13-.78 3.18 3.18 0 0 0-2.43 1 4 4 0 0 0-.92 2.78 3.74 3.74 0 0 0 .92 2.66 3.07 3.07 0 0 0 2.34 1 3.07 3.07 0 0 0 1.91-.57 3.23 3.23 0 0 0 1.07-1.74l-1.4-.45a2.06 2.06 0 0 1-.6 1.07Zm12.32-8.41a2.59 2.59 0 0 0-2.3-2.51C18.72 3.05 15.86 3 13 3c-2.86 0-5.72.05-7.53.17a2.59 2.59 0 0 0-2.3 2.51c-.23 4.207-.23 8.423 0 12.63a2.57 2.57 0 0 0 2.3 2.5c1.81.13 4.67.19 7.53.19 2.86 0 5.72-.06 7.53-.19a2.57 2.57 0 0 0 2.3-2.5c.23-4.207.23-8.423 0-12.63Zm-1.49 12.53a1.11 1.11 0 0 1-.91 1.11c-1.67.11-4.45.18-7.43.18-2.98 0-5.76-.07-7.43-.18a1.11 1.11 0 0 1-.91-1.11c-.21-4.14-.21-8.29 0-12.43a1.11 1.11 0 0 1 .91-1.11C7.24 4.56 10 4.49 13 4.49s5.76.07 7.43.18a1.11 1.11 0 0 1 .91 1.11c.21 4.14.21 8.29 0 12.43Z"/>\n</svg></slot>\n  </slot>\n';
	var pr = e => {
		e.setAttribute("aria-checked", pt(e))
	}, gr = (e, t) => {
		let i = e.getAttribute(t);
		return i ? lt(i) : []
	}, vr = (e, t, i) => {
		if (null == i || !i.length) return void e.removeAttribute(t);
		let a = ht(i);
		e.getAttribute(t) !== a && e.setAttribute(t, a)
	};
	z.customElements.get("media-captions-button") || z.customElements.define("media-captions-button", class extends Ni {
		constructor(e = {}) {
			super({slotTemplate: fr, ...e}), this._captionsReady = !1
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_SUBTITLES_LIST, v.MEDIA_SUBTITLES_SHOWING]
		}

		get mediaSubtitlesList() {
			return gr(this, v.MEDIA_SUBTITLES_LIST)
		}

		set mediaSubtitlesList(e) {
			vr(this, v.MEDIA_SUBTITLES_LIST, e)
		}

		get mediaSubtitlesShowing() {
			return gr(this, v.MEDIA_SUBTITLES_SHOWING)
		}

		set mediaSubtitlesShowing(e) {
			vr(this, v.MEDIA_SUBTITLES_SHOWING, e)
		}

		connectedCallback() {
			super.connectedCallback(), this.setAttribute("role", "switch"), this.setAttribute("aria-label", I.CLOSED_CAPTIONS()), pr(this)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_SUBTITLES_SHOWING && pr(this)
		}

		handleClick() {
			this.dispatchEvent(new z.CustomEvent(m.MEDIA_TOGGLE_SUBTITLES_REQUEST, {composed: !0, bubbles: !0}))
		}
	});
	var Er, br, yr, Tr, Ar, _r = Object.defineProperty, kr = (e, t, i) => {
		if (!t.has(e)) throw TypeError("Cannot " + i)
	}, Sr = (e, t, i) => {
		if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
		t instanceof WeakSet ? t.add(e) : t.set(e, i)
	}, wr = (e, t, i) => (kr(e, t, "access private method"), i), Lr = X.createElement("template");
	Lr.innerHTML = Za.template.innerHTML + '\n  <slot name="captions-indicator" hidden>\n  <svg aria-hidden="true" viewBox="0 0 26 24" part="captions-indicator indicator">\n    <path d="M22.83 5.68a2.58 2.58 0 0 0-2.3-2.5c-3.62-.24-11.44-.24-15.06 0a2.58 2.58 0 0 0-2.3 2.5c-.23 4.21-.23 8.43 0 12.64a2.58 2.58 0 0 0 2.3 2.5c3.62.24 11.44.24 15.06 0a2.58 2.58 0 0 0 2.3-2.5c.23-4.21.23-8.43 0-12.64Zm-11.39 9.45a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.92 3.92 0 0 1 .92-2.77 3.18 3.18 0 0 1 2.43-1 2.94 2.94 0 0 1 2.13.78c.364.359.62.813.74 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.17 1.61 1.61 0 0 0-1.29.58 2.79 2.79 0 0 0-.5 1.89 3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.48 1.48 0 0 0 1-.37 2.1 2.1 0 0 0 .59-1.14l1.4.44a3.23 3.23 0 0 1-1.07 1.69Zm7.22 0a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.88 3.88 0 0 1 .93-2.77 3.14 3.14 0 0 1 2.42-1 3 3 0 0 1 2.16.82 2.8 2.8 0 0 1 .73 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.21 1.61 1.61 0 0 0-1.29.58A2.79 2.79 0 0 0 15 12a3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.44 1.44 0 0 0 1-.37 2.1 2.1 0 0 0 .6-1.15l1.4.44a3.17 3.17 0 0 1-1.1 1.7Z"/>\n  </svg></slot>';
	var Rr = class extends Za {
		constructor() {
			super(...arguments), Sr(this, br), Sr(this, Tr), Sr(this, Er, void 0)
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_SUBTITLES_LIST, v.MEDIA_SUBTITLES_SHOWING]
		}

		get anchorElement() {
			return "auto" !== this.anchor ? super.anchorElement : ie(this).querySelector("media-captions-menu-button")
		}

		get mediaSubtitlesList() {
			return Ir(this, v.MEDIA_SUBTITLES_LIST)
		}

		set mediaSubtitlesList(e) {
			Dr(this, v.MEDIA_SUBTITLES_LIST, e)
		}

		get mediaSubtitlesShowing() {
			return Ir(this, v.MEDIA_SUBTITLES_SHOWING)
		}

		set mediaSubtitlesShowing(e) {
			Dr(this, v.MEDIA_SUBTITLES_SHOWING, e)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_SUBTITLES_LIST && t !== i ? wr(this, br, yr).call(this) : e === v.MEDIA_SUBTITLES_SHOWING && t !== i && (this.value = i)
		}

		connectedCallback() {
			super.connectedCallback(), this.addEventListener("change", wr(this, Tr, Ar))
		}

		disconnectedCallback() {
			super.disconnectedCallback(), this.removeEventListener("change", wr(this, Tr, Ar))
		}
	};
	Er = new WeakMap, br = new WeakSet, yr = function () {
		var e;
		if (((e, t, i) => (kr(e, t, "read from private field"), i ? i.call(e) : t.get(e)))(this, Er) === JSON.stringify(this.mediaSubtitlesList)) return;
		((e, t, i, a) => {
			kr(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i)
		})(this, Er, JSON.stringify(this.mediaSubtitlesList)), this.defaultSlot.textContent = "";
		let t = !this.value, i = Va({type: "radio", text: this.formatMenuItemText("Off"), value: "off", checked: t});
		i.prepend(Ka(this, "checked-indicator")), this.defaultSlot.append(i);
		let a = this.mediaSubtitlesList;
		for (let t of a) {
			let i = Va({
				type: "radio",
				text: this.formatMenuItemText(t.label, t),
				value: ut(t),
				checked: this.value == ut(t)
			});
			i.prepend(Ka(this, "checked-indicator")), "captions" === (null != (e = t.kind) ? e : "subs") && i.append(Ka(this, "captions-indicator")), this.defaultSlot.append(i)
		}
	}, Tr = new WeakSet, Ar = function () {
		let e = this.mediaSubtitlesShowing, t = this.getAttribute(v.MEDIA_SUBTITLES_SHOWING), i = this.value !== t;
		if (null != e && e.length && i && this.dispatchEvent(new z.CustomEvent(m.MEDIA_DISABLE_SUBTITLES_REQUEST, {
			composed: !0,
			bubbles: !0,
			detail: e
		})), !this.value || !i) return;
		let a = new z.CustomEvent(m.MEDIA_SHOW_SUBTITLES_REQUEST, {composed: !0, bubbles: !0, detail: this.value});
		this.dispatchEvent(a)
	}, ((e, t, i) => {
		((e, t, i) => {
			t in e ? _r(e, t, {enumerable: !0, configurable: !0, writable: !0, value: i}) : e[t] = i
		})(e, "symbol" != typeof t ? t + "" : t, i)
	})(Rr, "template", Lr);
	var Ir = (e, t) => {
		let i = e.getAttribute(t);
		return i ? lt(i) : []
	}, Dr = (e, t, i) => {
		if (null == i || !i.length) return void e.removeAttribute(t);
		let a = ht(i);
		e.getAttribute(t) !== a && e.setAttribute(t, a)
	};
	z.customElements.get("media-captions-menu") || z.customElements.define("media-captions-menu", Rr);
	var Cr = X.createElement("template");
	Cr.innerHTML = '\n  <style>\n    :host([aria-checked="true"]) slot[name=off] {\n      display: none !important;\n    }\n\n    \n    :host(:not([aria-checked="true"])) slot[name=on] {\n      display: none !important;\n    }\n  </style>\n\n  <slot name="icon">\n    <slot name="on"><svg aria-hidden="true" viewBox="0 0 26 24">\n  <path d="M22.83 5.68a2.58 2.58 0 0 0-2.3-2.5c-3.62-.24-11.44-.24-15.06 0a2.58 2.58 0 0 0-2.3 2.5c-.23 4.21-.23 8.43 0 12.64a2.58 2.58 0 0 0 2.3 2.5c3.62.24 11.44.24 15.06 0a2.58 2.58 0 0 0 2.3-2.5c.23-4.21.23-8.43 0-12.64Zm-11.39 9.45a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.92 3.92 0 0 1 .92-2.77 3.18 3.18 0 0 1 2.43-1 2.94 2.94 0 0 1 2.13.78c.364.359.62.813.74 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.17 1.61 1.61 0 0 0-1.29.58 2.79 2.79 0 0 0-.5 1.89 3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.48 1.48 0 0 0 1-.37 2.1 2.1 0 0 0 .59-1.14l1.4.44a3.23 3.23 0 0 1-1.07 1.69Zm7.22 0a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.88 3.88 0 0 1 .93-2.77 3.14 3.14 0 0 1 2.42-1 3 3 0 0 1 2.16.82 2.8 2.8 0 0 1 .73 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.21 1.61 1.61 0 0 0-1.29.58A2.79 2.79 0 0 0 15 12a3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.44 1.44 0 0 0 1-.37 2.1 2.1 0 0 0 .6-1.15l1.4.44a3.17 3.17 0 0 1-1.1 1.7Z"/>\n</svg></slot>\n    <slot name="off"><svg aria-hidden="true" viewBox="0 0 26 24">\n  <path d="M17.73 14.09a1.4 1.4 0 0 1-1 .37 1.579 1.579 0 0 1-1.27-.58A3 3 0 0 1 15 12a2.8 2.8 0 0 1 .5-1.85 1.63 1.63 0 0 1 1.29-.57 1.47 1.47 0 0 1 1.51 1.2l1.43-.34A2.89 2.89 0 0 0 19 9.07a3 3 0 0 0-2.14-.78 3.14 3.14 0 0 0-2.42 1 3.91 3.91 0 0 0-.93 2.78 3.74 3.74 0 0 0 .92 2.66 3.07 3.07 0 0 0 2.34 1 3.07 3.07 0 0 0 1.91-.57 3.17 3.17 0 0 0 1.07-1.74l-1.4-.45c-.083.43-.3.822-.62 1.12Zm-7.22 0a1.43 1.43 0 0 1-1 .37 1.58 1.58 0 0 1-1.27-.58A3 3 0 0 1 7.76 12a2.8 2.8 0 0 1 .5-1.85 1.63 1.63 0 0 1 1.29-.57 1.47 1.47 0 0 1 1.51 1.2l1.43-.34a2.81 2.81 0 0 0-.74-1.32 2.94 2.94 0 0 0-2.13-.78 3.18 3.18 0 0 0-2.43 1 4 4 0 0 0-.92 2.78 3.74 3.74 0 0 0 .92 2.66 3.07 3.07 0 0 0 2.34 1 3.07 3.07 0 0 0 1.91-.57 3.23 3.23 0 0 0 1.07-1.74l-1.4-.45a2.06 2.06 0 0 1-.6 1.07Zm12.32-8.41a2.59 2.59 0 0 0-2.3-2.51C18.72 3.05 15.86 3 13 3c-2.86 0-5.72.05-7.53.17a2.59 2.59 0 0 0-2.3 2.51c-.23 4.207-.23 8.423 0 12.63a2.57 2.57 0 0 0 2.3 2.5c1.81.13 4.67.19 7.53.19 2.86 0 5.72-.06 7.53-.19a2.57 2.57 0 0 0 2.3-2.5c.23-4.207.23-8.423 0-12.63Zm-1.49 12.53a1.11 1.11 0 0 1-.91 1.11c-1.67.11-4.45.18-7.43.18-2.98 0-5.76-.07-7.43-.18a1.11 1.11 0 0 1-.91-1.11c-.21-4.14-.21-8.29 0-12.43a1.11 1.11 0 0 1 .91-1.11C7.24 4.56 10 4.49 13 4.49s5.76.07 7.43.18a1.11 1.11 0 0 1 .91 1.11c.21 4.14.21 8.29 0 12.43Z"/>\n</svg></slot>\n  </slot>\n';
	var xr = e => {
		e.setAttribute("aria-checked", pt(e))
	}, Mr = (e, t) => {
		let i = e.getAttribute(t);
		return i ? lt(i) : []
	}, Or = (e, t, i) => {
		if (null == i || !i.length) return void e.removeAttribute(t);
		let a = ht(i);
		e.getAttribute(t) !== a && e.setAttribute(t, a)
	};
	z.customElements.get("media-captions-menu-button") || z.customElements.define("media-captions-menu-button", class extends cr {
		constructor(e = {}) {
			super({slotTemplate: Cr, ...e}), this._captionsReady = !1
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_SUBTITLES_LIST, v.MEDIA_SUBTITLES_SHOWING]
		}

		get invokeTargetElement() {
			return null != this.invokeTarget ? super.invokeTargetElement : ie(this).querySelector("media-captions-menu")
		}

		get mediaSubtitlesList() {
			return Mr(this, v.MEDIA_SUBTITLES_LIST)
		}

		set mediaSubtitlesList(e) {
			Or(this, v.MEDIA_SUBTITLES_LIST, e)
		}

		get mediaSubtitlesShowing() {
			return Mr(this, v.MEDIA_SUBTITLES_SHOWING)
		}

		set mediaSubtitlesShowing(e) {
			Or(this, v.MEDIA_SUBTITLES_SHOWING, e)
		}

		connectedCallback() {
			super.connectedCallback(), this.setAttribute("aria-label", I.CLOSED_CAPTIONS()), xr(this)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_SUBTITLES_SHOWING && xr(this)
		}
	});
	var Pr = X.createElement("template");
	Pr.innerHTML = `\n  <style>\n  :host([${v.MEDIA_IS_CASTING}]) slot:not([name=exit]):not([name=icon]) {\n    display: none !important;\n  }\n\n  \n  :host(:not([${v.MEDIA_IS_CASTING}])) slot:not([name=enter]):not([name=icon]) {\n    display: none !important;\n  }\n  </style>\n\n  <slot name="icon">\n    <slot name="enter"><svg aria-hidden="true" viewBox="0 0 24 24"><g><path class="cast_caf_icon_arch0" d="M1,18 L1,21 L4,21 C4,19.3 2.66,18 1,18 L1,18 Z"/><path class="cast_caf_icon_arch1" d="M1,14 L1,16 C3.76,16 6,18.2 6,21 L8,21 C8,17.13 4.87,14 1,14 L1,14 Z"/><path class="cast_caf_icon_arch2" d="M1,10 L1,12 C5.97,12 10,16.0 10,21 L12,21 C12,14.92 7.07,10 1,10 L1,10 Z"/><path class="cast_caf_icon_box" d="M21,3 L3,3 C1.9,3 1,3.9 1,5 L1,8 L3,8 L3,5 L21,5 L21,19 L14,19 L14,21 L21,21 C22.1,21 23,20.1 23,19 L23,5 C23,3.9 22.1,3 21,3 L21,3 Z"/></g></svg></slot>\n    <slot name="exit"><svg aria-hidden="true" viewBox="0 0 24 24"><g><path class="cast_caf_icon_arch0" d="M1,18 L1,21 L4,21 C4,19.3 2.66,18 1,18 L1,18 Z"/><path class="cast_caf_icon_arch1" d="M1,14 L1,16 C3.76,16 6,18.2 6,21 L8,21 C8,17.13 4.87,14 1,14 L1,14 Z"/><path class="cast_caf_icon_arch2" d="M1,10 L1,12 C5.97,12 10,16.0 10,21 L12,21 C12,14.92 7.07,10 1,10 L1,10 Z"/><path class="cast_caf_icon_box" d="M21,3 L3,3 C1.9,3 1,3.9 1,5 L1,8 L3,8 L3,5 L21,5 L21,19 L14,19 L14,21 L21,21 C22.1,21 23,20.1 23,19 L23,5 C23,3.9 22.1,3 21,3 L21,3 Z"/><path class="cast_caf_icon_boxfill" d="M5,7 L5,8.63 C8,8.6 13.37,14 13.37,17 L19,17 L19,7 Z"/></g></svg></slot>\n  </slot>\n`;
	var Nr = e => {
		let t = e.mediaIsCasting ? D.EXIT_CAST() : D.ENTER_CAST();
		e.setAttribute("aria-label", t)
	};
	z.customElements.get("media-cast-button") || z.customElements.define("media-cast-button", class extends Ni {
		constructor(e = {}) {
			super({slotTemplate: Pr, ...e})
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_IS_CASTING, v.MEDIA_CAST_UNAVAILABLE]
		}

		get mediaIsCasting() {
			return pe(this, v.MEDIA_IS_CASTING)
		}

		set mediaIsCasting(e) {
			ge(this, v.MEDIA_IS_CASTING, e)
		}

		get mediaCastUnavailable() {
			return ve(this, v.MEDIA_CAST_UNAVAILABLE)
		}

		set mediaCastUnavailable(e) {
			Ee(this, v.MEDIA_CAST_UNAVAILABLE, e)
		}

		connectedCallback() {
			super.connectedCallback(), Nr(this)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_IS_CASTING && Nr(this)
		}

		handleClick() {
			let e = this.mediaIsCasting ? m.MEDIA_EXIT_CAST_REQUEST : m.MEDIA_ENTER_CAST_REQUEST;
			this.dispatchEvent(new z.CustomEvent(e, {composed: !0, bubbles: !0}))
		}
	});
	var Ur, Fr, Br, $r, Hr, Wr, Gr, Vr, Kr, qr, Yr, jr, zr = Object.defineProperty, Xr = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, Qr = (e, t, i) => (Xr(e, t, "read from private field"), i ? i.call(e) : t.get(e)), Zr = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, Jr = (e, t, i, a) => (Xr(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		en = (e, t, i) => (Xr(e, t, "access private method"), i), tn = X.createElement("template");
	tn.innerHTML = "\n  <style>\n    :host {\n      font: var(--media-font,\n        var(--media-font-weight, normal)\n        var(--media-font-size, 14px) /\n        var(--media-text-content-height, var(--media-control-height, 24px))\n        var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));\n      color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));\n      background: var(--media-dialog-background, var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .8))));\n      border-radius: var(--media-dialog-border-radius);\n      border: var(--media-dialog-border, none);\n      display: var(--media-dialog-display, inline-flex);\n      transition: var(--media-dialog-transition-in,\n        visibility 0s,\n        opacity .2s ease-out,\n        transform .15s ease-out\n      ) !important;\n      \n      visibility: var(--media-dialog-visibility, visible);\n      opacity: var(--media-dialog-opacity, 1);\n      transform: var(--media-dialog-transform-in, translateY(0) scale(1));\n    }\n\n    :host([hidden]) {\n      transition: var(--media-dialog-transition-out,\n        visibility .15s ease-in,\n        opacity .15s ease-in,\n        transform .15s ease-in\n      ) !important;\n      visibility: var(--media-dialog-hidden-visibility, hidden);\n      opacity: var(--media-dialog-hidden-opacity, 0);\n      transform: var(--media-dialog-transform-out, translateY(2px) scale(.99));\n      pointer-events: none;\n    }\n  </style>\n  <slot></slot>\n";
	var an = "hidden", rn = "anchor", nn = class extends z.HTMLElement {
		constructor() {
			super(), Zr(this, Br), Zr(this, Hr), Zr(this, Gr), Zr(this, Kr), Zr(this, Yr), Zr(this, Ur, void 0), Zr(this, Fr, void 0), this.shadowRoot || (this.attachShadow({mode: "open"}), this.nativeEl = this.constructor.template.content.cloneNode(!0), this.shadowRoot.append(this.nativeEl)), this.addEventListener("invoke", this), this.addEventListener("focusout", this), this.addEventListener("keydown", this)
		}

		static get observedAttributes() {
			return [an, rn]
		}

		get keysUsed() {
			return ["Escape", "Tab"]
		}

		handleEvent(e) {
			switch (e.type) {
				case"invoke":
					en(this, Gr, Vr).call(this, e);
					break;
				case"focusout":
					en(this, Kr, qr).call(this, e);
					break;
				case"keydown":
					en(this, Yr, jr).call(this, e)
			}
		}

		connectedCallback() {
			this.role || (this.role = "dialog")
		}

		attributeChangedCallback(e, t, i) {
			e === an && i !== t && (this.hidden ? en(this, Hr, Wr).call(this) : en(this, Br, $r).call(this))
		}

		focus() {
			Jr(this, Ur, le());
			let e = this.querySelector('[autofocus], [tabindex]:not([tabindex="-1"]), [role="menu"]');
			null == e || e.focus()
		}
	};
	Ur = new WeakMap, Fr = new WeakMap, Br = new WeakSet, $r = function () {
		var e;
		null == (e = Qr(this, Fr)) || e.setAttribute("aria-expanded", "true"), this.addEventListener("transitionend", (() => this.focus()), {once: !0})
	}, Hr = new WeakSet, Wr = function () {
		var e;
		null == (e = Qr(this, Fr)) || e.setAttribute("aria-expanded", "false")
	}, Gr = new WeakSet, Vr = function (e) {
		Jr(this, Fr, e.relatedTarget), se(this, e.relatedTarget) || (this.hidden = !this.hidden)
	}, Kr = new WeakSet, qr = function (e) {
		var t;
		se(this, e.relatedTarget) || (null == (t = Qr(this, Ur)) || t.focus(), Qr(this, Fr) && Qr(this, Fr) !== e.relatedTarget && !this.hidden && (this.hidden = !0))
	}, Yr = new WeakSet, jr = function (e) {
		var t, i, a, r, n;
		let {key: s, ctrlKey: o, altKey: l, metaKey: d} = e;
		o || l || d || this.keysUsed.includes(s) && (e.preventDefault(), e.stopPropagation(), "Tab" === s ? (e.shiftKey ? null == (i = null == (t = this.previousElementSibling) ? void 0 : t.focus) || i.call(t) : null == (r = null == (a = this.nextElementSibling) ? void 0 : a.focus) || r.call(a), this.blur()) : "Escape" === s && (null == (n = Qr(this, Ur)) || n.focus(), this.hidden = !0))
	}, ((e, t, i) => {
		((e, t, i) => {
			t in e ? zr(e, t, {enumerable: !0, configurable: !0, writable: !0, value: i}) : e[t] = i
		})(e, "symbol" != typeof t ? t + "" : t, i)
	})(nn, "template", tn), z.customElements.get("media-chrome-dialog") || z.customElements.define("media-chrome-dialog", nn);
	var sn, on, ln, dn, un, hn, cn, mn, fn, pn, gn, vn, En, bn, yn, Tn = Object.defineProperty, An = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, _n = (e, t, i) => (An(e, t, "read from private field"), i ? i.call(e) : t.get(e)), kn = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, Sn = (e, t, i, a) => (An(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		wn = (e, t, i) => (An(e, t, "access private method"), i), Ln = X.createElement("template");
	Ln.innerHTML = '\n  <style>\n    :host {\n      transition: var(--media-menu-item-transition,\n        background .15s linear,\n        opacity .2s ease-in-out\n      );\n      outline: var(--media-menu-item-outline, 0);\n      outline-offset: var(--media-menu-item-outline-offset, -1px);\n      cursor: pointer;\n      display: flex;\n      align-items: center;\n      align-self: stretch;\n      justify-self: stretch;\n      white-space: nowrap;\n      white-space-collapse: collapse;\n      text-wrap: nowrap;\n      padding: .4em .8em .4em 1em;\n    }\n\n    :host(:focus-visible) {\n      box-shadow: var(--media-menu-item-focus-shadow, inset 0 0 0 2px rgb(27 127 204 / .9));\n      outline: var(--media-menu-item-hover-outline, 0);\n      outline-offset: var(--media-menu-item-hover-outline-offset,  var(--media-menu-item-outline-offset, -1px));\n    }\n\n    :host(:hover) {\n      cursor: pointer;\n      background: var(--media-menu-item-hover-background, rgb(92 92 102 / .5));\n      outline: var(--media-menu-item-hover-outline);\n      outline-offset: var(--media-menu-item-hover-outline-offset,  var(--media-menu-item-outline-offset, -1px));\n    }\n\n    :host([aria-checked="true"]) {\n      background: var(--media-menu-item-checked-background);\n    }\n\n    :host([hidden]) {\n      display: none;\n    }\n\n    :host([disabled]) {\n      pointer-events: none;\n      color: rgba(255, 255, 255, .3);\n    }\n\n    slot:not([name]) {\n      width: 100%;\n    }\n\n    slot:not([name="submenu"]) {\n      display: inline-flex;\n      align-items: center;\n      transition: inherit;\n      opacity: var(--media-menu-item-opacity, 1);\n    }\n\n    slot[name="description"] {\n      justify-content: end;\n    }\n\n    slot[name="description"] > span {\n      display: inline-block;\n      margin-inline: 1em .2em;\n      max-width: var(--media-menu-item-description-max-width, 100px);\n      text-overflow: ellipsis;\n      overflow: hidden;\n      font-size: .8em;\n      font-weight: 400;\n      text-align: right;\n      position: relative;\n      top: .04em;\n    }\n\n    slot[name="checked-indicator"] {\n      display: none;\n    }\n\n    :host(:is([role="menuitemradio"],[role="menuitemcheckbox"])) slot[name="checked-indicator"] {\n      display: var(--media-menu-item-checked-indicator-display, inline-block);\n    }\n\n    \n    svg, img, ::slotted(svg), ::slotted(img) {\n      height: var(--media-menu-item-icon-height, var(--media-control-height, 24px));\n      fill: var(--media-icon-color, var(--media-primary-color, rgb(238 238 238)));\n      display: block;\n    }\n\n    \n    [part~="indicator"],\n    ::slotted([part~="indicator"]) {\n      fill: var(--media-menu-item-indicator-fill,\n        var(--media-icon-color, var(--media-primary-color, rgb(238 238 238))));\n      height: var(--media-menu-item-indicator-height, 1.25em);\n      margin-right: .5ch;\n    }\n\n    [part~="checked-indicator"] {\n      visibility: hidden;\n    }\n\n    :host([aria-checked="true"]) [part~="checked-indicator"] {\n      visibility: visible;\n    }\n  </style>\n  <slot name="checked-indicator">\n    <svg aria-hidden="true" viewBox="0 1 24 24" part="checked-indicator indicator">\n      <path d="m10 15.17 9.193-9.191 1.414 1.414-10.606 10.606-6.364-6.364 1.414-1.414 4.95 4.95Z"/>\n    </svg>\n  </slot>\n  <slot name="prefix"></slot>\n  <slot></slot>\n  <slot name="description"></slot>\n  <slot name="suffix"></slot>\n  <slot name="submenu"></slot>\n';
	var Rn = "type", In = "value", Dn = "checked", Cn = "disabled", xn = class extends z.HTMLElement {
		constructor() {
			super(), kn(this, ln), kn(this, un), kn(this, cn), kn(this, pn), kn(this, vn), kn(this, bn), kn(this, sn, !1), kn(this, on, void 0), kn(this, fn, (() => {
				var e, t;
				this.setAttribute("submenusize", `${this.submenuElement.items.length}`);
				let i = this.shadowRoot.querySelector('slot[name="description"]'),
					a = null == (t = null == (e = this.submenuElement.checkedItems) ? void 0 : e[0]) ? void 0 : t.text,
					r = X.createElement("span");
				r.textContent = null != a ? a : "", i.replaceChildren(r)
			})), this.shadowRoot || (this.attachShadow({mode: "open"}), this.shadowRoot.append(this.constructor.template.content.cloneNode(!0))), this.shadowRoot.addEventListener("slotchange", this)
		}

		static get observedAttributes() {
			return [Rn, Cn, Dn, In]
		}

		get invokeTarget() {
			return this.getAttribute("invoketarget")
		}

		set invokeTarget(e) {
			this.setAttribute("invoketarget", `${e}`)
		}

		get invokeTargetElement() {
			var e;
			return this.invokeTarget ? null == (e = de(this)) ? void 0 : e.querySelector(`#${this.invokeTarget}`) : this.submenuElement
		}

		get submenuElement() {
			return this.shadowRoot.querySelector('slot[name="submenu"]').assignedElements({flatten: !0})[0]
		}

		get type() {
			var e;
			return null != (e = this.getAttribute(Rn)) ? e : ""
		}

		set type(e) {
			this.setAttribute(Rn, `${e}`)
		}

		get value() {
			var e;
			return null != (e = this.getAttribute(In)) ? e : this.text
		}

		set value(e) {
			this.setAttribute(In, e)
		}

		get text() {
			var e;
			return (null != (e = this.textContent) ? e : "").trim()
		}

		get checked() {
			if (Mn(this)) return "true" === this.getAttribute("aria-checked")
		}

		set checked(e) {
			Mn(this) && (Sn(this, sn, !0), this.setAttribute("aria-checked", e ? "true" : "false"), e ? this.part.add("checked") : this.part.remove("checked"))
		}

		get keysUsed() {
			return ["Enter", " "]
		}

		enable() {
			this.hasAttribute("tabindex") || this.setAttribute("tabindex", "-1"), Mn(this) && !this.hasAttribute("aria-checked") && this.setAttribute("aria-checked", "false"), this.addEventListener("click", this), this.addEventListener("keydown", this)
		}

		disable() {
			this.removeAttribute("tabindex"), this.removeEventListener("click", this), this.removeEventListener("keydown", this), this.removeEventListener("keyup", this)
		}

		handleEvent(e) {
			switch (e.type) {
				case"slotchange":
					wn(this, ln, dn).call(this, e);
					break;
				case"click":
					this.handleClick(e);
					break;
				case"keydown":
					wn(this, vn, En).call(this, e);
					break;
				case"keyup":
					wn(this, pn, gn).call(this, e)
			}
		}

		attributeChangedCallback(e, t, i) {
			e === Dn && Mn(this) && !_n(this, sn) ? this.setAttribute("aria-checked", null != i ? "true" : "false") : e === Rn && i !== t ? this.role = "menuitem" + i : e === Cn && i !== t && (null == i ? this.enable() : this.disable())
		}

		connectedCallback() {
			this.hasAttribute(Cn) || this.enable(), this.role = "menuitem" + this.type, Sn(this, on, On(this, this.parentNode)), wn(this, bn, yn).call(this)
		}

		disconnectedCallback() {
			this.disable(), wn(this, bn, yn).call(this), Sn(this, on, null)
		}

		handleClick(e) {
			Mn(this) || this.invokeTargetElement && se(this, e.target) && this.invokeTargetElement.dispatchEvent(new Na({relatedTarget: this}))
		}
	};

	function Mn(e) {
		return "radio" === e.type || "checkbox" === e.type
	}

	function On(e, t) {
		if (!e) return null;
		let {host: i} = e.getRootNode();
		return !t && i ? On(e, i) : null != t && t.items ? t : On(t, null == t ? void 0 : t.parentNode)
	}

	sn = new WeakMap, on = new WeakMap, ln = new WeakSet, dn = function (e) {
		let t = e.target;
		if (null == t || !t.name) for (let e of t.assignedNodes({flatten: !0})) e instanceof Text && "" === e.textContent.trim() && e.remove();
		"submenu" === t.name && (this.submenuElement ? wn(this, un, hn).call(this) : wn(this, cn, mn).call(this))
	}, un = new WeakSet, hn = async function () {
		this.setAttribute("aria-haspopup", "menu"), this.setAttribute("aria-expanded", `${!this.submenuElement.hidden}`), this.submenuElement.addEventListener("change", _n(this, fn)), this.submenuElement.addEventListener("addmenuitem", _n(this, fn)), this.submenuElement.addEventListener("removemenuitem", _n(this, fn)), _n(this, fn).call(this)
	}, cn = new WeakSet, mn = function () {
		this.removeAttribute("aria-haspopup"), this.removeAttribute("aria-expanded"), this.submenuElement.removeEventListener("change", _n(this, fn)), this.submenuElement.removeEventListener("addmenuitem", _n(this, fn)), this.submenuElement.removeEventListener("removemenuitem", _n(this, fn)), _n(this, fn).call(this)
	}, fn = new WeakMap, pn = new WeakSet, gn = function (e) {
		let {key: t} = e;
		this.keysUsed.includes(t) ? this.handleClick(e) : this.removeEventListener("keyup", wn(this, pn, gn))
	}, vn = new WeakSet, En = function (e) {
		let {metaKey: t, altKey: i, key: a} = e;
		t || i || !this.keysUsed.includes(a) ? this.removeEventListener("keyup", wn(this, pn, gn)) : this.addEventListener("keyup", wn(this, pn, gn), {once: !0})
	}, bn = new WeakSet, yn = function () {
		var e;
		let t = null == (e = _n(this, on)) ? void 0 : e.radioGroupItems;
		if (!t) return;
		let i = t.filter((e => "true" === e.getAttribute("aria-checked"))).pop();
		i || (i = t[0]);
		for (let e of t) e.setAttribute("aria-checked", "false");
		null == i || i.setAttribute("aria-checked", "true")
	}, ((e, t, i) => {
		((e, t, i) => {
			t in e ? Tn(e, t, {enumerable: !0, configurable: !0, writable: !0, value: i}) : e[t] = i
		})(e, "symbol" != typeof t ? t + "" : t, i)
	})(xn, "template", Ln), z.customElements.get("media-chrome-menu-item") || z.customElements.define("media-chrome-menu-item", xn);
	var Pn, Nn, Un, Fn, Bn, $n, Hn, Wn, Gn, Vn, Kn, qn, Yn, jn, zn, Xn, Qn, Zn, Jn, es, ts, is, as, rs, ns,
		ss = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, os = (e, t, i) => (ss(e, t, "read from private field"), i ? i.call(e) : t.get(e)), ls = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, ds = (e, t, i, a) => (ss(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		us = (e, t, i) => (ss(e, t, "access private method"), i), hs = X.createElement("template");
	hs.innerHTML = '\n  <style>\n    :host {\n      --_focus-box-shadow: var(--media-focus-box-shadow, inset 0 0 0 2px rgb(27 127 204 / .9));\n      --_media-range-padding: var(--media-range-padding, var(--media-control-padding, 10px));\n\n      box-shadow: var(--_focus-visible-box-shadow, none);\n      background: var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7)));\n      height: calc(var(--media-control-height, 24px) + 2 * var(--_media-range-padding));\n      display: inline-flex;\n      align-items: center;\n      \n      vertical-align: middle;\n      box-sizing: border-box;\n      position: relative;\n      width: 100px;\n      transition: background .15s linear;\n      cursor: pointer;\n      pointer-events: auto;\n      touch-action: none; \n      z-index: 1; \n    }\n\n    \n    input[type=range]:focus {\n      outline: 0;\n    }\n    input[type=range]:focus::-webkit-slider-runnable-track {\n      outline: 0;\n    }\n\n    :host(:hover) {\n      background: var(--media-control-hover-background, rgb(50 50 70 / .7));\n    }\n\n    #leftgap {\n      padding-left: var(--media-range-padding-left, var(--_media-range-padding));\n    }\n\n    #rightgap {\n      padding-right: var(--media-range-padding-right, var(--_media-range-padding));\n    }\n\n    #startpoint,\n    #endpoint {\n      position: absolute;\n    }\n\n    #endpoint {\n      right: 0;\n    }\n\n    #container {\n      \n      width: var(--media-range-track-width, 100%);\n      transform: translate(var(--media-range-track-translate-x, 0px), var(--media-range-track-translate-y, 0px));\n      position: relative;\n      height: 100%;\n      display: flex;\n      align-items: center;\n      min-width: 40px;\n    }\n\n    #range {\n      \n      display: var(--media-time-range-hover-display, block);\n      bottom: var(--media-time-range-hover-bottom, -7px);\n      height: var(--media-time-range-hover-height, max(100% + 7px, 25px));\n      width: 100%;\n      position: absolute;\n      cursor: pointer;\n\n      -webkit-appearance: none; \n      -webkit-tap-highlight-color: transparent;\n      background: transparent; \n      margin: 0;\n      z-index: 1;\n    }\n\n    @media (hover: hover) {\n      #range {\n        bottom: var(--media-time-range-hover-bottom, -5px);\n        height: var(--media-time-range-hover-height, max(100% + 5px, 20px));\n      }\n    }\n\n    \n    \n    #range::-webkit-slider-thumb {\n      -webkit-appearance: none;\n      background: transparent;\n      width: .1px;\n      height: .1px;\n    }\n\n    \n    #range::-moz-range-thumb {\n      background: transparent;\n      border: transparent;\n      width: .1px;\n      height: .1px;\n    }\n\n    #appearance {\n      height: var(--media-range-track-height, 4px);\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      width: 100%;\n      position: absolute;\n      \n      will-change: transform;\n    }\n\n    #background,\n    #track {\n      border-radius: var(--media-range-track-border-radius, 1px);\n      position: absolute;\n      width: 100%;\n      height: 100%;\n    }\n\n    #background {\n      background: var(--media-range-track-background, rgb(255 255 255 / .2));\n      backdrop-filter: var(--media-range-track-background-backdrop-filter);\n      -webkit-backdrop-filter: var(--media-range-track-background-backdrop-filter);\n    }\n\n    #track {\n      border: var(--media-range-track-border, none);\n      outline: var(--media-range-track-outline);\n      outline-offset: var(--media-range-track-outline-offset);\n      backdrop-filter: var(--media-range-track-backdrop-filter);\n      -webkit-backdrop-filter: var(--media-range-track-backdrop-filter);\n      box-shadow: var(--media-range-track-box-shadow, none);\n      overflow: hidden;\n    }\n\n    #progress,\n    #highlight,\n    #pointer {\n      position: absolute;\n      height: 100%;\n      will-change: width;\n    }\n\n    #progress {\n      background: var(--media-range-bar-color, var(--media-primary-color, rgb(238 238 238)));\n      transition: var(--media-range-track-transition);\n    }\n\n    #pointer {\n      background: var(--media-range-track-pointer-background);\n      border-right: var(--media-range-track-pointer-border-right);\n      transition: visibility .25s, opacity .25s;\n      visibility: hidden;\n      opacity: 0;\n    }\n\n    @media (hover: hover) {\n      :host(:hover) #pointer {\n        transition: visibility .5s, opacity .5s;\n        visibility: visible;\n        opacity: 1;\n      }\n    }\n\n    #thumb {\n      width: var(--media-range-thumb-width, 10px);\n      height: var(--media-range-thumb-height, 10px);\n      margin-left: calc(var(--media-range-thumb-width, 10px) / -2);\n      border: var(--media-range-thumb-border, none);\n      border-radius: var(--media-range-thumb-border-radius, 10px);\n      background: var(--media-range-thumb-background, var(--media-primary-color, rgb(238 238 238)));\n      box-shadow: var(--media-range-thumb-box-shadow, 1px 1px 1px transparent);\n      transition: var(--media-range-thumb-transition);\n      transform: var(--media-range-thumb-transform, none);\n      opacity: var(--media-range-thumb-opacity, 1);\n      position: absolute;\n      left: 0;\n      cursor: pointer;\n    }\n\n    :host([disabled]) #thumb {\n      background-color: #777;\n    }\n\n    .segments #appearance {\n      height: var(--media-range-segment-hover-height, 7px);\n    }\n\n    #background,\n    #track {\n      clip-path: url(#segments-clipping);\n    }\n\n    #segments {\n      --segments-gap: var(--media-range-segments-gap, 2px);\n      position: absolute;\n      width: 100%;\n      height: 100%;\n    }\n\n    #segments-clipping {\n      transform: translateX(calc(var(--segments-gap) / 2));\n    }\n\n    #segments-clipping:empty {\n      display: none;\n    }\n\n    #segments-clipping rect {\n      height: var(--media-range-track-height, 4px);\n      y: calc((var(--media-range-segment-hover-height, 7px) - var(--media-range-track-height, 4px)) / 2);\n      transition: var(--media-range-segment-transition, transform .1s ease-in-out);\n      transform: var(--media-range-segment-transform, scaleY(1));\n      transform-origin: center;\n    }\n  </style>\n  <div id="leftgap"></div>\n  <div id="container">\n    <div id="startpoint"></div>\n    <div id="endpoint"></div>\n    <div id="appearance" part="appearance">\n      <div id="background"></div>\n      <div id="track">\n        <div id="highlight"></div>\n        <div id="pointer"></div>\n        <div id="progress"></div>\n      </div>\n      <div id="thumb"></div>\n      <svg id="segments"><clipPath id="segments-clipping"></clipPath></svg>\n    </div>\n    <input id="range" type="range" min="0" max="1" step="any" value="0">\n  </div>\n  <div id="rightgap"></div>\n';
	var cs = class extends z.HTMLElement {
		constructor() {
			super(), ls(this, Vn), ls(this, qn), ls(this, jn), ls(this, Xn), ls(this, Zn), ls(this, es), ls(this, is), ls(this, rs), ls(this, Pn, void 0), ls(this, Nn, void 0), ls(this, Un, void 0), ls(this, Fn, void 0), ls(this, Bn, {}), ls(this, $n, []), ls(this, Hn, (() => {
				if (this.range.matches(":focus-visible")) {
					let {style: e} = he(this.shadowRoot, ":host");
					e.setProperty("--_focus-visible-box-shadow", "var(--_focus-box-shadow)")
				}
			})), ls(this, Wn, (() => {
				let {style: e} = he(this.shadowRoot, ":host");
				e.removeProperty("--_focus-visible-box-shadow")
			})), ls(this, Gn, (() => {
				let e = this.shadowRoot.querySelector("#segments-clipping");
				e && e.parentNode.append(e)
			})), this.shadowRoot || (this.attachShadow({mode: "open"}), this.shadowRoot.appendChild(hs.content.cloneNode(!0))), this.container = this.shadowRoot.querySelector("#container"), ds(this, Un, this.shadowRoot.querySelector("#startpoint")), ds(this, Fn, this.shadowRoot.querySelector("#endpoint")), this.range = this.shadowRoot.querySelector("#range"), this.appearance = this.shadowRoot.querySelector("#appearance")
		}

		static get observedAttributes() {
			return ["disabled", "aria-disabled", f.MEDIA_CONTROLLER]
		}

		get dragging() {
			return this.hasAttribute("dragging")
		}

		get keysUsed() {
			return ["ArrowUp", "ArrowRight", "ArrowDown", "ArrowLeft"]
		}

		attributeChangedCallback(e, t, i) {
			var a, r, n, s, o;
			e === f.MEDIA_CONTROLLER ? (t && (null == (r = null == (a = os(this, Pn)) ? void 0 : a.unassociateElement) || r.call(a, this), ds(this, Pn, null)), i && this.isConnected && (ds(this, Pn, null == (n = this.getRootNode()) ? void 0 : n.getElementById(i)), null == (o = null == (s = os(this, Pn)) ? void 0 : s.associateElement) || o.call(s, this))) : ("disabled" === e || "aria-disabled" === e && t !== i) && (null == i ? (this.range.removeAttribute(e), us(this, qn, Yn).call(this)) : (this.range.setAttribute(e, i), us(this, jn, zn).call(this)))
		}

		connectedCallback() {
			var e, t, i;
			let {style: a} = he(this.shadowRoot, ":host");
			a.setProperty("display", `var(--media-control-display, var(--${this.localName}-display, inline-flex))`), os(this, Bn).pointer = he(this.shadowRoot, "#pointer"), os(this, Bn).progress = he(this.shadowRoot, "#progress"), os(this, Bn).thumb = he(this.shadowRoot, "#thumb");
			let r = this.getAttribute(f.MEDIA_CONTROLLER);
			r && (ds(this, Pn, null == (e = this.getRootNode()) ? void 0 : e.getElementById(r)), null == (i = null == (t = os(this, Pn)) ? void 0 : t.associateElement) || i.call(t, this)), this.updateBar(), this.shadowRoot.addEventListener("focusin", os(this, Hn)), this.shadowRoot.addEventListener("focusout", os(this, Wn)), us(this, qn, Yn).call(this), ee(this.container, os(this, Gn))
		}

		disconnectedCallback() {
			var e, t;
			us(this, jn, zn).call(this), null == (t = null == (e = os(this, Pn)) ? void 0 : e.unassociateElement) || t.call(e, this), ds(this, Pn, null), this.shadowRoot.removeEventListener("focusin", os(this, Hn)), this.shadowRoot.removeEventListener("focusout", os(this, Wn)), te(this.container, os(this, Gn))
		}

		updatePointerBar(e) {
			var t;
			null == (t = os(this, Bn).pointer) || t.style.setProperty("width", 100 * this.getPointerRatio(e) + "%")
		}

		updateBar() {
			var e, t;
			let i = 100 * this.range.valueAsNumber;
			null == (e = os(this, Bn).progress) || e.style.setProperty("width", `${i}%`), null == (t = os(this, Bn).thumb) || t.style.setProperty("left", `${i}%`)
		}

		updateSegments(e) {
			let t = this.shadowRoot.querySelector("#segments-clipping");
			if (t.textContent = "", this.container.classList.toggle("segments", !(null == e || !e.length)), null == e || !e.length) return;
			os(this, Bn).activeSegment = ce(this.shadowRoot, "#segments-clipping rect:nth-child(0)");
			let i = [...new Set([+this.range.min, ...e.flatMap((e => [e.start, e.end])), +this.range.max])];
			ds(this, $n, [...i]);
			let a = i.pop();
			for (let [e, r] of i.entries()) {
				let [n, s] = [0 === e, e === i.length - 1], o = n ? "calc(var(--segments-gap) / -1)" : 100 * r + "%",
					l = `calc(${100 * ((s ? a : i[e + 1]) - r)}%${n || s ? "" : " - var(--segments-gap)"})`,
					d = X.createElementNS("http://www.w3.org/2000/svg", "rect"),
					u = he(this.shadowRoot, `#segments-clipping rect:nth-child(${e + 1})`);
				u.style.setProperty("x", o), u.style.setProperty("width", l), t.append(d)
			}
		}

		getPointerRatio(e) {
			let t = function (e, t, i, a) {
				let r = ue(i, a), n = ue(i, {x: e, y: t}), s = ue(a, {x: e, y: t});
				return n > r || s > r ? n > s ? 1 : 0 : n / r
			}(e.clientX, e.clientY, os(this, Un).getBoundingClientRect(), os(this, Fn).getBoundingClientRect());
			return Math.max(0, Math.min(1, t))
		}

		handleEvent(e) {
			switch (e.type) {
				case"pointermove":
					us(this, rs, ns).call(this, e);
					break;
				case"input":
					this.updateBar();
					break;
				case"pointerenter":
					us(this, Zn, Jn).call(this, e);
					break;
				case"pointerdown":
					us(this, Xn, Qn).call(this, e);
					break;
				case"pointerup":
					us(this, es, ts).call(this);
					break;
				case"pointerleave":
					us(this, is, as).call(this)
			}
		}
	};
	Pn = new WeakMap, Nn = new WeakMap, Un = new WeakMap, Fn = new WeakMap, Bn = new WeakMap, $n = new WeakMap, Hn = new WeakMap, Wn = new WeakMap, Gn = new WeakMap, Vn = new WeakSet, Kn = function (e) {
		let t = os(this, Bn).activeSegment;
		if (!t) return;
		let i = this.getPointerRatio(e), a = `#segments-clipping rect:nth-child(${os(this, $n).findIndex(((e, t, a) => {
			let r = a[t + 1];
			return null != r && i >= e && i <= r
		})) + 1})`;
		(t.selectorText != a || !t.style.transform) && (t.selectorText = a, t.style.setProperty("transform", "var(--media-range-segment-hover-transform, scaleY(2))"))
	}, qn = new WeakSet, Yn = function () {
		this.hasAttribute("disabled") || (this.addEventListener("input", this), this.addEventListener("pointerdown", this), this.addEventListener("pointerenter", this))
	}, jn = new WeakSet, zn = function () {
		var e, t;
		this.removeEventListener("input", this), this.removeEventListener("pointerdown", this), this.removeEventListener("pointerenter", this), null == (e = z.window) || e.removeEventListener("pointerup", this), null == (t = z.window) || t.removeEventListener("pointermove", this)
	}, Xn = new WeakSet, Qn = function (e) {
		var t;
		ds(this, Nn, e.composedPath().includes(this.range)), null == (t = z.window) || t.addEventListener("pointerup", this)
	}, Zn = new WeakSet, Jn = function (e) {
		var t;
		"mouse" !== e.pointerType && us(this, Xn, Qn).call(this, e), this.addEventListener("pointerleave", this), null == (t = z.window) || t.addEventListener("pointermove", this)
	}, es = new WeakSet, ts = function () {
		var e;
		null == (e = z.window) || e.removeEventListener("pointerup", this), this.toggleAttribute("dragging", !1), this.range.disabled = this.hasAttribute("disabled")
	}, is = new WeakSet, as = function () {
		var e, t;
		this.removeEventListener("pointerleave", this), null == (e = z.window) || e.removeEventListener("pointermove", this), this.toggleAttribute("dragging", !1), this.range.disabled = this.hasAttribute("disabled"), null == (t = os(this, Bn).activeSegment) || t.style.removeProperty("transform")
	}, rs = new WeakSet, ns = function (e) {
		this.toggleAttribute("dragging", 1 === e.buttons || "mouse" !== e.pointerType), this.updatePointerBar(e), us(this, Vn, Kn).call(this, e), this.dragging && ("mouse" !== e.pointerType || !os(this, Nn)) && (this.range.disabled = !0, this.range.valueAsNumber = this.getPointerRatio(e), this.range.dispatchEvent(new Event("input", {
			bubbles: !0,
			composed: !0
		})))
	}, z.customElements.get("media-chrome-range") || z.customElements.define("media-chrome-range", cs);
	var ms, fs = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, ps = (e, t, i) => (fs(e, t, "read from private field"), i ? i.call(e) : t.get(e)),
		gs = (e, t, i, a) => (fs(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		vs = X.createElement("template");
	vs.innerHTML = "\n  <style>\n    :host {\n      \n      box-sizing: border-box;\n      display: var(--media-control-display, var(--media-control-bar-display, inline-flex));\n      color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));\n      --media-loading-indicator-icon-height: 44px;\n    }\n\n    ::slotted(media-time-range),\n    ::slotted(media-volume-range) {\n      min-height: 100%;\n    }\n\n    ::slotted(media-time-range),\n    ::slotted(media-clip-selector) {\n      flex-grow: 1;\n    }\n  </style>\n\n  <slot></slot>\n";
	var Es = class extends z.HTMLElement {
		constructor() {
			super(), ((e, t, i) => {
				if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
				t instanceof WeakSet ? t.add(e) : t.set(e, i)
			})(this, ms, void 0), this.shadowRoot || (this.attachShadow({mode: "open"}), this.shadowRoot.appendChild(vs.content.cloneNode(!0)))
		}

		static get observedAttributes() {
			return [f.MEDIA_CONTROLLER]
		}

		attributeChangedCallback(e, t, i) {
			var a, r, n, s, o;
			e === f.MEDIA_CONTROLLER && (t && (null == (r = null == (a = ps(this, ms)) ? void 0 : a.unassociateElement) || r.call(a, this), gs(this, ms, null)), i && this.isConnected && (gs(this, ms, null == (n = this.getRootNode()) ? void 0 : n.getElementById(i)), null == (o = null == (s = ps(this, ms)) ? void 0 : s.associateElement) || o.call(s, this)))
		}

		connectedCallback() {
			var e, t, i;
			let a = this.getAttribute(f.MEDIA_CONTROLLER);
			a && (gs(this, ms, null == (e = this.getRootNode()) ? void 0 : e.getElementById(a)), null == (i = null == (t = ps(this, ms)) ? void 0 : t.associateElement) || i.call(t, this))
		}

		disconnectedCallback() {
			var e, t;
			null == (t = null == (e = ps(this, ms)) ? void 0 : e.unassociateElement) || t.call(e, this), gs(this, ms, null)
		}
	};
	ms = new WeakMap, z.customElements.get("media-control-bar") || z.customElements.define("media-control-bar", Es);
	var bs, ys = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, Ts = (e, t, i) => (ys(e, t, "read from private field"), i ? i.call(e) : t.get(e)),
		As = (e, t, i, a) => (ys(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		_s = X.createElement("template");
	_s.innerHTML = "\n  <style>\n    :host {\n      font: var(--media-font,\n        var(--media-font-weight, normal)\n        var(--media-font-size, 14px) /\n        var(--media-text-content-height, var(--media-control-height, 24px))\n        var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));\n      color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));\n      background: var(--media-text-background, var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7))));\n      padding: var(--media-control-padding, 10px);\n      display: inline-flex;\n      justify-content: center;\n      align-items: center;\n      vertical-align: middle;\n      box-sizing: border-box;\n      text-align: center;\n      pointer-events: auto;\n    }\n\n    \n    :host(:focus-visible) {\n      box-shadow: inset 0 0 0 2px rgb(27 127 204 / .9);\n      outline: 0;\n    }\n\n    \n    :host(:where(:focus)) {\n      box-shadow: none;\n      outline: 0;\n    }\n  </style>\n  <slot></slot>\n";
	var ks = class extends z.HTMLElement {
		constructor() {
			super(), ((e, t, i) => {
				if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
				t instanceof WeakSet ? t.add(e) : t.set(e, i)
			})(this, bs, void 0), this.shadowRoot || (this.attachShadow({mode: "open"}), this.shadowRoot.appendChild(_s.content.cloneNode(!0)))
		}

		static get observedAttributes() {
			return [f.MEDIA_CONTROLLER]
		}

		attributeChangedCallback(e, t, i) {
			var a, r, n, s, o;
			e === f.MEDIA_CONTROLLER && (t && (null == (r = null == (a = Ts(this, bs)) ? void 0 : a.unassociateElement) || r.call(a, this), As(this, bs, null)), i && this.isConnected && (As(this, bs, null == (n = this.getRootNode()) ? void 0 : n.getElementById(i)), null == (o = null == (s = Ts(this, bs)) ? void 0 : s.associateElement) || o.call(s, this)))
		}

		connectedCallback() {
			var e, t, i;
			let {style: a} = he(this.shadowRoot, ":host");
			a.setProperty("display", `var(--media-control-display, var(--${this.localName}-display, inline-flex))`);
			let r = this.getAttribute(f.MEDIA_CONTROLLER);
			r && (As(this, bs, null == (e = this.getRootNode()) ? void 0 : e.getElementById(r)), null == (i = null == (t = Ts(this, bs)) ? void 0 : t.associateElement) || i.call(t, this))
		}

		disconnectedCallback() {
			var e, t;
			null == (t = null == (e = Ts(this, bs)) ? void 0 : e.unassociateElement) || t.call(e, this), As(this, bs, null)
		}
	};
	bs = new WeakMap, z.customElements.get("media-text-display") || z.customElements.define("media-text-display", ks);
	var Ss, ws = ks, Ls = (e, t, i) => {
		if (!t.has(e)) throw TypeError("Cannot " + i)
	}, Rs = (e, t, i) => (Ls(e, t, "read from private field"), i ? i.call(e) : t.get(e));
	Ss = new WeakMap, z.customElements.get("media-duration-display") || z.customElements.define("media-duration-display", class extends ks {
		constructor() {
			super(), ((e, t, i) => {
				if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
				t instanceof WeakSet ? t.add(e) : t.set(e, i)
			})(this, Ss, void 0), ((e, t, i, a) => {
				Ls(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i)
			})(this, Ss, this.shadowRoot.querySelector("slot")), Rs(this, Ss).textContent = W(0)
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_DURATION]
		}

		get mediaDuration() {
			return me(this, v.MEDIA_DURATION)
		}

		set mediaDuration(e) {
			fe(this, v.MEDIA_DURATION, e)
		}

		attributeChangedCallback(e, t, i) {
			e === v.MEDIA_DURATION && (Rs(this, Ss).textContent = W(+i)), super.attributeChangedCallback(e, t, i)
		}
	});
	var Is = X.createElement("template");
	Is.innerHTML = `\n  <style>\n  :host([${v.MEDIA_IS_FULLSCREEN}]) slot:not([name=exit]):not([name=icon]) {\n    display: none !important;\n  }\n\n  \n  :host(:not([${v.MEDIA_IS_FULLSCREEN}])) slot:not([name=enter]):not([name=icon]) {\n    display: none !important;\n  }\n  </style>\n\n  <slot name="icon">\n    <slot name="enter"><svg aria-hidden="true" viewBox="0 0 26 24">\n  <path d="M16 3v2.5h3.5V9H22V3h-6ZM4 9h2.5V5.5H10V3H4v6Zm15.5 9.5H16V21h6v-6h-2.5v3.5ZM6.5 15H4v6h6v-2.5H6.5V15Z"/>\n</svg></slot>\n    <slot name="exit"><svg aria-hidden="true" viewBox="0 0 26 24">\n  <path d="M18.5 6.5V3H16v6h6V6.5h-3.5ZM16 21h2.5v-3.5H22V15h-6v6ZM4 17.5h3.5V21H10v-6H4v2.5Zm3.5-11H4V9h6V3H7.5v3.5Z"/>\n</svg></slot>\n  </slot>\n`;
	var Ds = e => {
		let t = e.mediaIsFullscreen ? D.EXIT_FULLSCREEN() : D.ENTER_FULLSCREEN();
		e.setAttribute("aria-label", t)
	};
	z.customElements.get("media-fullscreen-button") || z.customElements.define("media-fullscreen-button", class extends Ni {
		constructor(e = {}) {
			super({slotTemplate: Is, ...e})
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_IS_FULLSCREEN, v.MEDIA_FULLSCREEN_UNAVAILABLE]
		}

		get mediaFullscreenUnavailable() {
			return ve(this, v.MEDIA_FULLSCREEN_UNAVAILABLE)
		}

		set mediaFullscreenUnavailable(e) {
			Ee(this, v.MEDIA_FULLSCREEN_UNAVAILABLE, e)
		}

		get mediaIsFullscreen() {
			return pe(this, v.MEDIA_IS_FULLSCREEN)
		}

		set mediaIsFullscreen(e) {
			ge(this, v.MEDIA_IS_FULLSCREEN, e)
		}

		connectedCallback() {
			super.connectedCallback(), Ds(this)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_IS_FULLSCREEN && Ds(this)
		}

		handleClick() {
			let e = this.mediaIsFullscreen ? m.MEDIA_EXIT_FULLSCREEN_REQUEST : m.MEDIA_ENTER_FULLSCREEN_REQUEST;
			this.dispatchEvent(new z.CustomEvent(e, {composed: !0, bubbles: !0}))
		}
	});
	var {MEDIA_TIME_IS_LIVE: Cs, MEDIA_PAUSED: xs} = v, {MEDIA_SEEK_TO_LIVE_REQUEST: Ms, MEDIA_PLAY_REQUEST: Os} = m,
		Ps = X.createElement("template");
	Ps.innerHTML = `\n  <style>\n\n  slot[name=indicator] > *,\n  :host ::slotted([slot=indicator]) {\n    \n    min-width: auto;\n    fill: var(--media-live-button-icon-color, rgb(140, 140, 140));\n    color: var(--media-live-button-icon-color, rgb(140, 140, 140));\n  }\n\n  :host([${Cs}]:not([${xs}])) slot[name=indicator] > *,\n  :host([${Cs}]:not([${xs}])) ::slotted([slot=indicator]) {\n    fill: var(--media-live-button-indicator-color, rgb(255, 0, 0));\n    color: var(--media-live-button-indicator-color, rgb(255, 0, 0));\n  }\n\n  :host([${Cs}]:not([${xs}])) {\n    cursor: not-allowed;\n  }\n\n  </style>\n\n  <slot name="indicator"><svg viewBox="0 0 6 12"><circle cx="3" cy="6" r="2"></circle></svg></slot>\n  \n  <slot name="spacer">&nbsp;</slot><slot name="text">LIVE</slot>\n`;
	var Ns = e => {
		let t = e.mediaPaused || !e.mediaTimeIsLive, i = t ? D.SEEK_LIVE() : D.PLAYING_LIVE();
		e.setAttribute("aria-label", i), t ? e.removeAttribute("aria-disabled") : e.setAttribute("aria-disabled", "true")
	};
	z.customElements.get("media-live-button") || z.customElements.define("media-live-button", class extends Ni {
		constructor(e = {}) {
			super({slotTemplate: Ps, ...e})
		}

		static get observedAttributes() {
			return [...super.observedAttributes, xs, Cs]
		}

		get mediaPaused() {
			return pe(this, v.MEDIA_PAUSED)
		}

		set mediaPaused(e) {
			ge(this, v.MEDIA_PAUSED, e)
		}

		get mediaTimeIsLive() {
			return pe(this, v.MEDIA_TIME_IS_LIVE)
		}

		set mediaTimeIsLive(e) {
			ge(this, v.MEDIA_TIME_IS_LIVE, e)
		}

		connectedCallback() {
			Ns(this), super.connectedCallback()
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), Ns(this)
		}

		handleClick() {
			!this.mediaPaused && this.mediaTimeIsLive || (this.dispatchEvent(new z.CustomEvent(Ms, {
				composed: !0,
				bubbles: !0
			})), this.hasAttribute(xs) && this.dispatchEvent(new z.CustomEvent(Os, {composed: !0, bubbles: !0})))
		}
	});
	var Us, Fs, Bs = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, $s = (e, t, i) => (Bs(e, t, "read from private field"), i ? i.call(e) : t.get(e)), Hs = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, Ws = (e, t, i, a) => (Bs(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		Gs = "loadingdelay", Vs = X.createElement("template");
	Vs.innerHTML = `\n<style>\n:host {\n  display: var(--media-control-display, var(--media-loading-indicator-display, inline-block));\n  vertical-align: middle;\n  box-sizing: border-box;\n  --_loading-indicator-delay: var(--media-loading-indicator-transition-delay, 500ms);\n}\n\n#status {\n  color: rgba(0,0,0,0);\n  width: 0px;\n  height: 0px;\n}\n\n:host slot[name=icon] > *,\n:host ::slotted([slot=icon]) {\n  opacity: var(--media-loading-indicator-opacity, 0);\n  transition: opacity 0.15s;\n}\n\n:host([${v.MEDIA_LOADING}]:not([${v.MEDIA_PAUSED}])) slot[name=icon] > *,\n:host([${v.MEDIA_LOADING}]:not([${v.MEDIA_PAUSED}])) ::slotted([slot=icon]) {\n  opacity: var(--media-loading-indicator-opacity, 1);\n  transition: opacity 0.15s var(--_loading-indicator-delay);\n}\n\n:host #status {\n  visibility: var(--media-loading-indicator-opacity, hidden);\n  transition: visibility 0.15s;\n}\n\n:host([${v.MEDIA_LOADING}]:not([${v.MEDIA_PAUSED}])) #status {\n  visibility: var(--media-loading-indicator-opacity, visible);\n  transition: visibility 0.15s var(--_loading-indicator-delay);\n}\n\nsvg, img, ::slotted(svg), ::slotted(img) {\n  width: var(--media-loading-indicator-icon-width);\n  height: var(--media-loading-indicator-icon-height, 100px);\n  fill: var(--media-icon-color, var(--media-primary-color, rgb(238 238 238)));\n  vertical-align: middle;\n}\n</style>\n\n<slot name="icon">\n<svg aria-hidden="true" viewBox="0 0 100 100">\n  <path d="M73,50c0-12.7-10.3-23-23-23S27,37.3,27,50 M30.9,50c0-10.5,8.5-19.1,19.1-19.1S69.1,39.5,69.1,50">\n    <animateTransform\n       attributeName="transform"\n       attributeType="XML"\n       type="rotate"\n       dur="1s"\n       from="0 50 50"\n       to="360 50 50"\n       repeatCount="indefinite" />\n  </path>\n</svg>\n</slot>\n<div id="status" role="status" aria-live="polite">${I.MEDIA_LOADING()}</div>\n`;
	var Ks = class extends z.HTMLElement {
		constructor() {
			if (super(), Hs(this, Us, void 0), Hs(this, Fs, 500), !this.shadowRoot) {
				let e = this.attachShadow({mode: "open"}), t = Vs.content.cloneNode(!0);
				e.appendChild(t)
			}
		}

		static get observedAttributes() {
			return [f.MEDIA_CONTROLLER, v.MEDIA_PAUSED, v.MEDIA_LOADING, Gs]
		}

		get loadingDelay() {
			return $s(this, Fs)
		}

		set loadingDelay(e) {
			Ws(this, Fs, e);
			let {style: t} = he(this.shadowRoot, ":host");
			t.setProperty("--_loading-indicator-delay", `var(--media-loading-indicator-transition-delay, ${e}ms)`)
		}

		get mediaPaused() {
			return pe(this, v.MEDIA_PAUSED)
		}

		set mediaPaused(e) {
			ge(this, v.MEDIA_PAUSED, e)
		}

		get mediaLoading() {
			return pe(this, v.MEDIA_LOADING)
		}

		set mediaLoading(e) {
			ge(this, v.MEDIA_LOADING, e)
		}

		attributeChangedCallback(e, t, i) {
			var a, r, n, s, o;
			e === Gs && t !== i ? this.loadingDelay = Number(i) : e === f.MEDIA_CONTROLLER && (t && (null == (r = null == (a = $s(this, Us)) ? void 0 : a.unassociateElement) || r.call(a, this), Ws(this, Us, null)), i && this.isConnected && (Ws(this, Us, null == (n = this.getRootNode()) ? void 0 : n.getElementById(i)), null == (o = null == (s = $s(this, Us)) ? void 0 : s.associateElement) || o.call(s, this)))
		}

		connectedCallback() {
			var e, t, i;
			let a = this.getAttribute(f.MEDIA_CONTROLLER);
			a && (Ws(this, Us, null == (e = this.getRootNode()) ? void 0 : e.getElementById(a)), null == (i = null == (t = $s(this, Us)) ? void 0 : t.associateElement) || i.call(t, this))
		}

		disconnectedCallback() {
			var e, t;
			null == (t = null == (e = $s(this, Us)) ? void 0 : e.unassociateElement) || t.call(e, this), Ws(this, Us, null)
		}
	};
	Us = new WeakMap, Fs = new WeakMap, z.customElements.get("media-loading-indicator") || z.customElements.define("media-loading-indicator", Ks);
	var {MEDIA_VOLUME_LEVEL: qs} = v,
		Ys = '<svg aria-hidden="true" viewBox="0 0 24 24">\n  <path d="M3 9v6h4l5 5V4L7 9H3Zm13.5 3A4.5 4.5 0 0 0 14 8v8a4.47 4.47 0 0 0 2.5-4Z"/>\n</svg>',
		js = X.createElement("template");
	js.innerHTML = `\n  <style>\n  \n  :host(:not([${qs}])) slot:not([name=high]):not([name=icon]), \n  :host([${qs}=high]) slot:not([name=high]):not([name=icon]) {\n    display: none !important;\n  }\n\n  :host([${qs}=off]) slot:not([name=off]):not([name=icon]) {\n    display: none !important;\n  }\n\n  :host([${qs}=low]) slot:not([name=low]):not([name=icon]) {\n    display: none !important;\n  }\n\n  :host([${qs}=medium]) slot:not([name=medium]):not([name=icon]) {\n    display: none !important;\n  }\n  </style>\n\n  <slot name="icon">\n    <slot name="off"><svg aria-hidden="true" viewBox="0 0 24 24">\n  <path d="M16.5 12A4.5 4.5 0 0 0 14 8v2.18l2.45 2.45a4.22 4.22 0 0 0 .05-.63Zm2.5 0a6.84 6.84 0 0 1-.54 2.64L20 16.15A8.8 8.8 0 0 0 21 12a9 9 0 0 0-7-8.77v2.06A7 7 0 0 1 19 12ZM4.27 3 3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25A6.92 6.92 0 0 1 14 18.7v2.06A9 9 0 0 0 17.69 19l2 2.05L21 19.73l-9-9L4.27 3ZM12 4 9.91 6.09 12 8.18V4Z"/>\n</svg></slot>\n    <slot name="low">${Ys}</slot>\n    <slot name="medium">${Ys}</slot>\n    <slot name="high"><svg aria-hidden="true" viewBox="0 0 24 24">\n  <path d="M3 9v6h4l5 5V4L7 9H3Zm13.5 3A4.5 4.5 0 0 0 14 8v8a4.47 4.47 0 0 0 2.5-4ZM14 3.23v2.06a7 7 0 0 1 0 13.42v2.06a9 9 0 0 0 0-17.54Z"/>\n</svg></slot>\n  </slot>\n`;
	var zs = e => {
		let t = "off" === e.mediaVolumeLevel ? D.UNMUTE() : D.MUTE();
		e.setAttribute("aria-label", t)
	};
	z.customElements.get("media-mute-button") || z.customElements.define("media-mute-button", class extends Ni {
		constructor(e = {}) {
			super({slotTemplate: js, ...e})
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_VOLUME_LEVEL]
		}

		get mediaVolumeLevel() {
			return ve(this, v.MEDIA_VOLUME_LEVEL)
		}

		set mediaVolumeLevel(e) {
			Ee(this, v.MEDIA_VOLUME_LEVEL, e)
		}

		connectedCallback() {
			zs(this), super.connectedCallback()
		}

		attributeChangedCallback(e, t, i) {
			e === v.MEDIA_VOLUME_LEVEL && zs(this), super.attributeChangedCallback(e, t, i)
		}

		handleClick() {
			let e = "off" === this.mediaVolumeLevel ? m.MEDIA_UNMUTE_REQUEST : m.MEDIA_MUTE_REQUEST;
			this.dispatchEvent(new z.CustomEvent(e, {composed: !0, bubbles: !0}))
		}
	});
	var Xs = '<svg aria-hidden="true" viewBox="0 0 28 24">\n  <path d="M24 3H4a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h20a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1Zm-1 16H5V5h18v14Zm-3-8h-7v5h7v-5Z"/>\n</svg>',
		Qs = X.createElement("template");
	Qs.innerHTML = `\n  <style>\n  :host([${v.MEDIA_IS_PIP}]) slot:not([name=exit]):not([name=icon]) {\n    display: none !important;\n  }\n\n  \n  :host(:not([${v.MEDIA_IS_PIP}])) slot:not([name=enter]):not([name=icon]) {\n    display: none !important;\n  }\n  </style>\n\n  <slot name="icon">\n    <slot name="enter">${Xs}</slot>\n    <slot name="exit">${Xs}</slot>\n  </slot>\n`;
	var Zs = e => {
		let t = e.mediaIsPip ? D.EXIT_PIP() : D.ENTER_PIP();
		e.setAttribute("aria-label", t)
	};
	z.customElements.get("media-pip-button") || z.customElements.define("media-pip-button", class extends Ni {
		constructor(e = {}) {
			super({slotTemplate: Qs, ...e})
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_IS_PIP, v.MEDIA_PIP_UNAVAILABLE]
		}

		get mediaPipUnavailable() {
			return ve(this, v.MEDIA_PIP_UNAVAILABLE)
		}

		set mediaPipUnavailable(e) {
			Ee(this, v.MEDIA_PIP_UNAVAILABLE, e)
		}

		get mediaIsPip() {
			return pe(this, v.MEDIA_IS_PIP)
		}

		set mediaIsPip(e) {
			ge(this, v.MEDIA_IS_PIP, e)
		}

		connectedCallback() {
			Zs(this), super.connectedCallback()
		}

		attributeChangedCallback(e, t, i) {
			e === v.MEDIA_IS_PIP && Zs(this), super.attributeChangedCallback(e, t, i)
		}

		handleClick() {
			let e = this.mediaIsPip ? m.MEDIA_EXIT_PIP_REQUEST : m.MEDIA_ENTER_PIP_REQUEST;
			this.dispatchEvent(new z.CustomEvent(e, {composed: !0, bubbles: !0}))
		}
	});
	var Js, eo = (e, t, i) => (((e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		})(e, t, "read from private field"), i ? i.call(e) : t.get(e)), to = "rates", io = [1, 1.2, 1.5, 1.7, 2],
		ao = X.createElement("template");
	ao.innerHTML = '\n  <style>\n    :host {\n      min-width: 5ch;\n      padding: var(--media-button-padding, var(--media-control-padding, 10px 5px));\n    }\n  </style>\n  <slot name="icon"></slot>\n';
	Js = new WeakMap, z.customElements.get("media-playback-rate-button") || z.customElements.define("media-playback-rate-button", class extends Ni {
		constructor(e = {}) {
			super({slotTemplate: ao, ...e}), ((e, t, i) => {
				if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
				t instanceof WeakSet ? t.add(e) : t.set(e, i)
			})(this, Js, new st(this, to, {defaultValue: io})), this.container = this.shadowRoot.querySelector('slot[name="icon"]'), this.container.innerHTML = "1x"
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_PLAYBACK_RATE, to]
		}

		get rates() {
			return eo(this, Js)
		}

		set rates(e) {
			e ? Array.isArray(e) && (eo(this, Js).value = e.join(" ")) : eo(this, Js).value = ""
		}

		get mediaPlaybackRate() {
			return me(this, v.MEDIA_PLAYBACK_RATE, 1)
		}

		set mediaPlaybackRate(e) {
			fe(this, v.MEDIA_PLAYBACK_RATE, e)
		}

		attributeChangedCallback(e, t, i) {
			if (super.attributeChangedCallback(e, t, i), e === to && (eo(this, Js).value = i), e === v.MEDIA_PLAYBACK_RATE) {
				let e = i ? +i : Number.NaN, t = Number.isNaN(e) ? 1 : e;
				this.container.innerHTML = `${t}x`, this.setAttribute("aria-label", I.PLAYBACK_RATE({playbackRate: t}))
			}
		}

		handleClick() {
			var e, t;
			let i = Array.from(this.rates.values(), (e => +e)).sort(((e, t) => e - t)),
				a = null != (t = null != (e = i.find((e => e > this.mediaPlaybackRate))) ? e : i[0]) ? t : 1,
				r = new z.CustomEvent(m.MEDIA_PLAYBACK_RATE_REQUEST, {composed: !0, bubbles: !0, detail: a});
			this.dispatchEvent(r)
		}
	});
	var ro, no, so, oo, lo, uo = (e, t, i) => {
		if (!t.has(e)) throw TypeError("Cannot " + i)
	}, ho = (e, t, i) => (uo(e, t, "read from private field"), i ? i.call(e) : t.get(e)), co = (e, t, i) => {
		if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
		t instanceof WeakSet ? t.add(e) : t.set(e, i)
	}, mo = (e, t, i) => (uo(e, t, "access private method"), i), fo = "rates";
	ro = new WeakMap, no = new WeakSet, so = function () {
		this.defaultSlot.textContent = "";
		for (let e of this.rates) {
			let t = Va({
				type: "radio",
				text: this.formatMenuItemText(`${e}x`, e),
				value: e,
				checked: this.mediaPlaybackRate == e
			});
			t.prepend(Ka(this, "checked-indicator")), this.defaultSlot.append(t)
		}
	}, oo = new WeakSet, lo = function () {
		if (!this.value) return;
		let e = new z.CustomEvent(m.MEDIA_PLAYBACK_RATE_REQUEST, {composed: !0, bubbles: !0, detail: this.value});
		this.dispatchEvent(e)
	}, z.customElements.get("media-playback-rate-menu") || z.customElements.define("media-playback-rate-menu", class extends Za {
		constructor() {
			super(), co(this, no), co(this, oo), co(this, ro, new st(this, fo, {defaultValue: io})), mo(this, no, so).call(this)
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_PLAYBACK_RATE, fo]
		}

		get anchorElement() {
			return "auto" !== this.anchor ? super.anchorElement : ie(this).querySelector("media-playback-rate-menu-button")
		}

		get rates() {
			return ho(this, ro)
		}

		set rates(e) {
			e ? Array.isArray(e) && (ho(this, ro).value = e.join(" ")) : ho(this, ro).value = "", mo(this, no, so).call(this)
		}

		get mediaPlaybackRate() {
			return me(this, v.MEDIA_PLAYBACK_RATE, 1)
		}

		set mediaPlaybackRate(e) {
			fe(this, v.MEDIA_PLAYBACK_RATE, e)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_PLAYBACK_RATE && t != i ? this.value = i : e === fo && t != i && (ho(this, ro).value = i, mo(this, no, so).call(this))
		}

		connectedCallback() {
			super.connectedCallback(), this.addEventListener("change", mo(this, oo, lo))
		}

		disconnectedCallback() {
			super.disconnectedCallback(), this.removeEventListener("change", mo(this, oo, lo))
		}
	});
	var po, go = (e, t, i) => (((e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		})(e, t, "read from private field"), i ? i.call(e) : t.get(e)), vo = "rates", Eo = [1, 1.2, 1.5, 1.7, 2],
		bo = X.createElement("template");
	bo.innerHTML = '\n  <style>\n    :host {\n      min-width: 5ch;\n      padding: var(--media-button-padding, var(--media-control-padding, 10px 5px));\n    }\n  </style>\n  <slot name="icon"></slot>\n';
	po = new WeakMap, z.customElements.get("media-playback-rate-menu-button") || z.customElements.define("media-playback-rate-menu-button", class extends cr {
		constructor(e = {}) {
			super({slotTemplate: bo, ...e}), ((e, t, i) => {
				if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
				t instanceof WeakSet ? t.add(e) : t.set(e, i)
			})(this, po, new st(this, vo, {defaultValue: Eo})), this.container = this.shadowRoot.querySelector('slot[name="icon"]'), this.container.innerHTML = "1x"
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_PLAYBACK_RATE, vo]
		}

		get invokeTargetElement() {
			return null != this.invokeTarget ? super.invokeTargetElement : ie(this).querySelector("media-playback-rate-menu")
		}

		get rates() {
			return go(this, po)
		}

		set rates(e) {
			e ? Array.isArray(e) && (go(this, po).value = e.join(" ")) : go(this, po).value = ""
		}

		get mediaPlaybackRate() {
			return me(this, v.MEDIA_PLAYBACK_RATE, 1)
		}

		set mediaPlaybackRate(e) {
			fe(this, v.MEDIA_PLAYBACK_RATE, e)
		}

		attributeChangedCallback(e, t, i) {
			if (super.attributeChangedCallback(e, t, i), e === vo && (go(this, po).value = i), e === v.MEDIA_PLAYBACK_RATE) {
				let e = i ? +i : Number.NaN, t = Number.isNaN(e) ? 1 : e;
				this.container.innerHTML = `${t}x`, this.setAttribute("aria-label", I.PLAYBACK_RATE({playbackRate: t}))
			}
		}
	});
	var yo = X.createElement("template");
	yo.innerHTML = `\n  <style>\n  :host([${v.MEDIA_PAUSED}]) slot[name=pause] {\n    display: none !important;\n  }\n\n  :host(:not([${v.MEDIA_PAUSED}])) slot[name=play] {\n    display: none !important;\n  }\n  </style>\n\n  <slot name="icon">\n    <slot name="play"><svg aria-hidden="true" viewBox="0 0 24 24">\n  <path d="m6 21 15-9L6 3v18Z"/>\n</svg></slot>\n    <slot name="pause"><svg aria-hidden="true" viewBox="0 0 24 24">\n  <path d="M6 20h4V4H6v16Zm8-16v16h4V4h-4Z"/>\n</svg></slot>\n  </slot>\n`;
	var To = e => {
		let t = e.mediaPaused ? D.PLAY() : D.PAUSE();
		e.setAttribute("aria-label", t)
	};
	z.customElements.get("media-play-button") || z.customElements.define("media-play-button", class extends Ni {
		constructor(e = {}) {
			super({slotTemplate: yo, ...e})
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_PAUSED, v.MEDIA_ENDED]
		}

		get mediaPaused() {
			return pe(this, v.MEDIA_PAUSED)
		}

		set mediaPaused(e) {
			ge(this, v.MEDIA_PAUSED, e)
		}

		connectedCallback() {
			To(this), super.connectedCallback()
		}

		attributeChangedCallback(e, t, i) {
			e === v.MEDIA_PAUSED && To(this), super.attributeChangedCallback(e, t, i)
		}

		handleClick() {
			let e = this.mediaPaused ? m.MEDIA_PLAY_REQUEST : m.MEDIA_PAUSE_REQUEST;
			this.dispatchEvent(new z.CustomEvent(e, {composed: !0, bubbles: !0}))
		}
	});
	var Ao = "placeholdersrc", _o = "src", ko = X.createElement("template");
	ko.innerHTML = '\n  <style>\n    :host {\n      pointer-events: none;\n      display: var(--media-poster-image-display, inline-block);\n      box-sizing: border-box;\n    }\n\n    img {\n      max-width: 100%;\n      max-height: 100%;\n      min-width: 100%;\n      min-height: 100%;\n      background-repeat: no-repeat;\n      background-position: var(--media-poster-image-background-position, var(--media-object-position, center));\n      background-size: var(--media-poster-image-background-size, var(--media-object-fit, contain));\n      object-fit: var(--media-object-fit, contain);\n      object-position: var(--media-object-position, center);\n    }\n  </style>\n\n  <img part="poster img" aria-hidden="true" id="image"/>\n';
	var So = class extends z.HTMLElement {
		constructor() {
			super(), this.shadowRoot || (this.attachShadow({mode: "open"}), this.shadowRoot.appendChild(ko.content.cloneNode(!0))), this.image = this.shadowRoot.querySelector("#image")
		}

		static get observedAttributes() {
			return [Ao, _o]
		}

		get placeholderSrc() {
			return ve(this, Ao)
		}

		set placeholderSrc(e) {
			Ee(this, _o, e)
		}

		get src() {
			return ve(this, _o)
		}

		set src(e) {
			Ee(this, _o, e)
		}

		attributeChangedCallback(e, t, i) {
			e === _o && (null == i ? this.image.removeAttribute(_o) : this.image.setAttribute(_o, i)), e === Ao && (null == i ? (e => {
				e.style.removeProperty("background-image")
			})(this.image) : ((e, t) => {
				e.style["background-image"] = `url('${t}')`
			})(this.image, i))
		}
	};
	z.customElements.get("media-poster-image") || z.customElements.define("media-poster-image", So);
	var wo, Lo = (e, t, i) => {
		if (!t.has(e)) throw TypeError("Cannot " + i)
	};
	wo = new WeakMap, z.customElements.get("media-preview-chapter-display") || z.customElements.define("media-preview-chapter-display", class extends ws {
		constructor() {
			super(), ((e, t, i) => {
				if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
				t instanceof WeakSet ? t.add(e) : t.set(e, i)
			})(this, wo, void 0), ((e, t, i, a) => {
				Lo(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i)
			})(this, wo, this.shadowRoot.querySelector("slot"))
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_PREVIEW_CHAPTER]
		}

		get mediaPreviewChapter() {
			return ve(this, v.MEDIA_PREVIEW_CHAPTER)
		}

		set mediaPreviewChapter(e) {
			Ee(this, v.MEDIA_PREVIEW_CHAPTER, e)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_PREVIEW_CHAPTER && i !== t && null != i && (((e, t, i) => (Lo(e, t, "read from private field"), i ? i.call(e) : t.get(e)))(this, wo).textContent = i, "" !== i ? this.setAttribute("aria-valuetext", `chapter: ${i}`) : this.removeAttribute("aria-valuetext"))
		}
	});
	var Ro, Io = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, Do = (e, t, i) => (Io(e, t, "read from private field"), i ? i.call(e) : t.get(e)),
		Co = (e, t, i, a) => (Io(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		xo = X.createElement("template");
	xo.innerHTML = '\n  <style>\n    :host {\n      box-sizing: border-box;\n      display: var(--media-control-display, var(--media-preview-thumbnail-display, inline-block));\n      overflow: hidden;\n    }\n\n    img {\n      display: none;\n      position: relative;\n    }\n  </style>\n  <img crossorigin loading="eager" decoding="async">\n';
	var Mo = class extends z.HTMLElement {
		constructor() {
			super(), ((e, t, i) => {
				if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
				t instanceof WeakSet ? t.add(e) : t.set(e, i)
			})(this, Ro, void 0), this.shadowRoot || (this.attachShadow({mode: "open"}), this.shadowRoot.appendChild(xo.content.cloneNode(!0)))
		}

		static get observedAttributes() {
			return [f.MEDIA_CONTROLLER, v.MEDIA_PREVIEW_IMAGE, v.MEDIA_PREVIEW_COORDS]
		}

		get mediaPreviewImage() {
			return ve(this, v.MEDIA_PREVIEW_IMAGE)
		}

		set mediaPreviewImage(e) {
			Ee(this, v.MEDIA_PREVIEW_IMAGE, e)
		}

		get mediaPreviewCoords() {
			let e = this.getAttribute(v.MEDIA_PREVIEW_COORDS);
			if (e) return e.split(/\s+/).map((e => +e))
		}

		set mediaPreviewCoords(e) {
			e ? this.setAttribute(v.MEDIA_PREVIEW_COORDS, e.join(" ")) : this.removeAttribute(v.MEDIA_PREVIEW_COORDS)
		}

		connectedCallback() {
			var e, t, i;
			let a = this.getAttribute(f.MEDIA_CONTROLLER);
			a && (Co(this, Ro, null == (e = this.getRootNode()) ? void 0 : e.getElementById(a)), null == (i = null == (t = Do(this, Ro)) ? void 0 : t.associateElement) || i.call(t, this))
		}

		disconnectedCallback() {
			var e, t;
			null == (t = null == (e = Do(this, Ro)) ? void 0 : e.unassociateElement) || t.call(e, this), Co(this, Ro, null)
		}

		attributeChangedCallback(e, t, i) {
			var a, r, n, s, o;
			[v.MEDIA_PREVIEW_IMAGE, v.MEDIA_PREVIEW_COORDS].includes(e) && this.update(), e === f.MEDIA_CONTROLLER && (t && (null == (r = null == (a = Do(this, Ro)) ? void 0 : a.unassociateElement) || r.call(a, this), Co(this, Ro, null)), i && this.isConnected && (Co(this, Ro, null == (n = this.getRootNode()) ? void 0 : n.getElementById(i)), null == (o = null == (s = Do(this, Ro)) ? void 0 : s.associateElement) || o.call(s, this)))
		}

		update() {
			let e = this.mediaPreviewCoords, t = this.mediaPreviewImage;
			if (!e || !t) return;
			let [i, a, r, n] = e, s = t.split("#")[0], o = getComputedStyle(this), {
					maxWidth: l,
					maxHeight: d,
					minWidth: u,
					minHeight: h
				} = o, c = Math.min(parseInt(l) / r, parseInt(d) / n), m = Math.max(parseInt(u) / r, parseInt(h) / n),
				f = c < 1, p = f ? c : m > 1 ? m : 1, {style: g} = he(this.shadowRoot, ":host"),
				v = he(this.shadowRoot, "img").style, E = this.shadowRoot.querySelector("img"), b = f ? "min" : "max";
			g.setProperty(`${b}-width`, "initial", "important"), g.setProperty(`${b}-height`, "initial", "important"), g.width = r * p + "px", g.height = n * p + "px";
			let y = () => {
				v.width = this.imgWidth * p + "px", v.height = this.imgHeight * p + "px", v.display = "block"
			};
			E.src !== s && (E.onload = () => {
				this.imgWidth = E.naturalWidth, this.imgHeight = E.naturalHeight, y()
			}, E.src = s, y()), y(), v.transform = `translate(-${i * p}px, -${a * p}px)`
		}
	};
	Ro = new WeakMap, z.customElements.get("media-preview-thumbnail") || z.customElements.define("media-preview-thumbnail", Mo);
	var Oo, Po = (e, t, i) => {
		if (!t.has(e)) throw TypeError("Cannot " + i)
	}, No = (e, t, i) => (Po(e, t, "read from private field"), i ? i.call(e) : t.get(e));
	Oo = new WeakMap, z.customElements.get("media-preview-time-display") || z.customElements.define("media-preview-time-display", class extends ks {
		constructor() {
			super(), ((e, t, i) => {
				if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
				t instanceof WeakSet ? t.add(e) : t.set(e, i)
			})(this, Oo, void 0), ((e, t, i, a) => {
				Po(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i)
			})(this, Oo, this.shadowRoot.querySelector("slot")), No(this, Oo).textContent = W(0)
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_PREVIEW_TIME]
		}

		get mediaPreviewTime() {
			return me(this, v.MEDIA_PREVIEW_TIME)
		}

		set mediaPreviewTime(e) {
			fe(this, v.MEDIA_PREVIEW_TIME, e)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_PREVIEW_TIME && null != i && (No(this, Oo).textContent = W(i))
		}
	});
	var Uo, Fo, Bo, $o, Ho, Wo, Go = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, Vo = (e, t, i) => (Go(e, t, "read from private field"), i ? i.call(e) : t.get(e)), Ko = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, qo = (e, t, i, a) => (Go(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		Yo = (e, t, i) => (Go(e, t, "access private method"), i);
	Uo = new WeakMap, Fo = new WeakMap, Bo = new WeakSet, $o = function () {
		if (Vo(this, Fo) === JSON.stringify(this.mediaRenditionList)) return;
		qo(this, Fo, JSON.stringify(this.mediaRenditionList));
		let e = this.mediaRenditionList.sort(((e, t) => t.height - e.height));
		this.defaultSlot.textContent = "";
		let t = !this.mediaRenditionSelected;
		for (let i of e) {
			let e = Va({
				type: "radio",
				text: this.formatMenuItemText(`${Math.min(i.width, i.height)}p`, i),
				value: `${i.id}`,
				checked: i.selected && !t
			});
			e.prepend(Ka(this, "checked-indicator")), this.defaultSlot.append(e)
		}
		let i = Va({type: "radio", text: this.formatMenuItemText("Auto"), value: "auto", checked: t});
		i.prepend(Ka(this, "checked-indicator")), this.defaultSlot.append(i)
	}, Ho = new WeakSet, Wo = function () {
		if (null == this.value) return;
		let e = new z.CustomEvent(m.MEDIA_RENDITION_REQUEST, {composed: !0, bubbles: !0, detail: this.value});
		this.dispatchEvent(e)
	}, z.customElements.get("media-rendition-menu") || z.customElements.define("media-rendition-menu", class extends Za {
		constructor() {
			super(...arguments), Ko(this, Bo), Ko(this, Ho), Ko(this, Uo, []), Ko(this, Fo, void 0)
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_RENDITION_LIST, v.MEDIA_RENDITION_SELECTED, v.MEDIA_RENDITION_UNAVAILABLE]
		}

		get anchorElement() {
			return "auto" !== this.anchor ? super.anchorElement : ie(this).querySelector("media-rendition-menu-button")
		}

		get mediaRenditionList() {
			return Vo(this, Uo)
		}

		set mediaRenditionList(e) {
			qo(this, Uo, e), Yo(this, Bo, $o).call(this)
		}

		get mediaRenditionSelected() {
			return ve(this, v.MEDIA_RENDITION_SELECTED)
		}

		set mediaRenditionSelected(e) {
			Ee(this, v.MEDIA_RENDITION_SELECTED, e)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_RENDITION_SELECTED && t !== i ? this.value = null != i ? i : "auto" : e === v.MEDIA_RENDITION_LIST && t !== i && (qo(this, Uo, C(i)), Yo(this, Bo, $o).call(this))
		}

		connectedCallback() {
			super.connectedCallback(), this.addEventListener("change", Yo(this, Ho, Wo))
		}

		disconnectedCallback() {
			super.disconnectedCallback(), this.removeEventListener("change", Yo(this, Ho, Wo))
		}
	});
	var jo = X.createElement("template");
	jo.innerHTML = '\n  <slot name="icon"><svg aria-hidden="true" viewBox="0 0 24 24">\n  <path d="M13.5 2.5h2v6h-2v-2h-11v-2h11v-2Zm4 2h4v2h-4v-2Zm-12 4h2v6h-2v-2h-3v-2h3v-2Zm4 2h12v2h-12v-2Zm1 4h2v6h-2v-2h-8v-2h8v-2Zm4 2h7v2h-7v-2Z" />\n</svg></slot>\n';
	z.customElements.get("media-rendition-menu-button") || z.customElements.define("media-rendition-menu-button", class extends cr {
		constructor() {
			super({slotTemplate: jo})
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_RENDITION_SELECTED, v.MEDIA_RENDITION_UNAVAILABLE]
		}

		get invokeTargetElement() {
			return null != this.invokeTarget ? super.invokeTargetElement : ie(this).querySelector("media-rendition-menu")
		}

		get mediaRenditionSelected() {
			return ve(this, v.MEDIA_RENDITION_SELECTED)
		}

		set mediaRenditionSelected(e) {
			Ee(this, v.MEDIA_RENDITION_SELECTED, e)
		}

		connectedCallback() {
			super.connectedCallback(), this.setAttribute("aria-label", I.QUALITY())
		}
	});
	var zo = "seekoffset", Xo = X.createElement("template");
	Xo.innerHTML = '\n  <slot name="icon"><svg aria-hidden="true" viewBox="0 0 20 24"><defs><style>.text{font-size:8px;font-family:Arial-BoldMT, Arial;font-weight:700;}</style></defs><text class="text value" transform="translate(2.18 19.87)">30</text><path d="M10 6V3L4.37 7 10 10.94V8a5.54 5.54 0 0 1 1.9 10.48v2.12A7.5 7.5 0 0 0 10 6Z"/></svg></slot>\n';
	z.customElements.get("media-seek-backward-button") || z.customElements.define("media-seek-backward-button", class extends Ni {
		constructor(e = {}) {
			super({slotTemplate: Xo, ...e})
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_CURRENT_TIME, zo]
		}

		get seekOffset() {
			return me(this, zo, 30)
		}

		set seekOffset(e) {
			fe(this, zo, e), this.setAttribute("aria-label", D.SEEK_BACK_N_SECS({seekOffset: this.seekOffset})), re(ne(this, "icon"), this.seekOffset)
		}

		get mediaCurrentTime() {
			return me(this, v.MEDIA_CURRENT_TIME, 0)
		}

		set mediaCurrentTime(e) {
			fe(this, v.MEDIA_CURRENT_TIME, e)
		}

		connectedCallback() {
			this.seekOffset = me(this, zo, 30), super.connectedCallback()
		}

		attributeChangedCallback(e, t, i) {
			e === zo && (this.seekOffset = me(this, zo, 30)), super.attributeChangedCallback(e, t, i)
		}

		handleClick() {
			let e = Math.max(this.mediaCurrentTime - this.seekOffset, 0),
				t = new z.CustomEvent(m.MEDIA_SEEK_REQUEST, {composed: !0, bubbles: !0, detail: e});
			this.dispatchEvent(t)
		}
	});
	var Qo = "seekoffset", Zo = X.createElement("template");
	Zo.innerHTML = '\n  <slot name="icon"><svg aria-hidden="true" viewBox="0 0 20 24"><defs><style>.text{font-size:8px;font-family:Arial-BoldMT, Arial;font-weight:700;}</style></defs><text class="text value" transform="translate(8.9 19.87)">30</text><path d="M10 6V3l5.61 4L10 10.94V8a5.54 5.54 0 0 0-1.9 10.48v2.12A7.5 7.5 0 0 1 10 6Z"/></svg></slot>\n';
	z.customElements.get("media-seek-forward-button") || z.customElements.define("media-seek-forward-button", class extends Ni {
		constructor(e = {}) {
			super({slotTemplate: Zo, ...e})
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_CURRENT_TIME, Qo]
		}

		get seekOffset() {
			return me(this, Qo, 30)
		}

		set seekOffset(e) {
			fe(this, Qo, e), this.setAttribute("aria-label", D.SEEK_FORWARD_N_SECS({seekOffset: this.seekOffset})), re(ne(this, "icon"), this.seekOffset)
		}

		get mediaCurrentTime() {
			return me(this, v.MEDIA_CURRENT_TIME, 0)
		}

		set mediaCurrentTime(e) {
			fe(this, v.MEDIA_CURRENT_TIME, e)
		}

		connectedCallback() {
			this.seekOffset = me(this, Qo, 30), super.connectedCallback()
		}

		attributeChangedCallback(e, t, i) {
			e === Qo && (this.seekOffset = me(this, Qo, 30)), super.attributeChangedCallback(e, t, i)
		}

		handleClick() {
			let e = this.mediaCurrentTime + this.seekOffset,
				t = new z.CustomEvent(m.MEDIA_SEEK_REQUEST, {composed: !0, bubbles: !0, detail: e});
			this.dispatchEvent(t)
		}
	});
	var Jo = Object.defineProperty, el = X.createElement("template");
	el.innerHTML = Za.template.innerHTML + '\n  <style>\n    :host {\n      background: var(--media-settings-menu-background,\n        var(--media-menu-background,\n        var(--media-control-background,\n        var(--media-secondary-color, rgb(20 20 30 / .8)))));\n      min-width: var(--media-settings-menu-min-width, 160px);\n      border-radius: 2px 2px 0 0;\n      overflow: hidden;\n    }\n\n    :host([role="menu"]) {\n      \n      justify-content: end;\n    }\n\n    slot:not([name]) {\n      justify-content: var(--media-settings-menu-justify-content);\n      flex-direction: var(--media-settings-menu-flex-direction, column);\n      overflow: visible;\n    }\n\n    #container.has-expanded {\n      --media-settings-menu-item-opacity: 0;\n    }\n  </style>\n';
	var tl = class extends Za {
		get anchorElement() {
			return "auto" !== this.anchor ? super.anchorElement : ie(this).querySelector("media-settings-menu-button")
		}
	};
	((e, t, i) => {
		((e, t, i) => {
			t in e ? Jo(e, t, {enumerable: !0, configurable: !0, writable: !0, value: i}) : e[t] = i
		})(e, "symbol" != typeof t ? t + "" : t, i)
	})(tl, "template", el), z.customElements.get("media-settings-menu") || z.customElements.define("media-settings-menu", tl);
	var il = X.createElement("template");
	il.innerHTML = '\n  <slot name="icon">\n    <svg aria-hidden="true" viewBox="0 0 24 24">\n      <path d="M4.5 14.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Zm7.5 0a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Zm7.5 0a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z"/>\n    </svg>\n  </slot>\n';
	z.customElements.get("media-settings-menu-button") || z.customElements.define("media-settings-menu-button", class extends cr {
		constructor() {
			super({slotTemplate: il})
		}

		static get observedAttributes() {
			return [...super.observedAttributes, "target"]
		}

		get invokeTargetElement() {
			return null != this.invokeTarget ? super.invokeTargetElement : ie(this).querySelector("media-settings-menu")
		}

		connectedCallback() {
			super.connectedCallback(), this.setAttribute("aria-label", I.SETTINGS())
		}
	});
	var al, rl = Object.defineProperty, nl = X.createElement("template");
	nl.innerHTML = xn.template.innerHTML + '\n  <style>\n    slot:not([name="submenu"]) {\n      opacity: var(--media-settings-menu-item-opacity, var(--media-menu-item-opacity));\n    }\n\n    :host([aria-expanded="true"]:hover) {\n      background: transparent;\n    }\n  </style>\n', null != (al = nl.content) && al.querySelector && (nl.content.querySelector('slot[name="suffix"]').innerHTML = '\n    <svg aria-hidden="true" viewBox="0 0 20 24">\n      <path d="m8.12 17.585-.742-.669 4.2-4.665-4.2-4.666.743-.669 4.803 5.335-4.803 5.334Z"/>\n    </svg>\n  ');
	var sl = class extends xn {
	};
	((e, t, i) => {
		((e, t, i) => {
			t in e ? rl(e, t, {enumerable: !0, configurable: !0, writable: !0, value: i}) : e[t] = i
		})(e, "symbol" != typeof t ? t + "" : t, i)
	})(sl, "template", nl), z.customElements.get("media-settings-menu-item") || z.customElements.define("media-settings-menu-item", sl);
	var ol, ll = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, dl = (e, t, i) => (ll(e, t, "read from private field"), i ? i.call(e) : t.get(e)),
		ul = {REMAINING: "remaining", SHOW_DURATION: "showduration", NO_TOGGLE: "notoggle"},
		hl = [...Object.values(ul), v.MEDIA_CURRENT_TIME, v.MEDIA_DURATION, v.MEDIA_SEEKABLE], cl = ["Enter", " "],
		ml = (e, {timesSep: t = "&nbsp;/&nbsp;"} = {}) => {
			var i, a;
			let r = e.hasAttribute(ul.REMAINING), n = e.hasAttribute(ul.SHOW_DURATION),
				s = null != (i = e.mediaCurrentTime) ? i : 0, [, o] = null != (a = e.mediaSeekable) ? a : [], l = 0;
			Number.isFinite(e.mediaDuration) ? l = e.mediaDuration : Number.isFinite(o) && (l = o);
			let d = W(r ? 0 - (l - s) : s);
			return n ? `${d}${t}${W(l)}` : d
		};
	ol = new WeakMap, z.customElements.get("media-time-display") || z.customElements.define("media-time-display", class extends ks {
		constructor() {
			super(), ((e, t, i) => {
				if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
				t instanceof WeakSet ? t.add(e) : t.set(e, i)
			})(this, ol, void 0), ((e, t, i, a) => {
				ll(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i)
			})(this, ol, this.shadowRoot.querySelector("slot")), dl(this, ol).innerHTML = `${ml(this)}`
		}

		static get observedAttributes() {
			return [...super.observedAttributes, ...hl, "disabled"]
		}

		get remaining() {
			return pe(this, ul.REMAINING)
		}

		set remaining(e) {
			ge(this, ul.REMAINING, e)
		}

		get showDuration() {
			return pe(this, ul.SHOW_DURATION)
		}

		set showDuration(e) {
			ge(this, ul.SHOW_DURATION, e)
		}

		get noToggle() {
			return pe(this, ul.NO_TOGGLE)
		}

		set noToggle(e) {
			ge(this, ul.NO_TOGGLE, e)
		}

		get mediaDuration() {
			return me(this, v.MEDIA_DURATION)
		}

		set mediaDuration(e) {
			fe(this, v.MEDIA_DURATION, e)
		}

		get mediaCurrentTime() {
			return me(this, v.MEDIA_CURRENT_TIME)
		}

		set mediaCurrentTime(e) {
			fe(this, v.MEDIA_CURRENT_TIME, e)
		}

		get mediaSeekable() {
			let e = this.getAttribute(v.MEDIA_SEEKABLE);
			if (e) return e.split(":").map((e => +e))
		}

		set mediaSeekable(e) {
			null != e ? this.setAttribute(v.MEDIA_SEEKABLE, e.join(":")) : this.removeAttribute(v.MEDIA_SEEKABLE)
		}

		connectedCallback() {
			let {style: e} = he(this.shadowRoot, ":host(:hover:not([notoggle]))");
			e.setProperty("cursor", "pointer"), e.setProperty("background", "var(--media-control-hover-background, rgba(50 50 70 / .7))"), this.hasAttribute("disabled") || this.enable(), this.setAttribute("role", "progressbar"), this.setAttribute("aria-label", I.PLAYBACK_TIME());
			let t = e => {
				let {key: i} = e;
				cl.includes(i) ? this.toggleTimeDisplay() : this.removeEventListener("keyup", t)
			};
			this.addEventListener("keydown", (e => {
				let {metaKey: i, altKey: a, key: r} = e;
				i || a || !cl.includes(r) ? this.removeEventListener("keyup", t) : this.addEventListener("keyup", t)
			})), this.addEventListener("click", this.toggleTimeDisplay), super.connectedCallback()
		}

		toggleTimeDisplay() {
			this.noToggle || (this.hasAttribute("remaining") ? this.removeAttribute("remaining") : this.setAttribute("remaining", ""))
		}

		disconnectedCallback() {
			this.disable(), super.disconnectedCallback()
		}

		attributeChangedCallback(e, t, i) {
			hl.includes(e) ? this.update() : "disabled" === e && i !== t && (null == i ? this.enable() : this.disable()), super.attributeChangedCallback(e, t, i)
		}

		enable() {
			this.tabIndex = 0
		}

		disable() {
			this.tabIndex = -1
		}

		update() {
			let e = ml(this);
			(e => {
				var t;
				let i = e.mediaCurrentTime, [, a] = null != (t = e.mediaSeekable) ? t : [], r = null;
				if (Number.isFinite(e.mediaDuration) ? r = e.mediaDuration : Number.isFinite(a) && (r = a), null == i || null === r) return void e.setAttribute("aria-valuetext", "video not loaded, unknown time.");
				let n = e.hasAttribute(ul.REMAINING), s = e.hasAttribute(ul.SHOW_DURATION), o = H(n ? 0 - (r - i) : i);
				if (!s) return void e.setAttribute("aria-valuetext", o);
				let l = `${o} of ${H(r)}`;
				e.setAttribute("aria-valuetext", l)
			})(this), e !== dl(this, ol).innerHTML && (dl(this, ol).innerHTML = e)
		}
	});
	var fl, pl, gl, vl, El, bl, yl, Tl, Al, _l, kl = (e, t, i) => {
		if (!t.has(e)) throw TypeError("Cannot " + i)
	}, Sl = (e, t, i) => (kl(e, t, "read from private field"), i ? i.call(e) : t.get(e)), wl = (e, t, i) => {
		if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
		t instanceof WeakSet ? t.add(e) : t.set(e, i)
	}, Ll = (e, t, i, a) => (kl(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i);
	fl = new WeakMap, pl = new WeakMap, gl = new WeakMap, vl = new WeakMap, El = new WeakMap, bl = new WeakMap, yl = new WeakMap, Tl = new WeakMap, Al = new WeakMap, _l = new WeakMap;
	var Rl, Il, Dl, Cl, xl, Ml, Ol, Pl, Nl, Ul, Fl, Bl, $l, Hl, Wl, Gl, Vl, Kl, ql, Yl, jl, zl, Xl, Ql, Zl, Jl,
		ed = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, td = (e, t, i) => (ed(e, t, "read from private field"), i ? i.call(e) : t.get(e)), id = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, ad = (e, t, i, a) => (ed(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		rd = (e, t, i) => (ed(e, t, "access private method"), i), nd = X.createElement("template");
	nd.innerHTML = `\n  <style>\n    :host {\n      --media-box-border-radius: 4px;\n      --media-box-padding-left: 10px;\n      --media-box-padding-right: 10px;\n      --media-preview-border-radius: var(--media-box-border-radius);\n      --media-box-arrow-offset: var(--media-box-border-radius);\n      --_control-background: var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7)));\n      --_preview-background: var(--media-preview-background, var(--_control-background));\n\n      \n      contain: layout;\n    }\n\n    #highlight {\n      background: var(--media-time-range-buffered-color, rgb(255 255 255 / .4));\n    }\n\n    #preview-rail,\n    #current-rail {\n      width: 100%;\n      position: absolute;\n      left: 0;\n      bottom: 100%;\n      pointer-events: none;\n      will-change: transform;\n    }\n\n    [part~="box"] {\n      width: min-content;\n      \n      position: absolute;\n      bottom: 100%;\n      flex-direction: column;\n      align-items: center;\n      transform: translateX(-50%);\n    }\n\n    [part~="current-box"] {\n      display: var(--media-current-box-display, var(--media-box-display, flex));\n      margin: var(--media-current-box-margin, var(--media-box-margin, 0 0 5px));\n      visibility: hidden;\n    }\n\n    [part~="preview-box"] {\n      display: var(--media-preview-box-display, var(--media-box-display, flex));\n      margin: var(--media-preview-box-margin, var(--media-box-margin, 0 0 5px));\n      transition-property: var(--media-preview-transition-property, visibility, opacity);\n      transition-duration: var(--media-preview-transition-duration-out, .25s);\n      transition-delay: var(--media-preview-transition-delay-out, 0s);\n      visibility: hidden;\n      opacity: 0;\n    }\n\n    :host(:is([${v.MEDIA_PREVIEW_IMAGE}], [${v.MEDIA_PREVIEW_TIME}])[dragging]) [part~="preview-box"] {\n      transition-duration: var(--media-preview-transition-duration-in, .5s);\n      transition-delay: var(--media-preview-transition-delay-in, .25s);\n      visibility: visible;\n      opacity: 1;\n    }\n\n    @media (hover: hover) {\n      :host(:is([${v.MEDIA_PREVIEW_IMAGE}], [${v.MEDIA_PREVIEW_TIME}]):hover) [part~="preview-box"] {\n        transition-duration: var(--media-preview-transition-duration-in, .5s);\n        transition-delay: var(--media-preview-transition-delay-in, .25s);\n        visibility: visible;\n        opacity: 1;\n      }\n    }\n\n    media-preview-thumbnail,\n    ::slotted(media-preview-thumbnail) {\n      visibility: hidden;\n      \n      transition: visibility 0s .25s;\n      transition-delay: calc(var(--media-preview-transition-delay-out, 0s) + var(--media-preview-transition-duration-out, .25s));\n      background: var(--media-preview-thumbnail-background, var(--_preview-background));\n      box-shadow: var(--media-preview-thumbnail-box-shadow, 0 0 4px rgb(0 0 0 / .2));\n      max-width: var(--media-preview-thumbnail-max-width, 180px);\n      max-height: var(--media-preview-thumbnail-max-height, 160px);\n      min-width: var(--media-preview-thumbnail-min-width, 120px);\n      min-height: var(--media-preview-thumbnail-min-height, 80px);\n      border: var(--media-preview-thumbnail-border);\n      border-radius: var(--media-preview-thumbnail-border-radius,\n        var(--media-preview-border-radius) var(--media-preview-border-radius) 0 0);\n    }\n\n    :host([${v.MEDIA_PREVIEW_IMAGE}][dragging]) media-preview-thumbnail,\n    :host([${v.MEDIA_PREVIEW_IMAGE}][dragging]) ::slotted(media-preview-thumbnail) {\n      transition-delay: var(--media-preview-transition-delay-in, .25s);\n      visibility: visible;\n    }\n\n    @media (hover: hover) {\n      :host([${v.MEDIA_PREVIEW_IMAGE}]:hover) media-preview-thumbnail,\n      :host([${v.MEDIA_PREVIEW_IMAGE}]:hover) ::slotted(media-preview-thumbnail) {\n        transition-delay: var(--media-preview-transition-delay-in, .25s);\n        visibility: visible;\n      }\n\n      :host([${v.MEDIA_PREVIEW_TIME}]:hover) {\n        --media-time-range-hover-display: block;\n      }\n    }\n\n    media-preview-chapter-display,\n    ::slotted(media-preview-chapter-display) {\n      font-size: var(--media-font-size, 13px);\n      line-height: 17px;\n      min-width: 0;\n      visibility: hidden;\n      \n      transition: min-width 0s, border-radius 0s, margin 0s, padding 0s, visibility 0s;\n      transition-delay: calc(var(--media-preview-transition-delay-out, 0s) + var(--media-preview-transition-duration-out, .25s));\n      background: var(--media-preview-chapter-background, var(--_preview-background));\n      border-radius: var(--media-preview-chapter-border-radius,\n        var(--media-preview-border-radius) var(--media-preview-border-radius)\n        var(--media-preview-border-radius) var(--media-preview-border-radius));\n      padding: var(--media-preview-chapter-padding, 3.5px 9px);\n      margin: var(--media-preview-chapter-margin, 0 0 5px);\n      text-shadow: var(--media-preview-chapter-text-shadow, 0 0 4px rgb(0 0 0 / .75));\n    }\n\n    :host([${v.MEDIA_PREVIEW_IMAGE}]) media-preview-chapter-display,\n    :host([${v.MEDIA_PREVIEW_IMAGE}]) ::slotted(media-preview-chapter-display) {\n      transition-delay: var(--media-preview-transition-delay-in, .25s);\n      border-radius: var(--media-preview-chapter-border-radius, 0);\n      padding: var(--media-preview-chapter-padding, 3.5px 9px 0);\n      margin: var(--media-preview-chapter-margin, 0);\n      min-width: 100%;\n    }\n\n    media-preview-chapter-display[${v.MEDIA_PREVIEW_CHAPTER}],\n    ::slotted(media-preview-chapter-display[${v.MEDIA_PREVIEW_CHAPTER}]) {\n      visibility: visible;\n    }\n\n    media-preview-chapter-display:not([aria-valuetext]),\n    ::slotted(media-preview-chapter-display:not([aria-valuetext])) {\n      display: none;\n    }\n\n    media-preview-time-display,\n    ::slotted(media-preview-time-display),\n    media-time-display,\n    ::slotted(media-time-display) {\n      font-size: var(--media-font-size, 13px);\n      line-height: 17px;\n      min-width: 0;\n      \n      transition: min-width 0s, border-radius 0s;\n      transition-delay: calc(var(--media-preview-transition-delay-out, 0s) + var(--media-preview-transition-duration-out, .25s));\n      background: var(--media-preview-time-background, var(--_preview-background));\n      border-radius: var(--media-preview-time-border-radius,\n        var(--media-preview-border-radius) var(--media-preview-border-radius)\n        var(--media-preview-border-radius) var(--media-preview-border-radius));\n      padding: var(--media-preview-time-padding, 3.5px 9px);\n      margin: var(--media-preview-time-margin, 0);\n      text-shadow: var(--media-preview-time-text-shadow, 0 0 4px rgb(0 0 0 / .75));\n      transform: translateX(min(\n        max(calc(50% - var(--_box-width) / 2),\n        calc(var(--_box-shift, 0))),\n        calc(var(--_box-width) / 2 - 50%)\n      ));\n    }\n\n    :host([${v.MEDIA_PREVIEW_IMAGE}]) media-preview-time-display,\n    :host([${v.MEDIA_PREVIEW_IMAGE}]) ::slotted(media-preview-time-display) {\n      transition-delay: var(--media-preview-transition-delay-in, .25s);\n      border-radius: var(--media-preview-time-border-radius,\n        0 0 var(--media-preview-border-radius) var(--media-preview-border-radius));\n      min-width: 100%;\n      transform: translateX(0);\n    }\n\n    :host([${v.MEDIA_PREVIEW_TIME}]:hover) {\n      --media-time-range-hover-display: block;\n    }\n\n    [part~="arrow"],\n    ::slotted([part~="arrow"]) {\n      display: var(--media-box-arrow-display, inline-block);\n      transform: translateX(min(\n        max(calc(50% - var(--_box-width) / 2 + var(--media-box-arrow-offset)),\n        calc(var(--_box-shift, 0))),\n        calc(var(--_box-width) / 2 - 50% - var(--media-box-arrow-offset))\n      ));\n      \n      border-color: transparent;\n      border-top-color: var(--media-box-arrow-background, var(--_control-background));\n      border-width: var(--media-box-arrow-border-width,\n        var(--media-box-arrow-height, 5px) var(--media-box-arrow-width, 6px) 0);\n      border-style: solid;\n      justify-content: center;\n      height: 0;\n    }\n  </style>\n  <div id="preview-rail">\n    <slot name="preview" part="box preview-box">\n      <media-preview-thumbnail></media-preview-thumbnail>\n      <media-preview-chapter-display></media-preview-chapter-display>\n      <media-preview-time-display></media-preview-time-display>\n      <slot name="preview-arrow"><div part="arrow"></div></slot>\n    </slot>\n  </div>\n  <div id="current-rail">\n    <slot name="current" part="box current-box">\n      \n    </slot>\n  </div>\n`;
	var sd = (e, t = e.mediaCurrentTime) => {
		let i = Number.isFinite(e.mediaSeekableStart) ? e.mediaSeekableStart : 0,
			a = Number.isFinite(e.mediaDuration) ? e.mediaDuration : e.mediaSeekableEnd;
		if (Number.isNaN(a)) return 0;
		let r = (t - i) / (a - i);
		return Math.max(0, Math.min(r, 1))
	}, od = (e, t = e.range.valueAsNumber) => {
		let i = Number.isFinite(e.mediaSeekableStart) ? e.mediaSeekableStart : 0,
			a = Number.isFinite(e.mediaDuration) ? e.mediaDuration : e.mediaSeekableEnd;
		return Number.isNaN(a) ? 0 : t * (a - i) + i
	};
	Rl = new WeakMap, Il = new WeakMap, Dl = new WeakMap, Cl = new WeakMap, xl = new WeakMap, Ml = new WeakMap, Ol = new WeakMap, Pl = new WeakMap, Nl = new WeakMap, Ul = new WeakSet, Fl = function () {
		rd(this, Bl, $l).call(this) ? td(this, Il).start() : td(this, Il).stop()
	}, Bl = new WeakSet, $l = function () {
		return this.isConnected && !this.mediaPaused && !this.mediaLoading && !this.mediaEnded && this.mediaSeekableEnd > 0 && function (e, t = 3) {
			if (e.checkVisibility) return e.checkVisibility({checkOpacity: !0, checkVisibilityCSS: !0});
			let i = e;
			for (; i && t > 0;) {
				let e = getComputedStyle(i);
				if ("0" === e.opacity || "hidden" === e.visibility || "none" === e.display) return !1;
				i = i.parentElement, t--
			}
			return !0
		}(this)
	}, Hl = new WeakMap, Wl = new WeakSet, Gl = function (e) {
		var t;
		let i = (null != (t = this.getAttribute("bounds") ? oe(this, `#${this.getAttribute("bounds")}`) : this.parentElement) ? t : this).getBoundingClientRect(),
			a = this.range.getBoundingClientRect(), r = e.offsetWidth;
		return {box: {width: r, min: -(a.left - i.left - r / 2), max: i.right - a.left - r / 2}, bounds: i, range: a}
	}, Vl = new WeakSet, Kl = function (e, t) {
		let i = 100 * t + "%", {width: a, min: r, max: n} = e.box;
		if (!a) return i;
		if (Number.isNaN(r) || (i = `max(calc(1 / var(--_range-width) * 100 * ${r}% + var(--media-box-padding-left)), ${i})`), !Number.isNaN(n)) {
			i = `min(${i}, ${`calc(1 / var(--_range-width) * 100 * ${n}% - var(--media-box-padding-right))`})`
		}
		return i
	}, ql = new WeakSet, Yl = function (e, t) {
		let {width: i, min: a, max: r} = e.box, n = t * e.range.width;
		if (n < a + td(this, Ol)) {
			return `${n - i / 2 + (e.range.left - e.bounds.left - td(this, Ol))}px`
		}
		if (n > r - td(this, Pl)) {
			return n + i / 2 - (e.bounds.right - e.range.right - td(this, Pl)) - e.range.width + "px"
		}
		return 0
	}, jl = new WeakSet, zl = function (e) {
		let t = [...td(this, Dl)].some((t => e.composedPath().includes(t)));
		if (!this.dragging && (t || !e.composedPath().includes(this))) return void rd(this, Xl, Ql).call(this, null);
		let i = this.mediaSeekableEnd;
		if (!i) return;
		let a = he(this.shadowRoot, "#preview-rail"), r = he(this.shadowRoot, '[part~="preview-box"]'),
			n = rd(this, Wl, Gl).call(this, td(this, xl)), s = (e.clientX - n.range.left) / n.range.width;
		s = Math.max(0, Math.min(1, s));
		let o = rd(this, Vl, Kl).call(this, n, s), l = rd(this, ql, Yl).call(this, n, s);
		a.style.transform = `translateX(${o})`, a.style.setProperty("--_range-width", `${n.range.width}`), r.style.setProperty("--_box-shift", `${l}`), r.style.setProperty("--_box-width", `${n.box.width}px`);
		let d = Math.round(td(this, Cl)) - Math.round(s * i);
		Math.abs(d) < 1 && s > .01 && s < .99 || (ad(this, Cl, s * i), rd(this, Xl, Ql).call(this, td(this, Cl)))
	}, Xl = new WeakSet, Ql = function (e) {
		this.dispatchEvent(new z.CustomEvent(m.MEDIA_PREVIEW_REQUEST, {composed: !0, bubbles: !0, detail: e}))
	}, Zl = new WeakSet, Jl = function () {
		td(this, Il).stop();
		let e = od(this);
		this.dispatchEvent(new z.CustomEvent(m.MEDIA_SEEK_REQUEST, {composed: !0, bubbles: !0, detail: e}))
	}, z.customElements.get("media-time-range") || z.customElements.define("media-time-range", class extends cs {
		constructor() {
			super(), id(this, Ul), id(this, Bl), id(this, Wl), id(this, Vl), id(this, ql), id(this, jl), id(this, Xl), id(this, Zl), id(this, Rl, void 0), id(this, Il, void 0), id(this, Dl, void 0), id(this, Cl, void 0), id(this, xl, void 0), id(this, Ml, void 0), id(this, Ol, void 0), id(this, Pl, void 0), id(this, Nl, void 0), id(this, Hl, (e => {
				this.dragging || (this.range.valueAsNumber = e, this.updateBar())
			})), this.container.appendChild(nd.content.cloneNode(!0)), ad(this, Dl, this.shadowRoot.querySelectorAll('[part~="box"]')), ad(this, xl, this.shadowRoot.querySelector('[part~="preview-box"]')), ad(this, Ml, this.shadowRoot.querySelector('[part~="current-box"]'));
			let e = getComputedStyle(this);
			ad(this, Ol, parseInt(e.getPropertyValue("--media-box-padding-left"))), ad(this, Pl, parseInt(e.getPropertyValue("--media-box-padding-right"))), ad(this, Il, new class {
				constructor(e, t, i) {
					wl(this, fl, void 0), wl(this, pl, void 0), wl(this, gl, void 0), wl(this, vl, void 0), wl(this, El, void 0), wl(this, bl, void 0), wl(this, yl, void 0), wl(this, Tl, void 0), wl(this, Al, 0), wl(this, _l, ((e = performance.now()) => {
						Ll(this, Al, requestAnimationFrame(Sl(this, _l))), Ll(this, vl, performance.now() - Sl(this, gl));
						let t = 1e3 / this.fps;
						if (Sl(this, vl) > t) {
							Ll(this, gl, e - Sl(this, vl) % t);
							let i = 1e3 / ((e - Sl(this, pl)) / ++((e, t, i, a) => ({
									set _(a) {
										Ll(e, t, a, i)
									}, get _() {
										return Sl(e, t, a)
									}
								}))(this, El)._), a = (e - Sl(this, bl)) / 1e3 / this.duration,
								r = Sl(this, yl) + a * this.playbackRate;
							r - Sl(this, fl).valueAsNumber > 0 ? Ll(this, Tl, this.playbackRate / this.duration / i) : (Ll(this, Tl, .995 * Sl(this, Tl)), r = Sl(this, fl).valueAsNumber + Sl(this, Tl)), this.callback(r)
						}
					})), Ll(this, fl, e), this.callback = t, this.fps = i
				}

				start() {
					0 === Sl(this, Al) && (Ll(this, gl, performance.now()), Ll(this, pl, Sl(this, gl)), Ll(this, El, 0), Sl(this, _l).call(this))
				}

				stop() {
					0 !== Sl(this, Al) && (cancelAnimationFrame(Sl(this, Al)), Ll(this, Al, 0))
				}

				update({start: e, duration: t, playbackRate: i}) {
					let a = e - Sl(this, fl).valueAsNumber, r = Math.abs(t - this.duration);
					(a > 0 || a < -.03 || r >= .5) && this.callback(e), Ll(this, yl, e), Ll(this, bl, performance.now()), this.duration = t, this.playbackRate = i
				}
			}(this.range, td(this, Hl), 60))
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_PAUSED, v.MEDIA_DURATION, v.MEDIA_SEEKABLE, v.MEDIA_CURRENT_TIME, v.MEDIA_PREVIEW_IMAGE, v.MEDIA_PREVIEW_TIME, v.MEDIA_PREVIEW_CHAPTER, v.MEDIA_BUFFERED, v.MEDIA_PLAYBACK_RATE, v.MEDIA_LOADING, v.MEDIA_ENDED]
		}

		get mediaChaptersCues() {
			return td(this, Nl)
		}

		set mediaChaptersCues(e) {
			var t;
			ad(this, Nl, e), this.updateSegments(null == (t = td(this, Nl)) ? void 0 : t.map((e => ({
				start: sd(this, e.startTime),
				end: sd(this, e.endTime)
			}))))
		}

		get mediaPaused() {
			return pe(this, v.MEDIA_PAUSED)
		}

		set mediaPaused(e) {
			ge(this, v.MEDIA_PAUSED, e)
		}

		get mediaLoading() {
			return pe(this, v.MEDIA_LOADING)
		}

		set mediaLoading(e) {
			ge(this, v.MEDIA_LOADING, e)
		}

		get mediaDuration() {
			return me(this, v.MEDIA_DURATION)
		}

		set mediaDuration(e) {
			fe(this, v.MEDIA_DURATION, e)
		}

		get mediaCurrentTime() {
			return me(this, v.MEDIA_CURRENT_TIME)
		}

		set mediaCurrentTime(e) {
			fe(this, v.MEDIA_CURRENT_TIME, e)
		}

		get mediaPlaybackRate() {
			return me(this, v.MEDIA_PLAYBACK_RATE, 1)
		}

		set mediaPlaybackRate(e) {
			fe(this, v.MEDIA_PLAYBACK_RATE, e)
		}

		get mediaBuffered() {
			let e = this.getAttribute(v.MEDIA_BUFFERED);
			return e ? e.split(" ").map((e => e.split(":").map((e => +e)))) : []
		}

		set mediaBuffered(e) {
			if (!e) return void this.removeAttribute(v.MEDIA_BUFFERED);
			let t = e.map((e => e.join(":"))).join(" ");
			this.setAttribute(v.MEDIA_BUFFERED, t)
		}

		get mediaSeekable() {
			let e = this.getAttribute(v.MEDIA_SEEKABLE);
			if (e) return e.split(":").map((e => +e))
		}

		set mediaSeekable(e) {
			null != e ? this.setAttribute(v.MEDIA_SEEKABLE, e.join(":")) : this.removeAttribute(v.MEDIA_SEEKABLE)
		}

		get mediaSeekableEnd() {
			var e;
			let [, t = this.mediaDuration] = null != (e = this.mediaSeekable) ? e : [];
			return t
		}

		get mediaSeekableStart() {
			var e;
			let [t = 0] = null != (e = this.mediaSeekable) ? e : [];
			return t
		}

		get mediaPreviewImage() {
			return ve(this, v.MEDIA_PREVIEW_IMAGE)
		}

		set mediaPreviewImage(e) {
			Ee(this, v.MEDIA_PREVIEW_IMAGE, e)
		}

		get mediaPreviewTime() {
			return me(this, v.MEDIA_PREVIEW_TIME)
		}

		set mediaPreviewTime(e) {
			fe(this, v.MEDIA_PREVIEW_TIME, e)
		}

		get mediaEnded() {
			return pe(this, v.MEDIA_ENDED)
		}

		set mediaEnded(e) {
			ge(this, v.MEDIA_ENDED, e)
		}

		connectedCallback() {
			var e;
			super.connectedCallback(), this.range.setAttribute("aria-label", I.SEEK()), rd(this, Ul, Fl).call(this), ad(this, Rl, this.getRootNode()), null == (e = td(this, Rl)) || e.addEventListener("transitionstart", this)
		}

		disconnectedCallback() {
			var e;
			super.disconnectedCallback(), rd(this, Ul, Fl).call(this), null == (e = td(this, Rl)) || e.removeEventListener("transitionstart", this), ad(this, Rl, null)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), t != i && (e === v.MEDIA_CURRENT_TIME || e === v.MEDIA_PAUSED || e === v.MEDIA_ENDED || e === v.MEDIA_LOADING || e === v.MEDIA_DURATION || e === v.MEDIA_SEEKABLE ? (td(this, Il).update({
				start: sd(this),
				duration: this.mediaSeekableEnd - this.mediaSeekableStart,
				playbackRate: this.mediaPlaybackRate
			}), rd(this, Ul, Fl).call(this), (e => {
				let t = e.range, i = H(+od(e)), a = H(+e.mediaSeekableEnd),
					r = i && a ? `${i} of ${a}` : "video not loaded, unknown time.";
				t.setAttribute("aria-valuetext", r)
			})(this)) : e === v.MEDIA_BUFFERED && this.updateBufferedBar(), (e === v.MEDIA_DURATION || e === v.MEDIA_SEEKABLE) && (this.mediaChaptersCues = td(this, Nl), this.updateBar()))
		}

		updateBar() {
			super.updateBar(), this.updateBufferedBar(), this.updateCurrentBox()
		}

		updateBufferedBar() {
			var e;
			let t, i = this.mediaBuffered;
			if (!i.length) return;
			if (this.mediaEnded) t = 1; else {
				let a = this.mediaCurrentTime, [, r = this.mediaSeekableStart] = null != (e = i.find((([e, t]) => e <= a && a <= t))) ? e : [];
				t = sd(this, r)
			}
			let {style: a} = he(this.shadowRoot, "#highlight");
			a.setProperty("width", 100 * t + "%")
		}

		updateCurrentBox() {
			if (!this.shadowRoot.querySelector('slot[name="current"]').assignedElements().length) return;
			let e = he(this.shadowRoot, "#current-rail"), t = he(this.shadowRoot, '[part~="current-box"]'),
				i = rd(this, Wl, Gl).call(this, td(this, Ml)),
				a = rd(this, Vl, Kl).call(this, i, this.range.valueAsNumber),
				r = rd(this, ql, Yl).call(this, i, this.range.valueAsNumber);
			e.style.transform = `translateX(${a})`, e.style.setProperty("--_range-width", `${i.range.width}`), t.style.setProperty("--_box-shift", `${r}`), t.style.setProperty("--_box-width", `${i.box.width}px`), t.style.setProperty("visibility", "initial")
		}

		handleEvent(e) {
			switch (super.handleEvent(e), e.type) {
				case"input":
					rd(this, Zl, Jl).call(this);
					break;
				case"pointermove":
					rd(this, jl, zl).call(this, e);
					break;
				case"pointerup":
				case"pointerleave":
					rd(this, Xl, Ql).call(this, null);
					break;
				case"transitionstart":
					se(e.target, this) && setTimeout((() => rd(this, Ul, Fl).call(this)), 0)
			}
		}
	});
	z.customElements.get("media-volume-range") || z.customElements.define("media-volume-range", class extends cs {
		constructor() {
			super(), this.range.addEventListener("input", (() => {
				let e = this.range.value,
					t = new z.CustomEvent(m.MEDIA_VOLUME_REQUEST, {composed: !0, bubbles: !0, detail: e});
				this.dispatchEvent(t)
			}))
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_VOLUME, v.MEDIA_MUTED, v.MEDIA_VOLUME_UNAVAILABLE]
		}

		get mediaVolume() {
			return me(this, v.MEDIA_VOLUME, 1)
		}

		set mediaVolume(e) {
			fe(this, v.MEDIA_VOLUME, e)
		}

		get mediaMuted() {
			return pe(this, v.MEDIA_MUTED)
		}

		set mediaMuted(e) {
			ge(this, v.MEDIA_MUTED, e)
		}

		get mediaVolumeUnavailable() {
			return ve(this, v.MEDIA_VOLUME_UNAVAILABLE)
		}

		set mediaVolumeUnavailable(e) {
			Ee(this, v.MEDIA_VOLUME_UNAVAILABLE, e)
		}

		connectedCallback() {
			super.connectedCallback(), this.range.setAttribute("aria-label", I.VOLUME())
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), (e === v.MEDIA_VOLUME || e === v.MEDIA_MUTED) && (this.range.valueAsNumber = (e => e.mediaMuted ? 0 : e.mediaVolume)(this), this.range.setAttribute("aria-valuetext", (({value: e}) => `${Math.round(100 * e)}%`)(this.range)), this.updateBar())
		}
	});
	var ld, dd, ud, hd, cd, md, fd, pd, gd, vd, Ed, bd, yd, Td, Ad, _d, kd, Sd, wd, Ld = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, Rd = (e, t, i) => (Ld(e, t, "read from private field"), i ? i.call(e) : t.get(e)), Id = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, Dd = (e, t, i, a) => (Ld(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		Cd = (e, t, i) => (Ld(e, t, "access private method"), i);

	function xd(e, t, i) {
		let a = X.createElement("media-chrome-option");
		a.part.add("option"), a.value = t, a.selected = i;
		let r = X.createElement("span");
		return r.textContent = e, a.append(r), a
	}

	function Md(e, t) {
		let i = e.querySelector(`:scope > [slot="${t}"]`);
		return "SLOT" == (null == i ? void 0 : i.nodeName) && (i = i.assignedElements({flatten: !0})[0]), i ? (i = i.cloneNode(!0), i.removeAttribute("slot"), i) : e.shadowRoot.querySelector(`[name="${t}"] > svg`).cloneNode(!0)
	}

	var Od = X.createElement("template");
	Od.innerHTML = '\n<style>\n  :host {\n    font: var(--media-font,\n      var(--media-font-weight, normal)\n      var(--media-font-size, 15px) /\n      var(--media-text-content-height, var(--media-control-height, 24px))\n      var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));\n    color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));\n    background: var(--media-listbox-background, var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .8))));\n    border-radius: var(--media-listbox-border-radius);\n    display: inline-flex;\n    flex-direction: column;\n    position: relative;\n    box-sizing: border-box;\n  }\n\n  ::slotted([slot="header"]) {\n    padding: .4em 1.4em;\n    border-bottom: 1px solid rgb(255 255 255 / .25);\n  }\n\n  #container {\n    gap: var(--media-listbox-gap);\n    display: flex;\n    flex-direction: var(--media-listbox-flex-direction, column);\n    overflow: hidden auto;\n    padding-block: .5em;\n  }\n\n  media-chrome-option {\n    padding-inline: .7em 1.4em;\n  }\n\n  media-chrome-option > span {\n    margin-inline: .5ch;\n  }\n\n  [part~="indicator"] {\n    fill: var(--media-option-indicator-fill, var(--media-icon-color, var(--media-primary-color, rgb(238 238 238))));\n    height: var(--media-option-indicator-height, 1.25em);\n    vertical-align: var(--media-option-indicator-vertical-align, text-top);\n  }\n\n  [part~="select-indicator"] {\n    display: var(--media-option-select-indicator-display);\n    visibility: hidden;\n  }\n\n  [aria-selected="true"] > [part~="select-indicator"] {\n    visibility: visible;\n  }\n</style>\n<style id="layout-row" media="width:0">\n\n  ::slotted([slot="header"]) {\n    padding: .4em .5em;\n  }\n\n  #container {\n    gap: var(--media-listbox-gap, .25em);\n    flex-direction: var(--media-listbox-flex-direction, row);\n    padding-inline: .5em;\n  }\n\n  media-chrome-option {\n    padding: .3em .24em;\n  }\n\n  media-chrome-option[aria-selected="true"] {\n    background: var(--media-option-selected-background, rgb(255 255 255 / .2));\n  }\n\n  [part~="select-indicator"] {\n    display: var(--media-option-select-indicator-display, none);\n  }\n</style>\n<slot name="header"></slot>\n<slot id="container"></slot>\n<slot name="select-indicator" hidden>\n<svg aria-hidden="true" viewBox="0 1 24 24" part="select-indicator indicator">\n  <path d="m10 15.17 9.193-9.191 1.414 1.414-10.606 10.606-6.364-6.364 1.414-1.414 4.95 4.95Z"/>\n</svg></slot>\n';
	var Pd = class extends z.HTMLElement {
		constructor(e = {}) {
			super(), Id(this, md), Id(this, vd), Id(this, bd), Id(this, Td), Id(this, _d), Id(this, Sd), Id(this, ld, void 0), Id(this, dd, ""), Id(this, ud, null), Id(this, hd, !1), Id(this, cd, (e => {
				this.handleClick(e)
			})), Id(this, pd, (e => {
				let {key: t} = e;
				"Escape" !== t ? "Meta" !== t ? Cd(this, md, fd).call(this, e) : Dd(this, hd, !1) : this.removeEventListener("keyup", Rd(this, pd))
			})), Id(this, gd, (e => {
				let {key: t, altKey: i} = e;
				i ? this.removeEventListener("keyup", Rd(this, pd)) : "Meta" !== t ? (this.keysUsed.includes(t) && e.preventDefault(), Rd(this, hd) && this.keysUsed.includes(t) ? Cd(this, md, fd).call(this, e) : this.addEventListener("keyup", Rd(this, pd), {once: !0})) : Dd(this, hd, !0)
			})), this.shadowRoot || (this.attachShadow({mode: "open"}), this.nativeEl = Od.content.cloneNode(!0), e.slotTemplate && this.nativeEl.append(e.slotTemplate.content.cloneNode(!0)), this.shadowRoot.append(this.nativeEl)), this.container = this.shadowRoot.querySelector("#container"), this.container.addEventListener("slotchange", (e => {
				for (let t of e.target.assignedNodes({flatten: !0})) 3 === t.nodeType && "" === t.textContent.trim() && t.remove()
			}))
		}

		static get observedAttributes() {
			return ["disabled", "style", f.MEDIA_CONTROLLER]
		}

		get options() {
			var e;
			let t = this.querySelectorAll("media-chrome-option");
			return t.length || (t = null == (e = this.container) ? void 0 : e.querySelectorAll("media-chrome-option")), Array.from(t)
		}

		get selectedOptions() {
			return this.options.filter((e => e.selected))
		}

		get value() {
			var e, t;
			return null != (t = null == (e = this.selectedOptions[0]) ? void 0 : e.value) ? t : ""
		}

		set value(e) {
			let t = this.options.find((t => t.value === e));
			t && Cd(this, Td, Ad).call(this, t)
		}

		get keysUsed() {
			return ["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"]
		}

		static formatOptionText(e) {
			return e
		}

		formatOptionText(e, t) {
			return this.constructor.formatOptionText(e, t)
		}

		focus() {
			var e;
			null == (e = this.selectedOptions[0]) || e.focus()
		}

		enable() {
			this.addEventListener("click", Rd(this, cd)), this.addEventListener("keydown", Rd(this, gd))
		}

		disable() {
			this.removeEventListener("click", Rd(this, cd)), this.removeEventListener("keyup", Rd(this, pd))
		}

		attributeChangedCallback(e, t, i) {
			var a, r, n, s, o;
			"style" === e && i !== t ? Cd(this, vd, Ed).call(this) : e === f.MEDIA_CONTROLLER ? (t && (null == (r = null == (a = Rd(this, ld)) ? void 0 : a.unassociateElement) || r.call(a, this), Dd(this, ld, null)), i && this.isConnected && (Dd(this, ld, null == (n = this.getRootNode()) ? void 0 : n.getElementById(i)), null == (o = null == (s = Rd(this, ld)) ? void 0 : s.associateElement) || o.call(s, this))) : "disabled" === e && i !== t && (null == i ? this.enable() : this.disable())
		}

		connectedCallback() {
			var e, t, i;
			Cd(this, vd, Ed).call(this), this.hasAttribute("disabled") || this.enable(), this.hasAttribute("role") || this.setAttribute("role", "listbox");
			let a = this.getAttribute(f.MEDIA_CONTROLLER);
			a && (Dd(this, ld, null == (e = this.getRootNode()) ? void 0 : e.getElementById(a)), null == (i = null == (t = Rd(this, ld)) ? void 0 : t.associateElement) || i.call(t, this))
		}

		disconnectedCallback() {
			var e, t;
			this.disable(), null == (t = null == (e = Rd(this, ld)) ? void 0 : e.unassociateElement) || t.call(e, this), Dd(this, ld, null)
		}

		handleSelection(e, t) {
			let i = Cd(this, bd, yd).call(this, e);
			i && Cd(this, Td, Ad).call(this, i, t)
		}

		handleMovement(e) {
			let t, {key: i} = e, a = this.options, r = Cd(this, bd, yd).call(this, e);
			switch (r || (r = a.filter((e => "0" === e.getAttribute("tabindex")))[0]), i) {
				case"ArrowDown":
					t = r.nextElementSibling, null != t && t.hasAttribute("disabled") && (t = t.nextElementSibling);
					break;
				case"ArrowUp":
					t = r.previousElementSibling, null != t && t.hasAttribute("disabled") && (t = t.previousElementSibling);
					break;
				case"Home":
					t = a[0];
					break;
				case"End":
					t = a[a.length - 1];
					break;
				default:
					t = Cd(this, _d, kd).call(this, i)
			}
			t && (a.forEach((e => e.setAttribute("tabindex", "-1"))), t.setAttribute("tabindex", "0"), t.focus())
		}

		handleClick(e) {
			let t = Cd(this, bd, yd).call(this, e);
			!t || t.hasAttribute("disabled") || (this.options.forEach((e => e.setAttribute("tabindex", "-1"))), t.setAttribute("tabindex", "0"), this.handleSelection(e, this.hasAttribute("aria-multiselectable") && "true" === this.getAttribute("aria-multiselectable")))
		}
	};
	ld = new WeakMap, dd = new WeakMap, ud = new WeakMap, hd = new WeakMap, cd = new WeakMap, md = new WeakSet, fd = function (e) {
		let {key: t} = e;
		"Enter" === t || " " === t ? this.handleSelection(e, this.hasAttribute("aria-multiselectable") && "true" === this.getAttribute("aria-multiselectable")) : this.handleMovement(e)
	}, pd = new WeakMap, gd = new WeakMap, vd = new WeakSet, Ed = function () {
		var e;
		let t = this.shadowRoot.querySelector("#layout-row"),
			i = "row" === (null == (e = getComputedStyle(this).getPropertyValue("--media-listbox-layout")) ? void 0 : e.trim());
		t.setAttribute("media", i ? "" : "width:0")
	}, bd = new WeakSet, yd = function (e) {
		let t = e.composedPath(), i = t.findIndex((e => "MEDIA-CHROME-OPTION" === e.nodeName));
		return t[i]
	}, Td = new WeakSet, Ad = function (e, t) {
		let i = [...this.selectedOptions];
		(!this.hasAttribute("aria-multiselectable") || "true" !== this.getAttribute("aria-multiselectable")) && this.options.forEach((e => e.selected = !1)), e.selected = !t || !e.selected, this.selectedOptions.some(((e, t) => e != i[t])) && this.dispatchEvent(new Event("change", {
			bubbles: !0,
			composed: !0
		}))
	}, _d = new WeakSet, kd = function (e) {
		Cd(this, Sd, wd).call(this);
		let t = this.options, i = t.findIndex((e => "0" === e.getAttribute("tabindex")));
		Dd(this, dd, Rd(this, dd) + e);
		let a = Rd(this, dd).split("").every((t => t === e)),
			r = t.slice(i + (a ? 1 : 0)).filter((e => e.textContent.toLowerCase().startsWith(Rd(this, dd)))),
			n = t.slice(0, i - (a ? 1 : 0)).filter((e => e.textContent.toLowerCase().startsWith(Rd(this, dd)))), s = [],
			o = [];
		return a && (s = t.slice(i + (a ? 1 : 0)).filter((t => t.textContent.startsWith(e))), o = t.slice(0, i - (a ? 1 : 0)).filter((t => t.textContent.startsWith(e)))), [...r, ...n, ...s, ...o][0]
	}, Sd = new WeakSet, wd = function () {
		clearTimeout(Rd(this, ud)), Dd(this, ud, null), Dd(this, ud, setTimeout((() => {
			Dd(this, dd, ""), Dd(this, ud, null)
		}), 500))
	}, z.customElements.get("media-chrome-listbox") || z.customElements.define("media-chrome-listbox", Pd);
	var Nd, Ud, Fd, Bd, $d = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, Hd = (e, t, i) => ($d(e, t, "read from private field"), i ? i.call(e) : t.get(e)), Wd = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, Gd = (e, t, i, a) => ($d(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		Vd = (e, t, i) => ($d(e, t, "access private method"), i), Kd = X.createElement("template");
	Kd.innerHTML = '\n<style>\n  :host {\n    cursor: pointer;\n    display: block;\n    line-height: revert;\n    white-space: nowrap;\n    white-space-collapse: collapse;\n    text-wrap: nowrap;\n    padding: .4em .5em;\n    transition: var(--media-option-transition);\n    outline: var(--media-option-outline, 0);\n    outline-offset: var(--media-option-outline-offset, -1px);\n  }\n\n  :host(:focus-visible) {\n    box-shadow: var(--media-option-focus-shadow, inset 0 0 0 2px rgb(27 127 204 / .9));\n    outline: var(--media-option-hover-outline, 0);\n    outline-offset: var(--media-option-hover-outline-offset,  var(--media-option-outline-offset, -1px));\n  }\n\n  :host(:hover) {\n    cursor: pointer;\n    background: var(--media-option-hover-background, rgb(82 82 122 / .8));\n    outline: var(--media-option-hover-outline);\n    outline-offset: var(--media-option-hover-outline-offset,  var(--media-option-outline-offset, -1px));\n  }\n\n  :host([aria-selected="true"]) {\n    background: var(--media-option-selected-background);\n  }\n\n  :host([disabled]) {\n    pointer-events: none;\n    color: rgba(255, 255, 255, .3);\n  }\n</style>\n<slot></slot>\n';
	var qd = "value", Yd = "selected", jd = "disabled", zd = class extends z.HTMLElement {
		constructor() {
			super(), Wd(this, Fd), Wd(this, Nd, !1), Wd(this, Ud, void 0), this.shadowRoot || (this.attachShadow({mode: "open"}), this.shadowRoot.appendChild(Kd.content.cloneNode(!0)))
		}

		static get observedAttributes() {
			return [jd, Yd, qd]
		}

		get value() {
			var e;
			return null != (e = this.getAttribute(qd)) ? e : this.text
		}

		set value(e) {
			this.setAttribute(qd, e)
		}

		get text() {
			var e;
			return (null != (e = this.textContent) ? e : "").trim()
		}

		get selected() {
			return "true" === this.getAttribute("aria-selected")
		}

		set selected(e) {
			Gd(this, Nd, !0), this.setAttribute("aria-selected", e ? "true" : "false"), e ? this.part.add("option-selected") : this.part.remove("option-selected")
		}

		enable() {
			this.hasAttribute("tabindex") || this.setAttribute("tabindex", -1), this.hasAttribute("aria-selected") || this.setAttribute("aria-selected", "false")
		}

		disable() {
			this.removeAttribute("tabindex")
		}

		attributeChangedCallback(e, t, i) {
			e !== Yd || Hd(this, Nd) ? e === jd && i !== t && (null == i ? this.enable() : this.disable()) : this.setAttribute("aria-selected", null != i ? "true" : "false")
		}

		connectedCallback() {
			this.hasAttribute(jd) || this.enable(), this.setAttribute("role", "option"), Gd(this, Ud, Xd(this, this.parentNode)), Vd(this, Fd, Bd).call(this)
		}

		disconnectedCallback() {
			this.disable(), Vd(this, Fd, Bd).call(this), Gd(this, Ud, null)
		}

		handleClick() {
		}
	};

	function Xd(e, t) {
		if (!e) return null;
		let {host: i} = e.getRootNode();
		return !t && i ? Xd(e, i) : null != t && t.options ? t : Xd(t, null == t ? void 0 : t.parentNode)
	}

	Nd = new WeakMap, Ud = new WeakMap, Fd = new WeakSet, Bd = function () {
		var e;
		let t = null == (e = Hd(this, Ud)) ? void 0 : e.options;
		if (!t) return;
		let i = t.filter((e => "true" === e.getAttribute("aria-selected"))).pop();
		i || (i = t[0]), "true" !== Hd(this, Ud).getAttribute("aria-multiselectable") && t.forEach((e => {
			e.setAttribute("tabindex", "-1"), e.setAttribute("aria-selected", "false")
		})), null == i || i.setAttribute("tabindex", "0"), null == i || i.setAttribute("aria-selected", "true")
	}, z.customElements.get("media-chrome-option") || z.customElements.define("media-chrome-option", zd);
	var Qd, Zd, Jd, eu, tu, iu, au, ru, nu, su, ou, lu, du, uu, hu, cu, mu, fu = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, pu = (e, t, i) => (fu(e, t, "read from private field"), i ? i.call(e) : t.get(e)), gu = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, vu = (e, t, i, a) => (fu(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		Eu = (e, t, i) => (fu(e, t, "access private method"), i), bu = X.createElement("template");
	bu.innerHTML = '\n  <style>\n  :host {\n    font: var(--media-font,\n      var(--media-font-weight, normal)\n      var(--media-font-size, 15px) /\n      var(--media-text-content-height, var(--media-control-height, 24px))\n      var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));\n    color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));\n    display: inline-flex;\n    position: relative;\n    flex-shrink: .5;\n  }\n\n  [name=listbox]::slotted(*),\n  [part=listbox] {\n    position: absolute;\n    bottom: 100%;\n    max-height: 300px;\n    transition: var(--media-selectmenu-transition-in,\n      visibility 0s, transform .15s ease-out, opacity .15s ease-out);\n    transform: var(--media-listbox-transform-in, translateY(0) scale(1));\n    visibility: visible;\n    opacity: 1;\n  }\n\n  [name=listbox][hidden]::slotted(*),\n  [hidden] [part=listbox] {\n    transition: var(--media-selectmenu-transition-out,\n      visibility .15s ease-out, transform .15s ease-out, opacity .15s ease-out);\n    transform: var(--media-listbox-transform-out, translateY(2px) scale(.99));\n    visibility: hidden;\n    opacity: 0;\n    pointer-events: none;\n  }\n\n  slot[name=listbox][hidden] {\n    display: block;\n  }\n  </style>\n\n  <slot name="button">\n    <media-chrome-button aria-haspopup="listbox" part="button">\n      <slot name="button-content"></slot>\n    </media-chrome-button>\n  </slot>\n  <slot name="listbox" hidden>\n    <media-chrome-listbox id="listbox" part="listbox">\n      <slot></slot>\n    </media-chrome-listbox>\n  </slot>\n';
	var yu = class extends z.HTMLElement {
		constructor() {
			var e;
			super(), gu(this, ou), gu(this, du), gu(this, hu), gu(this, Qd, void 0), gu(this, Zd, void 0), gu(this, Jd, void 0), gu(this, eu, void 0), gu(this, tu, void 0), gu(this, iu, (e => {
				let {key: t} = e;
				this.keysUsed.includes(t) ? !e.composedPath().includes(pu(this, Zd)) || "Enter" !== t && " " !== t ? "Escape" === t && Eu(this, hu, cu).call(this) : Eu(this, ou, lu).call(this) : this.removeEventListener("keyup", pu(this, iu))
			})), gu(this, au, (e => {
				let {metaKey: t, altKey: i, key: a} = e;
				t || i || !this.keysUsed.includes(a) ? this.removeEventListener("keyup", pu(this, iu)) : (e.preventDefault(), this.addEventListener("keyup", pu(this, iu), {once: !0}))
			})), gu(this, ru, (e => {
				e.composedPath().includes(this) || Eu(this, hu, cu).call(this)
			})), gu(this, nu, (e => {
				e.composedPath().includes(pu(this, Zd)) && Eu(this, ou, lu).call(this)
			})), gu(this, su, (() => {
				Eu(this, hu, cu).call(this)
			})), gu(this, mu, (() => {
				if (0 === pu(this, eu).offsetWidth) return;
				let e = pu(this, eu).offsetWidth, t = pu(this, Zd).getBoundingClientRect();
				if (this.hasAttribute("mediacontroller") || pu(this, Zd).hasAttribute("mediacontroller") || pu(this, eu).hasAttribute("mediacontroller")) return pu(this, eu).style.zIndex = "1", pu(this, eu).style.bottom = "unset", pu(this, eu).style.right = null, pu(this, eu).style.left = "0", void (pu(this, eu).style.top = `${t.height}px`);
				let i = Tu(this).getBoundingClientRect(), a = t.x + e, r = Math.max(t.right - a, t.right - i.right);
				pu(this, eu).style.left = null, pu(this, eu).style.right = `${r}px`, pu(this, eu).style.maxHeight = i.height - t.height + "px"
			})), this.shadowRoot || (this.attachShadow({mode: "open"}), this.shadowRoot.appendChild(bu.content.cloneNode(!0))), null == (e = this.init) || e.call(this), vu(this, Zd, this.shadowRoot.querySelector("[part=button]")), vu(this, eu, this.shadowRoot.querySelector("[part=listbox]")), vu(this, Jd, this.shadowRoot.querySelector("slot[name=button]")), pu(this, Jd).addEventListener("slotchange", (() => {
				let e = pu(this, Jd).assignedElements()[0];
				e && (vu(this, Zd, e), pu(this, Zd).preventClick = !0, this.hasAttribute("disabled") || pu(this, Zd).hasAttribute("disabled") ? this.disable() : (this.enable(), pu(this, Zd).setAttribute("aria-haspopup", "listbox")))
			})), vu(this, tu, this.shadowRoot.querySelector("slot[name=listbox]")), pu(this, tu).addEventListener("slotchange", (() => {
				vu(this, eu, pu(this, tu).assignedElements()[0] || pu(this, eu))
			}))
		}

		static get observedAttributes() {
			return ["disabled", f.MEDIA_CONTROLLER]
		}

		get keysUsed() {
			return ["Enter", "Escape", " ", "ArrowUp", "ArrowDown", "f", "c", "k", "m"]
		}

		enable() {
			pu(this, Zd).toggleAttribute("disabled", !1), this.addEventListener("change", pu(this, su)), this.addEventListener("keydown", pu(this, au)), this.addEventListener("click", pu(this, nu)), X.addEventListener("click", pu(this, ru))
		}

		disable() {
			pu(this, Zd).toggleAttribute("disabled", !0), this.removeEventListener("change", pu(this, su)), this.removeEventListener("keydown", pu(this, au)), this.removeEventListener("keyup", pu(this, iu)), this.removeEventListener("click", pu(this, nu)), X.removeEventListener("click", pu(this, ru))
		}

		attributeChangedCallback(e, t, i) {
			var a, r, n, s, o;
			e === f.MEDIA_CONTROLLER ? (t && (null == (r = null == (a = pu(this, Qd)) ? void 0 : a.unassociateElement) || r.call(a, this), vu(this, Qd, null), pu(this, eu).removeAttribute(f.MEDIA_CONTROLLER)), i && this.isConnected && (vu(this, Qd, null == (n = this.getRootNode()) ? void 0 : n.getElementById(i)), null == (o = null == (s = pu(this, Qd)) ? void 0 : s.associateElement) || o.call(s, this), pu(this, eu).setAttribute(f.MEDIA_CONTROLLER, i))) : "disabled" === e && i !== t && (null == i ? this.enable() : this.disable())
		}

		connectedCallback() {
			var e, t, i;
			let {style: a} = he(this.shadowRoot, ":host");
			a.setProperty("display", `var(--media-control-display, var(--${this.localName}-display, inline-flex))`);
			let r = this.getAttribute(f.MEDIA_CONTROLLER);
			r && (vu(this, Qd, null == (e = this.getRootNode()) ? void 0 : e.getElementById(r)), null == (i = null == (t = pu(this, Qd)) ? void 0 : t.associateElement) || i.call(t, this), pu(this, eu).setAttribute(f.MEDIA_CONTROLLER, r)), this.hasAttribute("disabled") || this.enable(), pu(this, tu).hidden || ee(Tu(this), pu(this, mu))
		}

		disconnectedCallback() {
			var e, t;
			te(Tu(this), pu(this, mu)), this.disable(), null == (t = null == (e = pu(this, Qd)) ? void 0 : e.unassociateElement) || t.call(e, this), vu(this, Qd, null), pu(this, eu).removeAttribute(f.MEDIA_CONTROLLER)
		}
	};

	function Tu(e) {
		var t;
		return null != (t = e.getAttribute("bounds") ? oe(e, `#${e.getAttribute("bounds")}`) : function (e) {
			var t;
			let i = e.getAttribute(f.MEDIA_CONTROLLER);
			return i ? null == (t = e.getRootNode()) ? void 0 : t.getElementById(i) : oe(e, "media-controller")
		}(e) || e.parentElement) ? t : e
	}

	Qd = new WeakMap, Zd = new WeakMap, Jd = new WeakMap, eu = new WeakMap, tu = new WeakMap, iu = new WeakMap, au = new WeakMap, ru = new WeakMap, nu = new WeakMap, su = new WeakMap, ou = new WeakSet, lu = function () {
		pu(this, tu).hidden ? Eu(this, du, uu).call(this) : Eu(this, hu, cu).call(this)
	}, du = new WeakSet, uu = function () {
		pu(this, tu).hidden && (pu(this, tu).hidden = !1, pu(this, Zd).setAttribute("aria-expanded", "true"), pu(this, mu).call(this), pu(this, eu).focus(), ee(Tu(this), pu(this, mu)))
	}, hu = new WeakSet, cu = function () {
		if (pu(this, tu).hidden) return;
		te(Tu(this), pu(this, mu));
		let e = le();
		pu(this, tu).hidden = !0, pu(this, Zd).setAttribute("aria-expanded", "false"), se(pu(this, eu), e) && pu(this, Zd).focus()
	}, mu = new WeakMap, z.customElements.get("media-chrome-selectmenu") || z.customElements.define("media-chrome-selectmenu", yu);
	var Au, _u, ku, Su, wu, Lu = (e, t, i) => {
		if (!t.has(e)) throw TypeError("Cannot " + i)
	}, Ru = (e, t, i) => {
		if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
		t instanceof WeakSet ? t.add(e) : t.set(e, i)
	}, Iu = (e, t, i) => (Lu(e, t, "access private method"), i), Du = X.createElement("template");
	Du.innerHTML = '\n  <slot name="captions-indicator" hidden>\n<svg aria-hidden="true" viewBox="0 0 26 24" part="captions-indicator indicator">\n  <path d="M22.83 5.68a2.58 2.58 0 0 0-2.3-2.5c-3.62-.24-11.44-.24-15.06 0a2.58 2.58 0 0 0-2.3 2.5c-.23 4.21-.23 8.43 0 12.64a2.58 2.58 0 0 0 2.3 2.5c3.62.24 11.44.24 15.06 0a2.58 2.58 0 0 0 2.3-2.5c.23-4.21.23-8.43 0-12.64Zm-11.39 9.45a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.92 3.92 0 0 1 .92-2.77 3.18 3.18 0 0 1 2.43-1 2.94 2.94 0 0 1 2.13.78c.364.359.62.813.74 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.17 1.61 1.61 0 0 0-1.29.58 2.79 2.79 0 0 0-.5 1.89 3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.48 1.48 0 0 0 1-.37 2.1 2.1 0 0 0 .59-1.14l1.4.44a3.23 3.23 0 0 1-1.07 1.69Zm7.22 0a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.88 3.88 0 0 1 .93-2.77 3.14 3.14 0 0 1 2.42-1 3 3 0 0 1 2.16.82 2.8 2.8 0 0 1 .73 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.21 1.61 1.61 0 0 0-1.29.58A2.79 2.79 0 0 0 15 12a3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.44 1.44 0 0 0 1-.37 2.1 2.1 0 0 0 .6-1.15l1.4.44a3.17 3.17 0 0 1-1.1 1.7Z"/>\n</svg></slot>\n';
	Au = new WeakMap, _u = new WeakSet, ku = function () {
		var e;
		if (((e, t, i) => (Lu(e, t, "read from private field"), i ? i.call(e) : t.get(e)))(this, Au) === JSON.stringify(this.mediaSubtitlesList)) return;
		((e, t, i, a) => {
			Lu(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i)
		})(this, Au, JSON.stringify(this.mediaSubtitlesList));
		let t = this.shadowRoot.querySelector("#container");
		t.textContent = "";
		let i = !this.value, a = xd(this.formatOptionText("Off"), "off", i);
		a.prepend(Md(this, "select-indicator")), t.append(a);
		let r = this.mediaSubtitlesList;
		for (let i of r) {
			let a = xd(this.formatOptionText(i.label, i), ut(i), this.value == ut(i));
			a.prepend(Md(this, "select-indicator")), "captions" === (null != (e = i.kind) ? e : "subs") && a.append(Md(this, "captions-indicator")), t.append(a)
		}
	}, Su = new WeakSet, wu = function () {
		let e = this.mediaSubtitlesShowing, t = this.getAttribute(v.MEDIA_SUBTITLES_SHOWING), i = this.value !== t;
		if (null != e && e.length && i && this.dispatchEvent(new z.CustomEvent(m.MEDIA_DISABLE_SUBTITLES_REQUEST, {
			composed: !0,
			bubbles: !0,
			detail: e
		})), !this.value || !i) return;
		let a = new z.CustomEvent(m.MEDIA_SHOW_SUBTITLES_REQUEST, {composed: !0, bubbles: !0, detail: this.value});
		this.dispatchEvent(a)
	};
	var Cu = (e, t) => {
		let i = e.getAttribute(t);
		return i ? lt(i) : []
	}, xu = (e, t, i) => {
		if (null == i || !i.length) return void e.removeAttribute(t);
		let a = ht(i);
		e.getAttribute(t) !== a && e.setAttribute(t, a)
	};
	z.customElements.get("media-captions-listbox") || z.customElements.define("media-captions-listbox", class extends Pd {
		constructor() {
			super({slotTemplate: Du}), Ru(this, _u), Ru(this, Su), Ru(this, Au, void 0)
		}

		static get observedAttributes() {
			return [...super.observedAttributes, "aria-multiselectable", v.MEDIA_SUBTITLES_LIST, v.MEDIA_SUBTITLES_SHOWING]
		}

		get mediaSubtitlesList() {
			return Cu(this, v.MEDIA_SUBTITLES_LIST)
		}

		set mediaSubtitlesList(e) {
			xu(this, v.MEDIA_SUBTITLES_LIST, e)
		}

		get mediaSubtitlesShowing() {
			return Cu(this, v.MEDIA_SUBTITLES_SHOWING)
		}

		set mediaSubtitlesShowing(e) {
			xu(this, v.MEDIA_SUBTITLES_SHOWING, e)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_SUBTITLES_LIST && t !== i ? Iu(this, _u, ku).call(this) : e === v.MEDIA_SUBTITLES_SHOWING && t !== i ? this.value = i : "aria-multiselectable" === e && (this.removeAttribute("aria-multiselectable"), console.warn("Captions List doesn't currently support multiple selections. You can enable multiple items via the media.textTracks API."))
		}

		connectedCallback() {
			super.connectedCallback(), this.addEventListener("change", Iu(this, Su, wu))
		}

		disconnectedCallback() {
			super.disconnectedCallback(), this.removeEventListener("change", Iu(this, Su, wu))
		}
	});
	z.customElements.get("media-captions-selectmenu") || z.customElements.define("media-captions-selectmenu", class extends yu {
		init() {
			let e = X.createElement("media-captions-button");
			e.part.add("button"), e.preventClick = !0;
			let t = X.createElement("media-captions-listbox");
			t.part.add("listbox"), t.setAttribute("exportparts", "option, option-selected, indicator");
			let i = this.shadowRoot.querySelector("slot[name=button]"),
				a = this.shadowRoot.querySelector("slot[name=listbox]");
			i.textContent = "", a.textContent = "", i.append(e), a.append(t)
		}
	});
	var Mu, Ou, Pu, Nu, Uu, Fu = (e, t, i) => {
		if (!t.has(e)) throw TypeError("Cannot " + i)
	}, Bu = (e, t, i) => (Fu(e, t, "read from private field"), i ? i.call(e) : t.get(e)), $u = (e, t, i) => {
		if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
		t instanceof WeakSet ? t.add(e) : t.set(e, i)
	}, Hu = (e, t, i) => (Fu(e, t, "access private method"), i), Wu = "rates";
	Mu = new WeakMap, Ou = new WeakSet, Pu = function () {
		let e = this.shadowRoot.querySelector("#container");
		e.textContent = "";
		for (let t of this.rates) {
			let i = xd(this.formatOptionText(`${t}x`, t), t, this.mediaPlaybackRate == t);
			i.prepend(Md(this, "select-indicator")), e.append(i)
		}
	}, Nu = new WeakSet, Uu = function () {
		if (!this.value) return;
		let e = new z.CustomEvent(m.MEDIA_PLAYBACK_RATE_REQUEST, {composed: !0, bubbles: !0, detail: this.value});
		this.dispatchEvent(e)
	}, z.customElements.get("media-playback-rate-listbox") || z.customElements.define("media-playback-rate-listbox", class extends Pd {
		constructor() {
			super(), $u(this, Ou), $u(this, Nu), $u(this, Mu, new st(this, Wu, {defaultValue: io})), Hu(this, Ou, Pu).call(this)
		}

		static get observedAttributes() {
			return [...super.observedAttributes, "aria-multiselectable", v.MEDIA_PLAYBACK_RATE, Wu]
		}

		get rates() {
			return Bu(this, Mu)
		}

		set rates(e) {
			e ? Array.isArray(e) && (Bu(this, Mu).value = e.join(" ")) : Bu(this, Mu).value = "", Hu(this, Ou, Pu).call(this)
		}

		get mediaPlaybackRate() {
			return me(this, v.MEDIA_PLAYBACK_RATE, 1)
		}

		set mediaPlaybackRate(e) {
			fe(this, v.MEDIA_PLAYBACK_RATE, e)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_PLAYBACK_RATE && t != i ? this.value = i : e === Wu && t != i && (Bu(this, Mu).value = i, Hu(this, Ou, Pu).call(this))
		}

		connectedCallback() {
			super.connectedCallback(), this.addEventListener("change", Hu(this, Nu, Uu))
		}

		disconnectedCallback() {
			super.disconnectedCallback(), this.removeEventListener("change", Hu(this, Nu, Uu))
		}
	});
	z.customElements.get("media-playback-rate-selectmenu") || z.customElements.define("media-playback-rate-selectmenu", class extends yu {
		init() {
			let e = X.createElement("media-playback-rate-button");
			e.part.add("button"), e.preventClick = !0;
			let t = X.createElement("media-playback-rate-listbox");
			t.part.add("listbox"), t.setAttribute("exportparts", "option, option-selected, indicator");
			let i = this.shadowRoot.querySelector("slot[name=button]"),
				a = this.shadowRoot.querySelector("slot[name=listbox]");
			i.textContent = "", a.textContent = "", i.append(e), a.append(t)
		}
	});
	var Gu, Vu, Ku, qu, Yu, ju, zu = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, Xu = (e, t, i) => (zu(e, t, "read from private field"), i ? i.call(e) : t.get(e)), Qu = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, Zu = (e, t, i, a) => (zu(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		Ju = (e, t, i) => (zu(e, t, "access private method"), i);
	Gu = new WeakMap, Vu = new WeakMap, Ku = new WeakSet, qu = function () {
		if (Xu(this, Vu) === JSON.stringify(this.mediaRenditionList)) return;
		Zu(this, Vu, JSON.stringify(this.mediaRenditionList));
		let e = this.mediaRenditionList.sort(((e, t) => t.height - e.height)),
			t = this.shadowRoot.querySelector("#container");
		t.textContent = "";
		let i = !this.mediaRenditionSelected;
		for (let a of e) {
			let e = xd(this.formatOptionText(`${Math.min(a.width, a.height)}p`, a), `${a.id}`, a.selected && !i);
			e.prepend(Md(this, "select-indicator")), t.append(e)
		}
		let a = xd(this.formatOptionText("Auto"), "auto", i);
		a.prepend(Md(this, "select-indicator")), t.append(a)
	}, Yu = new WeakSet, ju = function () {
		if (null == this.value) return;
		let e = new z.CustomEvent(m.MEDIA_RENDITION_REQUEST, {composed: !0, bubbles: !0, detail: this.value});
		this.dispatchEvent(e)
	}, z.customElements.get("media-rendition-listbox") || z.customElements.define("media-rendition-listbox", class extends Pd {
		constructor() {
			super(...arguments), Qu(this, Ku), Qu(this, Yu), Qu(this, Gu, []), Qu(this, Vu, void 0)
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_RENDITION_LIST, v.MEDIA_RENDITION_SELECTED]
		}

		get mediaRenditionList() {
			return Xu(this, Gu)
		}

		set mediaRenditionList(e) {
			Zu(this, Gu, e), Ju(this, Ku, qu).call(this)
		}

		get mediaRenditionSelected() {
			return ve(this, v.MEDIA_RENDITION_SELECTED)
		}

		set mediaRenditionSelected(e) {
			Ee(this, v.MEDIA_RENDITION_SELECTED, e)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_RENDITION_SELECTED && t !== i ? this.value = null != i ? i : "auto" : e === v.MEDIA_RENDITION_LIST && t !== i && (Zu(this, Gu, C(i)), Ju(this, Ku, qu).call(this))
		}

		connectedCallback() {
			super.connectedCallback(), this.addEventListener("change", Ju(this, Yu, ju))
		}

		disconnectedCallback() {
			super.disconnectedCallback(), this.removeEventListener("change", Ju(this, Yu, ju))
		}
	});
	var eh = X.createElement("template");
	eh.innerHTML = '\n  <slot name="icon"><svg aria-hidden="true" viewBox="0 0 24 24">\n  <path d="M13.5 2.5h2v6h-2v-2h-11v-2h11v-2Zm4 2h4v2h-4v-2Zm-12 4h2v6h-2v-2h-3v-2h3v-2Zm4 2h12v2h-12v-2Zm1 4h2v6h-2v-2h-8v-2h8v-2Zm4 2h7v2h-7v-2Z" />\n</svg></slot>\n';
	z.customElements.get("media-rendition-button") || z.customElements.define("media-rendition-button", class extends Ni {
		constructor() {
			super({slotTemplate: eh})
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_RENDITION_SELECTED, v.MEDIA_RENDITION_UNAVAILABLE]
		}

		get mediaRenditionSelected() {
			return ve(this, v.MEDIA_RENDITION_SELECTED)
		}

		set mediaRenditionSelected(e) {
			Ee(this, v.MEDIA_RENDITION_SELECTED, e)
		}
	});
	z.customElements.get("media-rendition-selectmenu") || z.customElements.define("media-rendition-selectmenu", class extends yu {
		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_RENDITION_SELECTED, v.MEDIA_RENDITION_UNAVAILABLE]
		}

		init() {
			let e = X.createElement("media-rendition-button");
			e.part.add("button"), e.preventClick = !0;
			let t = X.createElement("media-rendition-listbox");
			t.part.add("listbox"), t.setAttribute("exportparts", "option, option-selected, indicator");
			let i = this.shadowRoot.querySelector("slot[name=button]"),
				a = this.shadowRoot.querySelector("slot[name=listbox]");
			i.textContent = "", a.textContent = "", i.append(e), a.append(t)
		}
	});
	var th, ih, ah, rh, nh, sh, oh = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, lh = (e, t, i) => (oh(e, t, "read from private field"), i ? i.call(e) : t.get(e)), dh = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, uh = (e, t, i, a) => (oh(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		hh = (e, t, i) => (oh(e, t, "access private method"), i);
	th = new WeakMap, ih = new WeakMap, ah = new WeakSet, rh = function () {
		if (lh(this, ih) === JSON.stringify(this.mediaAudioTrackList)) return;
		uh(this, ih, JSON.stringify(this.mediaAudioTrackList));
		let e = this.mediaAudioTrackList, t = this.shadowRoot.querySelector("#container");
		t.textContent = "";
		for (let i of e) {
			let e = xd(this.formatOptionText(i.label, i), `${i.id}`, i.enabled);
			e.prepend(Md(this, "select-indicator")), t.append(e)
		}
	}, nh = new WeakSet, sh = function () {
		if (null == this.value) return;
		let e = new z.CustomEvent(m.MEDIA_AUDIO_TRACK_REQUEST, {composed: !0, bubbles: !0, detail: this.value});
		this.dispatchEvent(e)
	}, z.customElements.get("media-audio-track-listbox") || z.customElements.define("media-audio-track-listbox", class extends Pd {
		constructor() {
			super(...arguments), dh(this, ah), dh(this, nh), dh(this, th, []), dh(this, ih, void 0)
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_AUDIO_TRACK_LIST, v.MEDIA_AUDIO_TRACK_ENABLED]
		}

		get mediaAudioTrackList() {
			return lh(this, th)
		}

		set mediaAudioTrackList(e) {
			uh(this, th, e), hh(this, ah, rh).call(this)
		}

		get mediaAudioTrackEnabled() {
			return ve(this, v.MEDIA_AUDIO_TRACK_ENABLED)
		}

		set mediaAudioTrackEnabled(e) {
			Ee(this, v.MEDIA_AUDIO_TRACK_ENABLED, e)
		}

		attributeChangedCallback(e, t, i) {
			super.attributeChangedCallback(e, t, i), e === v.MEDIA_AUDIO_TRACK_ENABLED && t !== i ? this.value = i : e === v.MEDIA_AUDIO_TRACK_LIST && t !== i && (uh(this, th, O(i)), hh(this, ah, rh).call(this))
		}

		connectedCallback() {
			super.connectedCallback(), this.addEventListener("change", hh(this, nh, sh))
		}

		disconnectedCallback() {
			super.disconnectedCallback(), this.removeEventListener("change", hh(this, nh, sh))
		}
	});
	var ch = X.createElement("template");
	ch.innerHTML = '\n  <slot name="icon"><svg aria-hidden="true" viewBox="0 0 24 24">\n  <path d="M11 17H9.5V7H11v10Zm-3-3H6.5v-4H8v4Zm6-5h-1.5v6H14V9Zm3 7h-1.5V8H17v8Z"/>\n  <path d="M22 12c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10Zm-2 0a8 8 0 1 0-16 0 8 8 0 0 0 16 0Z"/>\n</svg></slot>\n';
	z.customElements.get("media-audio-track-button") || z.customElements.define("media-audio-track-button", class extends Ni {
		constructor() {
			super({slotTemplate: ch})
		}

		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_AUDIO_TRACK_ENABLED, v.MEDIA_AUDIO_TRACK_UNAVAILABLE]
		}

		get mediaAudioTrackEnabled() {
			return ve(this, v.MEDIA_AUDIO_TRACK_ENABLED)
		}

		set mediaAudioTrackEnabled(e) {
			Ee(this, v.MEDIA_AUDIO_TRACK_ENABLED, e)
		}
	});
	z.customElements.get("media-audio-track-selectmenu") || z.customElements.define("media-audio-track-selectmenu", class extends yu {
		static get observedAttributes() {
			return [...super.observedAttributes, v.MEDIA_AUDIO_TRACK_ENABLED, v.MEDIA_AUDIO_TRACK_UNAVAILABLE]
		}

		init() {
			let e = X.createElement("media-audio-track-button");
			e.part.add("button"), e.preventClick = !0;
			let t = X.createElement("media-audio-track-listbox");
			t.part.add("listbox"), t.setAttribute("exportparts", "option, option-selected, indicator");
			let i = this.shadowRoot.querySelector("slot[name=button]"),
				a = this.shadowRoot.querySelector("slot[name=listbox]");
			i.textContent = "", a.textContent = "", i.append(e), a.append(t)
		}
	});
	var mh = Object.create, fh = Object.defineProperty, ph = Object.getOwnPropertyDescriptor,
		gh = Object.getOwnPropertyNames, vh = Object.getPrototypeOf, Eh = Object.prototype.hasOwnProperty,
		bh = function (e, t) {
			return function () {
				return e && (t = e(e = 0)), t
			}
		}, yh = function (e, t) {
			return function () {
				return t || e((t = {exports: {}}).exports, t), t.exports
			}
		}, Th = function (e, t, i) {
			return i = null != e ? mh(vh(e)) : {}, function (e, t, i, a) {
				if (t && "object" == typeof t || "function" == typeof t) for (var r, n = gh(t), s = 0, o = n.length; s < o; s++) r = n[s], !Eh.call(e, r) && r !== i && fh(e, r, {
					get: function (e) {
						return t[e]
					}.bind(null, r), enumerable: !(a = ph(t, r)) || a.enumerable
				});
				return e
			}(!t && e && e.__esModule ? i : fh(i, "default", {value: e, enumerable: !0}), e)
		}, Ah = yh((function (e, t) {
			var i;
			i = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, t.exports = i
		}));

	function _h(e) {
		return e && "undefined" != typeof Symbol && e.constructor === Symbol ? "symbol" : typeof e
	}

	var kh = bh((function () {
	})), Sh = yh((function (e, t) {
		kh(), function (e, i) {
			"function" == typeof define && define.amd ? define(i) : "object" == typeof t && t.exports ? t.exports = i() : e.log = i()
		}(e, (function () {
			var e = function () {
				}, t = "undefined",
				i = ("undefined" == typeof window ? "undefined" : _h(window)) !== t && _h(window.navigator) !== t && /Trident\/|MSIE /.test(window.navigator.userAgent),
				a = ["trace", "debug", "info", "warn", "error"];

			function r(e, t) {
				var i = e[t];
				if ("function" == typeof i.bind) return i.bind(e);
				try {
					return Function.prototype.bind.call(i, e)
				} catch {
					return function () {
						return Function.prototype.apply.apply(i, [e, arguments])
					}
				}
			}

			function n() {
				console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace()
			}

			function s(t, i) {
				for (var r = 0; r < a.length; r++) {
					var n = a[r];
					this[n] = r < t ? e : this.methodFactory(n, t, i)
				}
				this.log = this.debug
			}

			function o(e, i, a) {
				return function () {
					("undefined" == typeof console ? "undefined" : _h(console)) !== t && (s.call(this, i, a), this[e].apply(this, arguments))
				}
			}

			function l(a, s, l) {
				return function (a) {
					return "debug" === a && (a = "log"), ("undefined" == typeof console ? "undefined" : _h(console)) !== t && ("trace" === a && i ? n : void 0 !== console[a] ? r(console, a) : void 0 !== console.log ? r(console, "log") : e)
				}(a) || o.apply(this, arguments)
			}

			function d(e, i, r) {
				var n, o = this;
				i = null == i ? "WARN" : i;
				var d = "loglevel";

				function u() {
					var e;
					if (("undefined" == typeof window ? "undefined" : _h(window)) !== t && d) {
						try {
							e = window.localStorage[d]
						} catch {
						}
						if ((void 0 === e ? "undefined" : _h(e)) === t) try {
							var i = window.document.cookie, a = i.indexOf(encodeURIComponent(d) + "=");
							-1 !== a && (e = /^([^;]+)/.exec(i.slice(a))[1])
						} catch {
						}
						return void 0 === o.levels[e] && (e = void 0), e
					}
				}

				"string" == typeof e ? d += ":" + e : "symbol" === (void 0 === e ? "undefined" : _h(e)) && (d = void 0), o.name = e, o.levels = {
					TRACE: 0,
					DEBUG: 1,
					INFO: 2,
					WARN: 3,
					ERROR: 4,
					SILENT: 5
				}, o.methodFactory = r || l, o.getLevel = function () {
					return n
				}, o.setLevel = function (i, r) {
					if ("string" == typeof i && void 0 !== o.levels[i.toUpperCase()] && (i = o.levels[i.toUpperCase()]), !("number" == typeof i && i >= 0 && i <= o.levels.SILENT)) throw "log.setLevel() called with invalid level: " + i;
					if (n = i, !1 !== r && function (e) {
						var i = (a[e] || "silent").toUpperCase();
						if (("undefined" == typeof window ? "undefined" : _h(window)) !== t && d) {
							try {
								return void (window.localStorage[d] = i)
							} catch {
							}
							try {
								window.document.cookie = encodeURIComponent(d) + "=" + i + ";"
							} catch {
							}
						}
					}(i), s.call(o, i, e), ("undefined" == typeof console ? "undefined" : _h(console)) === t && i < o.levels.SILENT) return "No console available for logging"
				}, o.setDefaultLevel = function (e) {
					i = e, u() || o.setLevel(e, !1)
				}, o.resetLevel = function () {
					o.setLevel(i, !1), function () {
						if (("undefined" == typeof window ? "undefined" : _h(window)) !== t && d) {
							try {
								return void window.localStorage.removeItem(d)
							} catch {
							}
							try {
								window.document.cookie = encodeURIComponent(d) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC"
							} catch {
							}
						}
					}()
				}, o.enableAll = function (e) {
					o.setLevel(o.levels.TRACE, e)
				}, o.disableAll = function (e) {
					o.setLevel(o.levels.SILENT, e)
				};
				var h = u();
				null == h && (h = i), o.setLevel(h, !1)
			}

			var u = new d, h = {};
			u.getLogger = function (e) {
				if ("symbol" !== (void 0 === e ? "undefined" : _h(e)) && "string" != typeof e || "" === e) throw new TypeError("You must supply a name when creating a logger.");
				var t = h[e];
				return t || (t = h[e] = new d(e, u.getLevel(), u.methodFactory)), t
			};
			var c = ("undefined" == typeof window ? "undefined" : _h(window)) !== t ? window.log : void 0;
			return u.noConflict = function () {
				return ("undefined" == typeof window ? "undefined" : _h(window)) !== t && window.log === u && (window.log = c), u
			}, u.getLoggers = function () {
				return h
			}, u.default = u, u
		}))
	}));

	function wh(e, t) {
		return null != t && "undefined" != typeof Symbol && t[Symbol.hasInstance] ? !!t[Symbol.hasInstance](e) : wh(e, t)
	}

	var Lh = bh((function () {
		Lh()
	})), Rh = yh((function (e) {
		var t = Object.prototype.hasOwnProperty;

		function i(e) {
			try {
				return decodeURIComponent(e.replace(/\+/g, " "))
			} catch {
				return null
			}
		}

		function a(e) {
			try {
				return encodeURIComponent(e)
			} catch {
				return null
			}
		}

		e.stringify = function (e, i) {
			i = i || "";
			var r, n, s = [];
			for (n in "string" != typeof i && (i = "?"), e) if (t.call(e, n)) {
				if (!(r = e[n]) && (null == r || isNaN(r)) && (r = ""), n = a(n), r = a(r), null === n || null === r) continue;
				s.push(n + "=" + r)
			}
			return s.length ? i + s.join("&") : ""
		}, e.parse = function (e) {
			for (var t, a = /([^=?#&]+)=?([^&]*)/g, r = {}; t = a.exec(e);) {
				var n = i(t[1]), s = i(t[2]);
				null === n || null === s || n in r || (r[n] = s)
			}
			return r
		}
	})), Ih = yh((function (e, t) {
		!function (i) {
			var a = !1;
			if ("function" == typeof define && define.amd && (define(i), a = !0), "object" == typeof e && (t.exports = i(), a = !0), !a) {
				var r = window.Cookies, n = window.Cookies = i();
				n.noConflict = function () {
					return window.Cookies = r, n
				}
			}
		}((function () {
			var e = function () {
				for (var e = 0, t = {}; e < arguments.length; e++) {
					var i = arguments[e];
					for (var a in i) t[a] = i[a]
				}
				return t
			};
			return function t(i) {
				function a(t, r, n) {
					var s;
					if ("undefined" != typeof document) {
						if (arguments.length > 1) {
							if ("number" == typeof (n = e({path: "/"}, a.defaults, n)).expires) {
								var o = new Date;
								o.setMilliseconds(o.getMilliseconds() + 864e5 * n.expires), n.expires = o
							}
							try {
								s = JSON.stringify(r), /^[\{\[]/.test(s) && (r = s)
							} catch {
							}
							return r = i.write ? i.write(r, t) : encodeURIComponent(String(r)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent), t = (t = (t = encodeURIComponent(String(t))).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)).replace(/[\(\)]/g, escape), document.cookie = [t, "=", r, n.expires ? "; expires=" + n.expires.toUTCString() : "", n.path ? "; path=" + n.path : "", n.domain ? "; domain=" + n.domain : "", n.secure ? "; secure" : ""].join("")
						}
						t || (s = {});
						for (var l = document.cookie ? document.cookie.split("; ") : [], d = /(%[0-9A-Z]{2})+/g, u = 0; u < l.length; u++) {
							var h = l[u].split("="), c = h.slice(1).join("=");
							'"' === c.charAt(0) && (c = c.slice(1, -1));
							try {
								var m = h[0].replace(d, decodeURIComponent);
								if (c = i.read ? i.read(c, m) : i(c, m) || c.replace(d, decodeURIComponent), this.json) try {
									c = JSON.parse(c)
								} catch {
								}
								if (t === m) {
									s = c;
									break
								}
								t || (s[m] = c)
							} catch {
							}
						}
						return s
					}
				}

				return a.set = a, a.get = function (e) {
					return a.call(a, e)
				}, a.getJSON = function () {
					return a.apply({json: !0}, [].slice.call(arguments))
				}, a.defaults = {}, a.remove = function (t, i) {
					a(t, "", e(i, {expires: -1}))
				}, a.withConverter = t, a
			}((function () {
			}))
		}))
	})), Dh = yh((function (e, t) {
		var i = Array.prototype.slice;
		t.exports = function (e, t) {
			for (("length" in e || (e = [e]), e = i.call(e)); e.length;) {
				var a = e.shift(), r = t(a);
				if (r) return r;
				a.childNodes && a.childNodes.length && (e = i.call(a.childNodes).concat(e))
			}
		}
	})), Ch = yh((function (e, t) {
		function i(e, t) {
			if (!wh(this, i)) return new i(e, t);
			this.data = e, this.nodeValue = e, this.length = e.length, this.ownerDocument = t || null
		}

		Lh(), t.exports = i, i.prototype.nodeType = 8, i.prototype.nodeName = "#comment", i.prototype.toString = function () {
			return "[object Comment]"
		}
	})), xh = yh((function (e, t) {
		function i(e, t) {
			if (!wh(this, i)) return new i(e);
			this.data = e || "", this.length = this.data.length, this.ownerDocument = t || null
		}

		Lh(), t.exports = i, i.prototype.type = "DOMTextNode", i.prototype.nodeType = 3, i.prototype.nodeName = "#text", i.prototype.toString = function () {
			return this.data
		}, i.prototype.replaceData = function (e, t, i) {
			var a = this.data, r = a.substring(0, e), n = a.substring(e + t, a.length);
			this.data = r + i + n, this.length = this.data.length
		}
	})), Mh = yh((function (e, t) {
		t.exports = function (e) {
			var t = this, i = e.type;
			e.target || (e.target = t), t.listeners || (t.listeners = {});
			var a = t.listeners[i];
			if (a) return a.forEach((function (i) {
				e.currentTarget = t, "function" == typeof i ? i(e) : i.handleEvent(e)
			}));
			t.parentNode && t.parentNode.dispatchEvent(e)
		}
	})), Oh = yh((function (e, t) {
		t.exports = function (e, t) {
			var i = this;
			i.listeners || (i.listeners = {}), i.listeners[e] || (i.listeners[e] = []), -1 === i.listeners[e].indexOf(t) && i.listeners[e].push(t)
		}
	})), Ph = yh((function (e, t) {
		t.exports = function (e, t) {
			var i = this;
			if (i.listeners && i.listeners[e]) {
				var a = i.listeners[e], r = a.indexOf(t);
				-1 !== r && a.splice(r, 1)
			}
		}
	})), Nh = yh((function (e, t) {
		kh(), t.exports = a;
		var i = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"];

		function a(e) {
			switch (e.nodeType) {
				case 3:
					return s(e.data);
				case 8:
					return "\x3c!--" + e.data + "--\x3e";
				default:
					return function (e) {
						var t = [], o = e.tagName;
						return "http://www.w3.org/1999/xhtml" === e.namespaceURI && (o = o.toLowerCase()), t.push("<" + o + function (e) {
							var t = [];
							for (var i in e) r(e, i) && t.push({name: i, value: e[i]});
							for (var a in e._attributes) for (var s in e._attributes[a]) {
								var o = e._attributes[a][s], l = (o.prefix ? o.prefix + ":" : "") + s;
								t.push({name: l, value: o.value})
							}
							return e.className && t.push({name: "class", value: e.className}), t.length ? n(t) : ""
						}(e) + function (e) {
							var t = e.dataset, i = [];
							for (var a in t) i.push({name: "data-" + a, value: t[a]});
							return i.length ? n(i) : ""
						}(e)), i.indexOf(o) > -1 ? t.push(" />") : (t.push(">"), e.childNodes.length ? t.push.apply(t, e.childNodes.map(a)) : e.textContent || e.innerText ? t.push(s(e.textContent || e.innerText)) : e.innerHTML && t.push(e.innerHTML), t.push("</" + o + ">")), t.join("")
					}(e)
			}
		}

		function r(e, t) {
			var i = _h(e[t]);
			return "style" === t && Object.keys(e.style).length > 0 || e.hasOwnProperty(t) && ("string" === i || "boolean" === i || "number" === i) && "nodeName" !== t && "className" !== t && "tagName" !== t && "textContent" !== t && "innerText" !== t && "namespaceURI" !== t && "innerHTML" !== t
		}

		function n(e) {
			var t = [];
			return e.forEach((function (e) {
				var i = e.name, a = e.value;
				"style" === i && (a = function (e) {
					if ("string" == typeof e) return e;
					var t = "";
					return Object.keys(e).forEach((function (i) {
						var a = e[i];
						i = i.replace(/[A-Z]/g, (function (e) {
							return "-" + e.toLowerCase()
						})), t += i + ":" + a + ";"
					})), t
				}(a)), t.push(i + '="' + function (e) {
					return s(e).replace(/"/g, "&quot;")
				}(a) + '"')
			})), t.length ? " " + t.join(" ") : ""
		}

		function s(e) {
			var t = "";
			return "string" == typeof e ? t = e : e && (t = e.toString()), t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
		}
	})), Uh = yh((function (e, t) {
		Lh();
		var i = Dh(), a = Mh(), r = Oh(), n = Ph(), s = Nh(), o = "http://www.w3.org/1999/xhtml";

		function l(e, t, i) {
			if (!wh(this, l)) return new l(e);
			var a = void 0 === i ? o : i || null;
			this.tagName = a === o ? String(e).toUpperCase() : e, this.nodeName = this.tagName, this.className = "", this.dataset = {}, this.childNodes = [], this.parentNode = null, this.style = {}, this.ownerDocument = t || null, this.namespaceURI = a, this._attributes = {}, "INPUT" === this.tagName && (this.type = "text")
		}

		t.exports = l, l.prototype.type = "DOMElement", l.prototype.nodeType = 1, l.prototype.appendChild = function (e) {
			return e.parentNode && e.parentNode.removeChild(e), this.childNodes.push(e), e.parentNode = this, e
		}, l.prototype.replaceChild = function (e, t) {
			e.parentNode && e.parentNode.removeChild(e);
			var i = this.childNodes.indexOf(t);
			return t.parentNode = null, this.childNodes[i] = e, e.parentNode = this, t
		}, l.prototype.removeChild = function (e) {
			var t = this.childNodes.indexOf(e);
			return this.childNodes.splice(t, 1), e.parentNode = null, e
		}, l.prototype.insertBefore = function (e, t) {
			e.parentNode && e.parentNode.removeChild(e);
			var i = null == t ? -1 : this.childNodes.indexOf(t);
			return i > -1 ? this.childNodes.splice(i, 0, e) : this.childNodes.push(e), e.parentNode = this, e
		}, l.prototype.setAttributeNS = function (e, t, i) {
			var a = null, r = t, n = t.indexOf(":");
			(n > -1 && (a = t.substr(0, n), r = t.substr(n + 1)), "INPUT" === this.tagName && "type" === t) ? this.type = i : (this._attributes[e] || (this._attributes[e] = {}))[r] = {
				value: i,
				prefix: a
			}
		}, l.prototype.getAttributeNS = function (e, t) {
			var i = this._attributes[e], a = i && i[t] && i[t].value;
			return "INPUT" === this.tagName && "type" === t ? this.type : "string" != typeof a ? null : a
		}, l.prototype.removeAttributeNS = function (e, t) {
			var i = this._attributes[e];
			i && delete i[t]
		}, l.prototype.hasAttributeNS = function (e, t) {
			var i = this._attributes[e];
			return !!i && t in i
		}, l.prototype.setAttribute = function (e, t) {
			return this.setAttributeNS(null, e, t)
		}, l.prototype.getAttribute = function (e) {
			return this.getAttributeNS(null, e)
		}, l.prototype.removeAttribute = function (e) {
			return this.removeAttributeNS(null, e)
		}, l.prototype.hasAttribute = function (e) {
			return this.hasAttributeNS(null, e)
		}, l.prototype.removeEventListener = n, l.prototype.addEventListener = r, l.prototype.dispatchEvent = a, l.prototype.focus = function () {
		}, l.prototype.toString = function () {
			return s(this)
		}, l.prototype.getElementsByClassName = function (e) {
			var t = e.split(" "), a = [];
			return i(this, (function (e) {
				if (1 === e.nodeType) {
					var i = (e.className || "").split(" ");
					t.every((function (e) {
						return -1 !== i.indexOf(e)
					})) && a.push(e)
				}
			})), a
		}, l.prototype.getElementsByTagName = function (e) {
			e = e.toLowerCase();
			var t = [];
			return i(this.childNodes, (function (i) {
				1 === i.nodeType && ("*" === e || i.tagName.toLowerCase() === e) && t.push(i)
			})), t
		}, l.prototype.contains = function (e) {
			return i(this, (function (t) {
				return e === t
			})) || !1
		}
	})), Fh = yh((function (e, t) {
		Lh();
		var i = Uh();

		function a(e) {
			if (!wh(this, a)) return new a;
			this.childNodes = [], this.parentNode = null, this.ownerDocument = e || null
		}

		t.exports = a, a.prototype.type = "DocumentFragment", a.prototype.nodeType = 11, a.prototype.nodeName = "#document-fragment", a.prototype.appendChild = i.prototype.appendChild, a.prototype.replaceChild = i.prototype.replaceChild, a.prototype.removeChild = i.prototype.removeChild, a.prototype.toString = function () {
			return this.childNodes.map((function (e) {
				return String(e)
			})).join("")
		}
	})), Bh = yh((function (e, t) {
		function i(e) {
		}

		t.exports = i, i.prototype.initEvent = function (e, t, i) {
			this.type = e, this.bubbles = t, this.cancelable = i
		}, i.prototype.preventDefault = function () {
		}
	})), $h = yh((function (e, t) {
		Lh();
		var i = Dh(), a = Ch(), r = xh(), n = Uh(), s = Fh(), o = Bh(), l = Mh(), d = Oh(), u = Ph();

		function h() {
			if (!wh(this, h)) return new h;
			this.head = this.createElement("head"), this.body = this.createElement("body"), this.documentElement = this.createElement("html"), this.documentElement.appendChild(this.head), this.documentElement.appendChild(this.body), this.childNodes = [this.documentElement], this.nodeType = 9
		}

		t.exports = h;
		var c = h.prototype;
		c.createTextNode = function (e) {
			return new r(e, this)
		}, c.createElementNS = function (e, t) {
			var i = null === e ? null : String(e);
			return new n(t, this, i)
		}, c.createElement = function (e) {
			return new n(e, this)
		}, c.createDocumentFragment = function () {
			return new s(this)
		}, c.createEvent = function (e) {
			return new o(e)
		}, c.createComment = function (e) {
			return new a(e, this)
		}, c.getElementById = function (e) {
			return e = String(e), i(this.childNodes, (function (t) {
				if (String(t.id) === e) return t
			})) || null
		}, c.getElementsByClassName = n.prototype.getElementsByClassName, c.getElementsByTagName = n.prototype.getElementsByTagName, c.contains = n.prototype.contains, c.removeEventListener = u, c.addEventListener = d, c.dispatchEvent = l
	})), Hh = yh((function (e, t) {
		var i = $h();
		t.exports = new i
	})), Wh = yh((function (e, t) {
		var i, a = "undefined" != typeof global ? global : "undefined" != typeof window ? window : {}, r = Hh();
		"undefined" != typeof document ? i = document : (i = a["__GLOBAL_DOCUMENT_CACHE@4"]) || (i = a["__GLOBAL_DOCUMENT_CACHE@4"] = r), t.exports = i
	}));

	function Gh(e, t) {
		(null == t || t > e.length) && (t = e.length);
		for (var i = 0, a = new Array(t); i < t; i++) a[i] = e[i];
		return a
	}

	function Vh(e, t) {
		return function (e) {
			if (Array.isArray(e)) return e
		}(e) || function (e, t) {
			var i = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
			if (null != i) {
				var a, r, n = [], s = !0, o = !1;
				try {
					for (i = i.call(e); !(s = (a = i.next()).done) && (n.push(a.value), !t || n.length !== t); s = !0) ;
				} catch (e) {
					o = !0, r = e
				} finally {
					try {
						!s && null != i.return && i.return()
					} finally {
						if (o) throw r
					}
				}
				return n
			}
		}(e, t) || function (e, t) {
			if (e) {
				if ("string" == typeof e) return Gh(e, t);
				var i = Object.prototype.toString.call(e).slice(8, -1);
				if ("Object" === i && e.constructor && (i = e.constructor.name), "Map" === i || "Set" === i) return Array.from(i);
				if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return Gh(e, t)
			}
		}(e, t) || function () {
			throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
		}()
	}

	var Kh = Th(Ah()), qh = function () {
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function (e) {
			var t = 16 * Math.random() | 0;
			return ("x" === e ? t : 3 & t | 8).toString(16)
		}))
	}, Yh = function () {
		return ("000000" + (Math.random() * Math.pow(36, 6) << 0).toString(36)).slice(-6)
	}, jh = function (e) {
		if (e && void 0 !== e.nodeName) return e.muxId || (e.muxId = Yh()), e.muxId;
		var t;
		try {
			t = document.querySelector(e)
		} catch {
		}
		return t && !t.muxId && (t.muxId = e), (null == t ? void 0 : t.muxId) || e
	}, zh = function (e) {
		var t;
		e && void 0 !== e.nodeName ? e = jh(t = e) : t = document.querySelector(e);
		var i = t && t.nodeName ? t.nodeName.toLowerCase() : "";
		return [t, e, i]
	}, Xh = Th(Sh()), Qh = Xh.default.methodFactory;
	Xh.default.methodFactory = function (e, t, i) {
		var a = Qh(e, t, i);
		return function () {
			for (var e = ["[mux]"], t = 0; t < arguments.length; t++) e.push(arguments[t]);
			a.apply(void 0, e)
		}
	}, Xh.default.setLevel(Xh.default.getLevel());
	var Zh = Xh.default, Jh = Th(Ah());

	function ec() {
		return "1" === (Jh.default.doNotTrack || Jh.default.navigator && Jh.default.navigator.doNotTrack)
	}

	var tc = Th(Ah()), ic = {
		now: function () {
			var e = tc.default.performance, t = e && e.timing, i = t && t.navigationStart,
				a = "number" == typeof i && "function" == typeof e.now ? i + e.now() : Date.now();
			return Math.round(a)
		}
	}, ac = ic;

	function rc(e) {
		if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e
	}

	function nc(e, t) {
		if (!wh(e, t)) throw new TypeError("Cannot call a class as a function")
	}

	function sc(e, t) {
		for (var i = 0; i < t.length; i++) {
			var a = t[i];
			a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a)
		}
	}

	function oc(e, t, i) {
		return t && sc(e.prototype, t), i && sc(e, i), e
	}

	function lc(e, t, i) {
		return t in e ? Object.defineProperty(e, t, {
			value: i,
			enumerable: !0,
			configurable: !0,
			writable: !0
		}) : e[t] = i, e
	}

	function dc(e, t) {
		return dc = Object.setPrototypeOf || function (e, t) {
			return e.__proto__ = t, e
		}, dc(e, t)
	}

	function uc(e) {
		return uc = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
			return e.__proto__ || Object.getPrototypeOf(e)
		}, uc(e)
	}

	function hc(e) {
		var t = function () {
			if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return !1;
			if ("function" == typeof Proxy) return !0;
			try {
				return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
				}))), !0
			} catch {
				return !1
			}
		}();
		return function () {
			var i, a = uc(e);
			if (t) {
				var r = uc(this).constructor;
				i = Reflect.construct(a, arguments, r)
			} else i = a.apply(this, arguments);
			return function (e, t) {
				return !t || "object" !== _h(t) && "function" != typeof t ? rc(e) : t
			}(this, i)
		}
	}

	Lh(), kh();
	var cc = function (e) {
		return mc(e)[0]
	}, mc = function (e) {
		if ("string" != typeof e || "" === e) return ["localhost"];
		var t, i = (e.match(/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/) || [])[4];
		return i && (t = (i.match(/[^\.]+\.[^\.]+$/) || [])[0]), [i, t]
	}, fc = Th(Ah()), pc = {
		exists: function () {
			var e = fc.default.performance;
			return void 0 !== (e && e.timing)
		}, domContentLoadedEventEnd: function () {
			var e = fc.default.performance, t = e && e.timing;
			return t && t.domContentLoadedEventEnd
		}, navigationStart: function () {
			var e = fc.default.performance, t = e && e.timing;
			return t && t.navigationStart
		}
	}, gc = pc;

	function vc(e, t, i) {
		i = void 0 === i ? 1 : i, e[t] = e[t] || 0, e[t] += i
	}

	function Ec(e) {
		for (var t = 1; t < arguments.length; t++) {
			var i = null != arguments[t] ? arguments[t] : {}, a = Object.keys(i);
			"function" == typeof Object.getOwnPropertySymbols && (a = a.concat(Object.getOwnPropertySymbols(i).filter((function (e) {
				return Object.getOwnPropertyDescriptor(i, e).enumerable
			})))), a.forEach((function (t) {
				lc(e, t, i[t])
			}))
		}
		return e
	}

	function bc(e, t) {
		return t = null != t ? t : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : function (e, t) {
			var i = Object.keys(e);
			if (Object.getOwnPropertySymbols) {
				var a = Object.getOwnPropertySymbols(e);
				t && (a = a.filter((function (t) {
					return Object.getOwnPropertyDescriptor(e, t).enumerable
				}))), i.push.apply(i, a)
			}
			return i
		}(Object(t)).forEach((function (i) {
			Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(t, i))
		})), e
	}

	var yc = ["x-request-id", "cf-ray", "x-amz-cf-id", "x-akamai-request-id"],
		Tc = ["x-cdn", "content-type"].concat(yc);

	function Ac(e) {
		var t = {};
		return (e = e || "").trim().split(/[\r\n]+/).forEach((function (e) {
			if (e) {
				var i = e.split(": "), a = i.shift();
				a && (Tc.indexOf(a.toLowerCase()) >= 0 || 0 === a.toLowerCase().indexOf("x-litix-")) && (t[a] = i.join(": "))
			}
		})), t
	}

	function _c(e) {
		if (e) {
			var t = yc.find((function (t) {
				return void 0 !== e[t]
			}));
			return t ? e[t] : void 0
		}
	}

	var kc = function (e) {
			var t = {};
			for (var i in e) {
				var a = e[i];
				if (-1 !== a["DATA-ID"].search("io.litix.data.")) t[a["DATA-ID"].replace("io.litix.data.", "")] = a.VALUE
			}
			return t
		}, Sc = function (e) {
			if (!e) return {};
			var t = gc.navigationStart(), i = e.loading, a = i ? i.start : e.trequest, r = i ? i.first : e.tfirst,
				n = i ? i.end : e.tload;
			return {
				bytesLoaded: e.total,
				requestStart: Math.round(t + a),
				responseStart: Math.round(t + r),
				responseEnd: Math.round(t + n)
			}
		}, wc = function (e) {
			if (e && "function" == typeof e.getAllResponseHeaders) return Ac(e.getAllResponseHeaders())
		}, Lc = function (e, t) {
			if (!e || !e.requestEndDate) return {};
			var i, a = cc(e.url), r = e.url, n = e.bytesLoaded, s = new Date(e.requestStartDate).getTime(),
				o = new Date(e.firstByteDate).getTime(), l = new Date(e.requestEndDate).getTime(),
				d = isNaN(e.duration) ? 0 : e.duration,
				u = "function" == typeof t.getMetricsFor ? t.getMetricsFor(e.mediaType).HttpList : t.getDashMetrics().getHttpRequests(e.mediaType);
			return u.length > 0 && (i = Ac(u[u.length - 1]._responseHeaders || "")), {
				requestStart: s,
				requestResponseStart: o,
				requestResponseEnd: l,
				requestBytesLoaded: n,
				requestResponseHeaders: i,
				requestMediaDuration: d,
				requestHostname: a,
				requestUrl: r,
				requestId: i ? _c(i) : void 0
			}
		}, Rc = function (e) {
			var t;
			return null === (t = e.match(/.*codecs\*?="(.*)"/)) || void 0 === t ? void 0 : t[1]
		}, Ic = function (e, t, i) {
			var a = e.log;
			if (i && i.on) {
				var r = function (e) {
					try {
						var t, i;
						return null === (i = e.getVersion) || void 0 === i || null === (t = i.call(e)) || void 0 === t ? void 0 : t.split(".").map((function (e) {
							return parseInt(e)
						}))[0]
					} catch {
						return !1
					}
				}(i), n = function (i, a) {
					return e.emit(t, i, a)
				}, s = function (e) {
					var t = e.type, i = (e.data || {}).url;
					n("requestcompleted", {
						request_event_type: t,
						request_start: 0,
						request_response_start: 0,
						request_response_end: 0,
						request_bytes_loaded: -1,
						request_type: "manifest",
						request_hostname: cc(i),
						request_url: i
					})
				};
				i.on("manifestLoaded", s);
				var o = {}, l = function (e) {
					if ("function" != typeof e.getRequests) return null;
					var t = e.getRequests({state: "executed"});
					return 0 === t.length ? null : t[t.length - 1]
				}, d = function (e) {
					var t = e.type, a = e.chunk, r = e.request, s = (a || {}).mediaInfo || {}, l = s.type,
						d = s.bitrateList, u = {};
					(d = d || []).forEach((function (e, t) {
						u[t] = {}, u[t].width = e.width, u[t].height = e.height, u[t].bitrate = e.bandwidth, u[t].attrs = {}
					})), "video" === l ? o.video = u : "audio" === l ? o.audio = u : o.media = u;
					var h = Lc(r, i), c = h.requestStart, m = h.requestResponseStart, f = h.requestResponseEnd,
						p = h.requestResponseHeaders, g = h.requestMediaDuration, v = h.requestHostname, E = h.requestUrl,
						b = h.requestId;
					n("requestcompleted", {
						request_event_type: t,
						request_start: c,
						request_response_start: m,
						request_response_end: f,
						request_bytes_loaded: -1,
						request_type: l + "_init",
						request_response_headers: p,
						request_hostname: v,
						request_id: b,
						request_url: E,
						request_media_duration: g,
						request_rendition_lists: o
					})
				};
				r >= 4 ? i.on("initFragmentLoaded", d) : i.on("initFragmentLoaded", (function (e) {
					var t = e.type, i = e.fragmentModel, a = e.chunk, r = l(i);
					d({type: t, request: r, chunk: a})
				}));
				var u = function (e) {
					var t = e.type, a = e.chunk, r = e.request, s = a || {}, o = s.mediaInfo, l = s.start,
						d = (o || {}).type, u = Lc(r, i), h = u.requestStart, c = u.requestResponseStart,
						m = u.requestResponseEnd, f = u.requestBytesLoaded, p = u.requestResponseHeaders,
						g = u.requestMediaDuration, v = u.requestHostname, E = u.requestUrl, b = u.requestId,
						y = function (e, t) {
							var i = t.getQualityFor(e), a = t.getCurrentTrackFor(e).bitrateList;
							return a ? {
								currentLevel: i,
								renditionWidth: a[i].width || null,
								renditionHeight: a[i].height || null,
								renditionBitrate: a[i].bandwidth
							} : {}
						}(d, i), T = y.currentLevel, A = y.renditionWidth, _ = y.renditionHeight, k = y.renditionBitrate;
					n("requestcompleted", {
						request_event_type: t,
						request_start: h,
						request_response_start: c,
						request_response_end: m,
						request_bytes_loaded: f,
						request_type: d,
						request_response_headers: p,
						request_hostname: v,
						request_id: b,
						request_url: E,
						request_media_start_time: l,
						request_media_duration: g,
						request_current_level: T,
						request_labeled_bitrate: k,
						request_video_width: A,
						request_video_height: _
					})
				};
				r >= 4 ? i.on("mediaFragmentLoaded", u) : i.on("mediaFragmentLoaded", (function (e) {
					var t = e.type, i = e.fragmentModel, a = e.chunk, r = l(i);
					u({type: t, request: r, chunk: a})
				}));
				var h = {video: void 0, audio: void 0, totalBitrate: void 0}, c = function (e, t, r) {
					if ("number" == typeof e.newQuality) {
						var s = e.mediaType;
						if ("audio" === s || "video" === s) {
							var o = i.getBitrateInfoListFor(s).find((function (t) {
								return t.qualityIndex === e.newQuality
							}));
							if (!o || "number" != typeof o.bitrate) return void a.warn("missing bitrate info for ".concat(s));
							h[s] = bc(Ec({}, o), {codec: i.getCurrentTrackFor(s).codec});
							var l = function () {
								if (h.video && "number" == typeof h.video.bitrate) {
									if (!h.video.width || !h.video.height) return void a.warn("have bitrate info for video but missing width/height");
									var e = h.video.bitrate;
									if (h.audio && "number" == typeof h.audio.bitrate && (e += h.audio.bitrate), e !== h.totalBitrate) return h.totalBitrate = e, {
										video_source_bitrate: e,
										video_source_height: h.video.height,
										video_source_width: h.video.width,
										video_source_codec: Rc(h.video.codec)
									}
								}
							}();
							l && n("renditionchange", l)
						}
					} else a.warn("missing evt.newQuality in qualityChangeRendered event", e)
				};
				i.on("qualityChangeRendered", c);
				var m = function (e) {
					var t = e.request, i = e.mediaType;
					n("requestcanceled", {
						request_event_type: (t = t || {}).type + "_" + t.action,
						request_url: t.url,
						request_type: i,
						request_hostname: cc(t.url)
					})
				};
				i.on("fragmentLoadingAbandoned", m);
				var f = function (e) {
					var t, i, a = e.error,
						r = (null == a || null === (t = a.data) || void 0 === t ? void 0 : t.request) || {},
						s = (null == a || null === (i = a.data) || void 0 === i ? void 0 : i.response) || {};
					27 === (null == a ? void 0 : a.code) && n("requestfailed", {
						request_error: r.type + "_" + r.action,
						request_url: r.url,
						request_hostname: cc(r.url),
						request_type: r.mediaType,
						request_error_code: s.status,
						request_error_text: s.statusText
					});
					var o = "".concat(null != r && r.url ? "url: ".concat(r.url, "\n") : "") + "".concat(null != s && s.status || null != s && s.statusText ? "response: ".concat(null == s ? void 0 : s.status, ", ").concat(null == s ? void 0 : s.statusText, "\n") : "");
					n("error", {
						player_error_code: null == a ? void 0 : a.code,
						player_error_message: null == a ? void 0 : a.message,
						player_error_context: o
					})
				};
				i.on("error", f), i._stopMuxMonitor = function () {
					i.off("manifestLoaded", s), i.off("initFragmentLoaded", d), i.off("mediaFragmentLoaded", u), i.off("qualityChangeRendered", c), i.off("error", f), i.off("fragmentLoadingAbandoned", m), delete i._stopMuxMonitor
				}
			} else a.warn("Invalid dash.js player reference. Monitoring blocked.")
		}, Dc = 0, Cc = function () {
			function e() {
				nc(this, e), lc(this, "_listeners", void 0)
			}

			return oc(e, [{
				key: "on", value: function (e, t, i) {
					return t._eventEmitterGuid = t._eventEmitterGuid || ++Dc, this._listeners = this._listeners || {}, this._listeners[e] = this._listeners[e] || [], i && (t = t.bind(i)), this._listeners[e].push(t), t
				}
			}, {
				key: "off", value: function (e, t) {
					var i = this._listeners && this._listeners[e];
					i && i.forEach((function (e, a) {
						e._eventEmitterGuid === t._eventEmitterGuid && i.splice(a, 1)
					}))
				}
			}, {
				key: "one", value: function (e, t, i) {
					var a = this;
					t._eventEmitterGuid = t._eventEmitterGuid || ++Dc;
					var r = function () {
						a.off(e, r), t.apply(i || this, arguments)
					};
					r._eventEmitterGuid = t._eventEmitterGuid, this.on(e, r)
				}
			}, {
				key: "emit", value: function (e, t) {
					var i = this;
					if (this._listeners) {
						t = t || {};
						var a = this._listeners["before*"] || [], r = this._listeners[e] || [],
							n = this._listeners["after" + e] || [], s = function (t, a) {
								(t = t.slice()).forEach((function (t) {
									t.call(i, {type: e}, a)
								}))
							};
						s(a, t), s(r, t), s(n, t)
					}
				}
			}]), e
		}(), xc = Cc, Mc = Th(Ah()), Oc = function () {
			function e(t) {
				var i = this;
				nc(this, e), lc(this, "_playbackHeartbeatInterval", void 0), lc(this, "_playheadShouldBeProgressing", void 0), lc(this, "pm", void 0), this.pm = t, this._playbackHeartbeatInterval = null, this._playheadShouldBeProgressing = !1, t.on("playing", (function () {
					i._playheadShouldBeProgressing = !0
				})), t.on("play", this._startPlaybackHeartbeatInterval.bind(this)), t.on("playing", this._startPlaybackHeartbeatInterval.bind(this)), t.on("adbreakstart", this._startPlaybackHeartbeatInterval.bind(this)), t.on("adplay", this._startPlaybackHeartbeatInterval.bind(this)), t.on("adplaying", this._startPlaybackHeartbeatInterval.bind(this)), t.on("devicewake", this._startPlaybackHeartbeatInterval.bind(this)), t.on("viewstart", this._startPlaybackHeartbeatInterval.bind(this)), t.on("rebufferstart", this._startPlaybackHeartbeatInterval.bind(this)), t.on("pause", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("ended", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("viewend", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("error", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("aderror", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("adpause", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("adended", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("adbreakend", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("seeked", (function () {
					t.data.player_is_paused ? i._stopPlaybackHeartbeatInterval() : i._startPlaybackHeartbeatInterval()
				})), t.on("timeupdate", (function () {
					null !== i._playbackHeartbeatInterval && t.emit("playbackheartbeat")
				})), t.on("devicesleep", (function (e, a) {
					null !== i._playbackHeartbeatInterval && (Mc.default.clearInterval(i._playbackHeartbeatInterval), t.emit("playbackheartbeatend", {viewer_time: a.viewer_time}), i._playbackHeartbeatInterval = null)
				}))
			}

			return oc(e, [{
				key: "_startPlaybackHeartbeatInterval", value: function () {
					var e = this;
					null === this._playbackHeartbeatInterval && (this.pm.emit("playbackheartbeat"), this._playbackHeartbeatInterval = Mc.default.setInterval((function () {
						e.pm.emit("playbackheartbeat")
					}), this.pm.playbackHeartbeatTime))
				}
			}, {
				key: "_stopPlaybackHeartbeatInterval", value: function () {
					this._playheadShouldBeProgressing = !1, null !== this._playbackHeartbeatInterval && (Mc.default.clearInterval(this._playbackHeartbeatInterval), this.pm.emit("playbackheartbeatend"), this._playbackHeartbeatInterval = null)
				}
			}]), e
		}(), Pc = Oc, Nc = function e(t) {
			var i = this;
			nc(this, e), lc(this, "viewErrored", void 0), t.on("viewinit", (function () {
				i.viewErrored = !1
			})), t.on("error", (function (e, a) {
				try {
					var r = t.errorTranslator({
						player_error_code: a.player_error_code,
						player_error_message: a.player_error_message,
						player_error_context: a.player_error_context,
						player_error_severity: a.player_error_severity,
						player_error_business_exception: a.player_error_business_exception
					});
					r && (t.data.player_error_code = r.player_error_code || a.player_error_code, t.data.player_error_message = r.player_error_message || a.player_error_message, t.data.player_error_context = r.player_error_context || a.player_error_context, t.data.player_error_severity = r.player_error_severity || a.player_error_severity, t.data.player_error_business_exception = r.player_error_business_exception || a.player_error_business_exception, i.viewErrored = !0)
				} catch (e) {
					t.mux.log.warn("Exception in error translator callback.", e), i.viewErrored = !0
				}
			})), t.on("aftererror", (function () {
				var e, i, a, r, n;
				null === (e = t.data) || void 0 === e || delete e.player_error_code, null === (i = t.data) || void 0 === i || delete i.player_error_message, null === (a = t.data) || void 0 === a || delete a.player_error_context, null === (r = t.data) || void 0 === r || delete r.player_error_severity, null === (n = t.data) || void 0 === n || delete n.player_error_business_exception
			}))
		}, Uc = function () {
			function e(t) {
				nc(this, e), lc(this, "_watchTimeTrackerLastCheckedTime", void 0), lc(this, "pm", void 0), this.pm = t, this._watchTimeTrackerLastCheckedTime = null, t.on("playbackheartbeat", this._updateWatchTime.bind(this)), t.on("playbackheartbeatend", this._clearWatchTimeState.bind(this))
			}

			return oc(e, [{
				key: "_updateWatchTime", value: function (e, t) {
					var i = t.viewer_time;
					null === this._watchTimeTrackerLastCheckedTime && (this._watchTimeTrackerLastCheckedTime = i), vc(this.pm.data, "view_watch_time", i - this._watchTimeTrackerLastCheckedTime), this._watchTimeTrackerLastCheckedTime = i
				}
			}, {
				key: "_clearWatchTimeState", value: function (e, t) {
					this._updateWatchTime(e, t), this._watchTimeTrackerLastCheckedTime = null
				}
			}]), e
		}(), Fc = Uc, Bc = function () {
			function e(t) {
				var i = this;
				nc(this, e), lc(this, "_playbackTimeTrackerLastPlayheadPosition", void 0), lc(this, "_lastTime", void 0), lc(this, "_isAdPlaying", void 0), lc(this, "_callbackUpdatePlaybackTime", void 0), lc(this, "pm", void 0), this.pm = t, this._playbackTimeTrackerLastPlayheadPosition = -1, this._lastTime = ac.now(), this._isAdPlaying = !1, this._callbackUpdatePlaybackTime = null;
				var a = this._startPlaybackTimeTracking.bind(this);
				t.on("playing", a), t.on("adplaying", a), t.on("seeked", a);
				var r = this._stopPlaybackTimeTracking.bind(this);
				t.on("playbackheartbeatend", r), t.on("seeking", r), t.on("adplaying", (function () {
					i._isAdPlaying = !0
				})), t.on("adended", (function () {
					i._isAdPlaying = !1
				})), t.on("adpause", (function () {
					i._isAdPlaying = !1
				})), t.on("adbreakstart", (function () {
					i._isAdPlaying = !1
				})), t.on("adbreakend", (function () {
					i._isAdPlaying = !1
				})), t.on("adplay", (function () {
					i._isAdPlaying = !1
				})), t.on("viewinit", (function () {
					i._playbackTimeTrackerLastPlayheadPosition = -1, i._lastTime = ac.now(), i._isAdPlaying = !1, i._callbackUpdatePlaybackTime = null
				}))
			}

			return oc(e, [{
				key: "_startPlaybackTimeTracking", value: function () {
					null === this._callbackUpdatePlaybackTime && (this._callbackUpdatePlaybackTime = this._updatePlaybackTime.bind(this), this._playbackTimeTrackerLastPlayheadPosition = this.pm.data.player_playhead_time, this.pm.on("playbackheartbeat", this._callbackUpdatePlaybackTime))
				}
			}, {
				key: "_stopPlaybackTimeTracking", value: function () {
					this._callbackUpdatePlaybackTime && (this._updatePlaybackTime(), this.pm.off("playbackheartbeat", this._callbackUpdatePlaybackTime), this._callbackUpdatePlaybackTime = null, this._playbackTimeTrackerLastPlayheadPosition = -1)
				}
			}, {
				key: "_updatePlaybackTime", value: function () {
					var e = this.pm.data.player_playhead_time, t = ac.now(), i = -1;
					this._playbackTimeTrackerLastPlayheadPosition >= 0 && e > this._playbackTimeTrackerLastPlayheadPosition ? i = e - this._playbackTimeTrackerLastPlayheadPosition : this._isAdPlaying && (i = t - this._lastTime), i > 0 && i <= 1e3 && vc(this.pm.data, "view_content_playback_time", i), this._playbackTimeTrackerLastPlayheadPosition = e, this._lastTime = t
				}
			}]), e
		}(), $c = Bc, Hc = function () {
			function e(t) {
				nc(this, e), lc(this, "pm", void 0), this.pm = t;
				var i = this._updatePlayheadTime.bind(this);
				t.on("playbackheartbeat", i), t.on("playbackheartbeatend", i), t.on("timeupdate", i), t.on("destroy", (function () {
					t.off("timeupdate", i)
				}))
			}

			return oc(e, [{
				key: "_updateMaxPlayheadPosition", value: function () {
					this.pm.data.view_max_playhead_position = void 0 === this.pm.data.view_max_playhead_position ? this.pm.data.player_playhead_time : Math.max(this.pm.data.view_max_playhead_position, this.pm.data.player_playhead_time)
				}
			}, {
				key: "_updatePlayheadTime", value: function (e, t) {
					var i = this, a = function () {
						i.pm.currentFragmentPDT && i.pm.currentFragmentStart && (i.pm.data.player_program_time = i.pm.currentFragmentPDT + i.pm.data.player_playhead_time - i.pm.currentFragmentStart)
					};
					if (t && t.player_playhead_time) this.pm.data.player_playhead_time = t.player_playhead_time, a(), this._updateMaxPlayheadPosition(); else if (this.pm.getPlayheadTime) {
						var r = this.pm.getPlayheadTime();
						void 0 !== r && (this.pm.data.player_playhead_time = r, a(), this._updateMaxPlayheadPosition())
					}
				}
			}]), e
		}(), Wc = Hc, Gc = 3e5, Vc = function e(t) {
			if (nc(this, e), !t.disableRebufferTracking) {
				var i, a = function (e, t) {
					r(t), i = void 0
				}, r = function (e) {
					if (i) {
						var a = e.viewer_time - i;
						vc(t.data, "view_rebuffer_duration", a), i = e.viewer_time, t.data.view_rebuffer_duration > Gc && (t.emit("viewend"), t.send("viewend"), t.mux.log.warn("Ending view after rebuffering for longer than ".concat(Gc, "ms, future events will be ignored unless a programchange or videochange occurs.")))
					}
					t.data.view_watch_time >= 0 && t.data.view_rebuffer_count > 0 && (t.data.view_rebuffer_frequency = t.data.view_rebuffer_count / t.data.view_watch_time, t.data.view_rebuffer_percentage = t.data.view_rebuffer_duration / t.data.view_watch_time)
				};
				t.on("playbackheartbeat", (function (e, t) {
					return r(t)
				})), t.on("rebufferstart", (function (e, r) {
					i || (vc(t.data, "view_rebuffer_count", 1), i = r.viewer_time, t.one("rebufferend", a))
				})), t.on("viewinit", (function () {
					i = void 0, t.off("rebufferend", a)
				}))
			}
		}, Kc = function () {
			function e(t) {
				var i = this;
				nc(this, e), lc(this, "_lastCheckedTime", void 0), lc(this, "_lastPlayheadTime", void 0), lc(this, "_lastPlayheadTimeUpdatedTime", void 0), lc(this, "_rebuffering", void 0), lc(this, "pm", void 0), this.pm = t, !t.disableRebufferTracking && !t.disablePlayheadRebufferTracking && (this._lastCheckedTime = null, this._lastPlayheadTime = null, this._lastPlayheadTimeUpdatedTime = null, t.on("playbackheartbeat", this._checkIfRebuffering.bind(this)), t.on("playbackheartbeatend", this._cleanupRebufferTracker.bind(this)), t.on("seeking", (function () {
					i._cleanupRebufferTracker(null, {viewer_time: ac.now()})
				})))
			}

			return oc(e, [{
				key: "_checkIfRebuffering", value: function (e, t) {
					if (this.pm.seekingTracker.isSeeking || this.pm.adTracker.isAdBreak || !this.pm.playbackHeartbeat._playheadShouldBeProgressing) this._cleanupRebufferTracker(e, t); else if (null !== this._lastCheckedTime) if (this._lastPlayheadTime === this.pm.data.player_playhead_time) {
						var i = t.viewer_time - this._lastPlayheadTimeUpdatedTime;
						"number" == typeof this.pm.sustainedRebufferThreshold && i >= this.pm.sustainedRebufferThreshold && (this._rebuffering || (this._rebuffering = !0, this.pm.emit("rebufferstart", {viewer_time: this._lastPlayheadTimeUpdatedTime}))), this._lastCheckedTime = t.viewer_time
					} else this._cleanupRebufferTracker(e, t, !0); else this._prepareRebufferTrackerState(t.viewer_time)
				}
			}, {
				key: "_clearRebufferTrackerState", value: function () {
					this._lastCheckedTime = null, this._lastPlayheadTime = null, this._lastPlayheadTimeUpdatedTime = null
				}
			}, {
				key: "_prepareRebufferTrackerState", value: function (e) {
					this._lastCheckedTime = e, this._lastPlayheadTime = this.pm.data.player_playhead_time, this._lastPlayheadTimeUpdatedTime = e
				}
			}, {
				key: "_cleanupRebufferTracker", value: function (e, t) {
					var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					if (this._rebuffering) this._rebuffering = !1, this.pm.emit("rebufferend", {viewer_time: t.viewer_time}); else {
						if (null === this._lastCheckedTime) return;
						var a = this.pm.data.player_playhead_time - this._lastPlayheadTime,
							r = t.viewer_time - this._lastPlayheadTimeUpdatedTime;
						"number" == typeof this.pm.minimumRebufferDuration && a > 0 && r - a > this.pm.minimumRebufferDuration && (this._lastCheckedTime = null, this.pm.emit("rebufferstart", {viewer_time: this._lastPlayheadTimeUpdatedTime}), this.pm.emit("rebufferend", {viewer_time: this._lastPlayheadTimeUpdatedTime + r - a}))
					}
					i ? this._prepareRebufferTrackerState(t.viewer_time) : this._clearRebufferTrackerState()
				}
			}]), e
		}(), qc = Kc, Yc = function () {
			function e(t) {
				var i = this;
				nc(this, e), lc(this, "NAVIGATION_START", void 0), lc(this, "pm", void 0), this.pm = t, t.on("viewinit", (function () {
					var e = t.data, a = e.view_id;
					if (!e.view_program_changed) {
						var r = function (e, r) {
							var n = r.viewer_time;
							("playing" === e.type && void 0 === t.data.view_time_to_first_frame || "adplaying" === e.type && (void 0 === t.data.view_time_to_first_frame || i._inPrerollPosition())) && i.calculateTimeToFirstFrame(n || ac.now(), a)
						};
						t.one("playing", r), t.one("adplaying", r), t.one("viewend", (function () {
							t.off("playing", r), t.off("adplaying", r)
						}))
					}
				}))
			}

			return oc(e, [{
				key: "_inPrerollPosition", value: function () {
					return void 0 === this.pm.data.view_content_playback_time || this.pm.data.view_content_playback_time <= 1e3
				}
			}, {
				key: "calculateTimeToFirstFrame", value: function (e, t) {
					t === this.pm.data.view_id && (this.pm.watchTimeTracker._updateWatchTime(null, {viewer_time: e}), this.pm.data.view_time_to_first_frame = this.pm.data.view_watch_time, (this.pm.data.player_autoplay_on || this.pm.data.video_is_autoplay) && this.NAVIGATION_START && (this.pm.data.view_aggregate_startup_time = this.pm.data.view_start + this.pm.data.view_watch_time - this.NAVIGATION_START))
				}
			}]), e
		}(), jc = Yc, zc = function e(t) {
			var i = this;
			nc(this, e), lc(this, "_lastPlayerHeight", void 0), lc(this, "_lastPlayerWidth", void 0), lc(this, "_lastPlayheadPosition", void 0), lc(this, "_lastSourceHeight", void 0), lc(this, "_lastSourceWidth", void 0), t.on("viewinit", (function () {
				i._lastPlayheadPosition = -1
			}));
			["pause", "rebufferstart", "seeking", "error", "adbreakstart", "hb"].forEach((function (e) {
				t.on(e, (function () {
					if (i._lastPlayheadPosition >= 0 && t.data.player_playhead_time >= 0 && i._lastPlayerWidth >= 0 && i._lastSourceWidth > 0 && i._lastPlayerHeight >= 0 && i._lastSourceHeight > 0) {
						var e = t.data.player_playhead_time - i._lastPlayheadPosition;
						if (e < 0) return void (i._lastPlayheadPosition = -1);
						var a = Math.min(i._lastPlayerWidth / i._lastSourceWidth, i._lastPlayerHeight / i._lastSourceHeight),
							r = Math.max(0, a - 1), n = Math.max(0, 1 - a);
						t.data.view_max_upscale_percentage = Math.max(t.data.view_max_upscale_percentage || 0, r), t.data.view_max_downscale_percentage = Math.max(t.data.view_max_downscale_percentage || 0, n), vc(t.data, "view_total_content_playback_time", e), vc(t.data, "view_total_upscaling", r * e), vc(t.data, "view_total_downscaling", n * e)
					}
					i._lastPlayheadPosition = -1
				}))
			})), ["playing", "hb"].forEach((function (e) {
				t.on(e, (function () {
					i._lastPlayheadPosition = t.data.player_playhead_time, i._lastPlayerWidth = t.data.player_width, i._lastPlayerHeight = t.data.player_height, i._lastSourceWidth = t.data.video_source_width, i._lastSourceHeight = t.data.video_source_height
				}))
			}))
		}, Xc = function e(t) {
			var i = this;
			nc(this, e), lc(this, "isSeeking", void 0), this.isSeeking = !1;
			var a = -1, r = function () {
				var e = ac.now(), r = (t.data.viewer_time || e) - (a || e);
				vc(t.data, "view_seek_duration", r), t.data.view_max_seek_time = Math.max(t.data.view_max_seek_time || 0, r), i.isSeeking = !1, a = -1
			};
			t.on("seeking", (function (e, n) {
				Object.assign(t.data, n), i.isSeeking && n.viewer_time - a <= 2e3 ? a = n.viewer_time : (i.isSeeking && r(), i.isSeeking = !0, a = n.viewer_time, vc(t.data, "view_seek_count", 1), t.send("seeking"))
			})), t.on("seeked", (function () {
				r()
			})), t.on("viewend", (function () {
				i.isSeeking && (r(), t.send("seeked")), i.isSeeking = !1, a = -1
			}))
		}, Qc = function (e, t) {
			e.push(t), e.sort((function (e, t) {
				return e.viewer_time - t.viewer_time
			}))
		},
		Zc = ["adbreakstart", "adrequest", "adresponse", "adplay", "adplaying", "adpause", "adended", "adbreakend", "aderror", "adclicked", "adskipped"],
		Jc = function () {
			function e(t) {
				var i = this;
				nc(this, e), lc(this, "_adHasPlayed", void 0), lc(this, "_adRequests", void 0), lc(this, "_adResponses", void 0), lc(this, "_currentAdRequestNumber", void 0), lc(this, "_currentAdResponseNumber", void 0), lc(this, "_prerollPlayTime", void 0), lc(this, "_wouldBeNewAdPlay", void 0), lc(this, "isAdBreak", void 0), lc(this, "pm", void 0), this.pm = t, t.on("viewinit", (function () {
					i.isAdBreak = !1, i._currentAdRequestNumber = 0, i._currentAdResponseNumber = 0, i._adRequests = [], i._adResponses = [], i._adHasPlayed = !1, i._wouldBeNewAdPlay = !0, i._prerollPlayTime = void 0
				})), Zc.forEach((function (e) {
					return t.on(e, i._updateAdData.bind(i))
				}));
				var a = function () {
					i.isAdBreak = !1
				};
				t.on("adbreakstart", (function () {
					i.isAdBreak = !0
				})), t.on("play", a), t.on("playing", a), t.on("viewend", a), t.on("adrequest", (function (e, a) {
					a = Object.assign({ad_request_id: "generatedAdRequestId" + i._currentAdRequestNumber++}, a), Qc(i._adRequests, a), vc(t.data, "view_ad_request_count"), i.inPrerollPosition() && (t.data.view_preroll_requested = !0, i._adHasPlayed || vc(t.data, "view_preroll_request_count"))
				})), t.on("adresponse", (function (e, a) {
					a = Object.assign({ad_request_id: "generatedAdRequestId" + i._currentAdResponseNumber++}, a), Qc(i._adResponses, a);
					var r = i.findAdRequest(a.ad_request_id);
					r && vc(t.data, "view_ad_request_time", Math.max(0, a.viewer_time - r.viewer_time))
				})), t.on("adplay", (function (e, a) {
					i._adHasPlayed = !0, i._wouldBeNewAdPlay && (i._wouldBeNewAdPlay = !1, vc(t.data, "view_ad_played_count")), i.inPrerollPosition() && !t.data.view_preroll_played && (t.data.view_preroll_played = !0, i._adRequests.length > 0 && (t.data.view_preroll_request_time = Math.max(0, a.viewer_time - i._adRequests[0].viewer_time)), t.data.view_start && (t.data.view_startup_preroll_request_time = Math.max(0, a.viewer_time - t.data.view_start)), i._prerollPlayTime = a.viewer_time)
				})), t.on("adplaying", (function (e, a) {
					i.inPrerollPosition() && void 0 === t.data.view_preroll_load_time && void 0 !== i._prerollPlayTime && (t.data.view_preroll_load_time = a.viewer_time - i._prerollPlayTime, t.data.view_startup_preroll_load_time = a.viewer_time - i._prerollPlayTime)
				})), t.on("adclicked", (function (e, a) {
					i._wouldBeNewAdPlay || vc(t.data, "view_ad_clicked_count")
				})), t.on("adskipped", (function (e, a) {
					i._wouldBeNewAdPlay || vc(t.data, "view_ad_skipped_count")
				})), t.on("adended", (function () {
					i._wouldBeNewAdPlay = !0
				})), t.on("aderror", (function () {
					i._wouldBeNewAdPlay = !0
				}))
			}

			return oc(e, [{
				key: "inPrerollPosition", value: function () {
					return void 0 === this.pm.data.view_content_playback_time || this.pm.data.view_content_playback_time <= 1e3
				}
			}, {
				key: "findAdRequest", value: function (e) {
					for (var t = 0; t < this._adRequests.length; t++) if (this._adRequests[t].ad_request_id === e) return this._adRequests[t]
				}
			}, {
				key: "_updateAdData", value: function (e, t) {
					if (this.inPrerollPosition()) {
						if (!this.pm.data.view_preroll_ad_tag_hostname && t.ad_tag_url) {
							var i = Vh(mc(t.ad_tag_url), 2), a = i[0], r = i[1];
							this.pm.data.view_preroll_ad_tag_domain = r, this.pm.data.view_preroll_ad_tag_hostname = a
						}
						if (!this.pm.data.view_preroll_ad_asset_hostname && t.ad_asset_url) {
							var n = Vh(mc(t.ad_asset_url), 2), s = n[0], o = n[1];
							this.pm.data.view_preroll_ad_asset_domain = o, this.pm.data.view_preroll_ad_asset_hostname = s
						}
					}
					this.pm.data.ad_asset_url = null == t ? void 0 : t.ad_asset_url, this.pm.data.ad_tag_url = null == t ? void 0 : t.ad_tag_url, this.pm.data.ad_creative_id = null == t ? void 0 : t.ad_creative_id, this.pm.data.ad_id = null == t ? void 0 : t.ad_id, this.pm.data.ad_universal_id = null == t ? void 0 : t.ad_universal_id
				}
			}]), e
		}(), em = Jc, tm = Th(Ah()), im = function e(t) {
			nc(this, e);
			var i, a, r = function () {
				t.disableRebufferTracking || i && (vc(t.data, "view_waiting_rebuffer_duration", ac.now() - i), i = !1, tm.default.clearInterval(a))
			}, n = !1, s = function () {
				n = !1, r()
			};
			t.on("waiting", (function () {
				n && (t.disableRebufferTracking || (vc(t.data, "view_waiting_rebuffer_count", 1), i = ac.now(), a = tm.default.setInterval((function () {
					if (i) {
						var e = ac.now();
						vc(t.data, "view_waiting_rebuffer_duration", e - i), i = e
					}
				}), 250)))
			})), t.on("playing", (function () {
				r(), n = !0
			})), t.on("pause", s), t.on("seeking", s)
		}, am = function e(t) {
			var i = this;
			nc(this, e), lc(this, "lastWallClockTime", void 0);
			var a = function () {
				i.lastWallClockTime = ac.now(), t.on("before*", r)
			}, r = function (e) {
				var a = ac.now(), r = i.lastWallClockTime;
				i.lastWallClockTime = a, a - r > 3e4 && (t.emit("devicesleep", {viewer_time: r}), Object.assign(t.data, {viewer_time: r}), t.send("devicesleep"), t.emit("devicewake", {viewer_time: a}), Object.assign(t.data, {viewer_time: a}), t.send("devicewake"))
			};
			t.one("playbackheartbeat", a), t.on("playbackheartbeatend", (function () {
				t.off("before*", r), t.one("playbackheartbeat", a)
			}))
		}, rm = Th(Ah()), nm = Th(Rh()), sm = Th(Ih()), om = "muxData", lm = function () {
			var e;
			try {
				e = nm.default.parse(sm.default.get(om) || "")
			} catch {
				e = {}
			}
			return e
		}, dm = function (e) {
			try {
				sm.default.set(om, nm.default.stringify(e), {expires: 365})
			} catch {
			}
		};
	var um = Th(Ah()), hm = function () {
		var e;
		switch (cm()) {
			case"cellular":
				e = "cellular";
				break;
			case"ethernet":
				e = "wired";
				break;
			case"wifi":
				e = "wifi";
				break;
			case void 0:
				break;
			default:
				e = "other"
		}
		return e
	}, cm = function () {
		var e = um.default.navigator, t = e && (e.connection || e.mozConnection || e.webkitConnection);
		return t && t.type
	};
	hm.getConnectionFromAPI = cm;
	var mm = hm, fm = gm({
		a: "env",
		b: "beacon",
		c: "custom",
		d: "ad",
		e: "event",
		f: "experiment",
		i: "internal",
		m: "mux",
		n: "response",
		p: "player",
		q: "request",
		r: "retry",
		s: "session",
		t: "timestamp",
		u: "viewer",
		v: "video",
		w: "page",
		x: "view",
		y: "sub"
	}), pm = gm({
		ad: "ad",
		ag: "aggregate",
		ap: "api",
		al: "application",
		ar: "architecture",
		as: "asset",
		au: "autoplay",
		av: "average",
		bi: "bitrate",
		br: "break",
		bw: "browser",
		by: "bytes",
		bz: "business",
		ca: "cached",
		cb: "cancel",
		cc: "codec",
		cd: "code",
		cg: "category",
		ch: "changed",
		ck: "clicked",
		cl: "canceled",
		cn: "config",
		co: "count",
		ce: "counter",
		cp: "complete",
		cr: "creative",
		ct: "content",
		cu: "current",
		cx: "connection",
		cz: "context",
		dg: "downscaling",
		dm: "domain",
		dn: "cdn",
		do: "downscale",
		dr: "drm",
		dp: "dropped",
		du: "duration",
		dv: "device",
		ec: "encoding",
		ed: "edge",
		en: "end",
		eg: "engine",
		em: "embed",
		er: "error",
		ep: "experiments",
		es: "errorcode",
		et: "errortext",
		ee: "event",
		ev: "events",
		ex: "expires",
		ez: "exception",
		fa: "failed",
		fi: "first",
		fm: "family",
		ft: "format",
		fp: "fps",
		fq: "frequency",
		fr: "frame",
		fs: "fullscreen",
		ha: "has",
		hb: "holdback",
		he: "headers",
		ho: "host",
		hn: "hostname",
		ht: "height",
		id: "id",
		ii: "init",
		in: "instance",
		ip: "ip",
		is: "is",
		ke: "key",
		la: "language",
		lb: "labeled",
		le: "level",
		li: "live",
		ld: "loaded",
		lo: "load",
		ls: "lists",
		lt: "latency",
		ma: "max",
		md: "media",
		me: "message",
		mf: "manifest",
		mi: "mime",
		ml: "midroll",
		mm: "min",
		mn: "manufacturer",
		mo: "model",
		mx: "mux",
		ne: "newest",
		nm: "name",
		no: "number",
		on: "on",
		os: "os",
		pa: "paused",
		pb: "playback",
		pd: "producer",
		pe: "percentage",
		pf: "played",
		pg: "program",
		ph: "playhead",
		pi: "plugin",
		pl: "preroll",
		pn: "playing",
		po: "poster",
		pr: "preload",
		ps: "position",
		pt: "part",
		py: "property",
		ra: "rate",
		rd: "requested",
		re: "rebuffer",
		rf: "rendition",
		rm: "remote",
		ro: "ratio",
		rp: "response",
		rq: "request",
		rs: "requests",
		sa: "sample",
		sd: "skipped",
		se: "session",
		sk: "seek",
		sm: "stream",
		so: "source",
		sq: "sequence",
		sr: "series",
		st: "start",
		su: "startup",
		sv: "server",
		sw: "software",
		sy: "severity",
		ta: "tag",
		tc: "tech",
		te: "text",
		tg: "target",
		th: "throughput",
		ti: "time",
		tl: "total",
		to: "to",
		tt: "title",
		ty: "type",
		ug: "upscaling",
		un: "universal",
		up: "upscale",
		ur: "url",
		us: "user",
		va: "variant",
		vd: "viewed",
		vi: "video",
		ve: "version",
		vw: "view",
		vr: "viewer",
		wd: "width",
		wa: "watch",
		wt: "waiting"
	});

	function gm(e) {
		var t = {};
		for (var i in e) e.hasOwnProperty(i) && (t[e[i]] = i);
		return t
	}

	function vm(e) {
		var t = {}, i = {};
		return Object.keys(e).forEach((function (a) {
			var r = !1;
			if (e.hasOwnProperty(a) && void 0 !== e[a]) {
				var n = a.split("_"), s = n[0], o = fm[s];
				o || (Zh.info("Data key word `" + n[0] + "` not expected in " + a), o = s + "_"), n.splice(1).forEach((function (e) {
					"url" === e && (r = !0), pm[e] ? o += pm[e] : Number(e) && Math.floor(Number(e)) === Number(e) ? o += e : (Zh.info("Data key word `" + e + "` not expected in " + a), o += "_" + e + "_")
				})), r ? i[o] = e[a] : t[o] = e[a]
			}
		})), Object.assign(t, i)
	}

	var Em = Th(Ah()),
		bm = {maxBeaconSize: 300, maxQueueLength: 3600, baseTimeBetweenBeacons: 1e4, maxPayloadKBSize: 500},
		ym = ["hb", "requestcompleted", "requestfailed", "requestcanceled"], Tm = function (e) {
			var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
			this._beaconUrl = e || "https://img.litix.io", this._eventQueue = [], this._postInFlight = !1, this._failureCount = 0, this._sendTimeout = !1, this._options = Object.assign({}, bm, t)
		};
	Tm.prototype.queueEvent = function (e, t) {
		var i = Object.assign({}, t);
		return (this._eventQueue.length <= this._options.maxQueueLength || "eventrateexceeded" === e) && (this._eventQueue.push(i), this._sendTimeout || this._startBeaconSending(), this._eventQueue.length <= this._options.maxQueueLength)
	}, Tm.prototype.flushEvents = function () {
		arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && 1 === this._eventQueue.length ? this._eventQueue.pop() : (this._eventQueue.length && this._sendBeaconQueue(), this._startBeaconSending())
	}, Tm.prototype.destroy = function () {
		var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
		this.destroyed = !0, e ? this._clearBeaconQueue() : this.flushEvents(), Em.default.clearTimeout(this._sendTimeout)
	}, Tm.prototype._clearBeaconQueue = function () {
		var e = this._eventQueue.length > this._options.maxBeaconSize ? this._eventQueue.length - this._options.maxBeaconSize : 0,
			t = this._eventQueue.slice(e);
		e > 0 && Object.assign(t[t.length - 1], vm({mux_view_message: "event queue truncated"}));
		var i = this._createPayload(t);
		_m(this._beaconUrl, i, !0, (function () {
		}))
	}, Tm.prototype._sendBeaconQueue = function () {
		var e = this;
		if (!this._postInFlight) {
			var t = this._eventQueue.slice(0, this._options.maxBeaconSize);
			this._eventQueue = this._eventQueue.slice(this._options.maxBeaconSize), this._postInFlight = !0;
			var i = this._createPayload(t), a = ac.now();
			_m(this._beaconUrl, i, !1, (function (i, r) {
				r ? (e._eventQueue = t.concat(e._eventQueue), e._failureCount += 1, Zh.info("Error sending beacon: " + r)) : e._failureCount = 0, e._roundTripTime = ac.now() - a, e._postInFlight = !1
			}))
		}
	}, Tm.prototype._getNextBeaconTime = function () {
		if (!this._failureCount) return this._options.baseTimeBetweenBeacons;
		var e = Math.pow(2, this._failureCount - 1);
		return (1 + (e *= Math.random())) * this._options.baseTimeBetweenBeacons
	}, Tm.prototype._startBeaconSending = function () {
		var e = this;
		Em.default.clearTimeout(this._sendTimeout), !this.destroyed && (this._sendTimeout = Em.default.setTimeout((function () {
			e._eventQueue.length && e._sendBeaconQueue(), e._startBeaconSending()
		}), this._getNextBeaconTime()))
	}, Tm.prototype._createPayload = function (e) {
		var t = this, i = {transmission_timestamp: Math.round(ac.now())};
		this._roundTripTime && (i.rtt_ms = Math.round(this._roundTripTime));
		var a, r, n, s = function () {
			a = JSON.stringify({metadata: i, events: r || e}), n = a.length / 1024
		}, o = function () {
			return n <= t._options.maxPayloadKBSize
		};
		return s(), o() || (Zh.info("Payload size is too big (" + n + " kb). Removing unnecessary events."), r = e.filter((function (e) {
			return -1 === ym.indexOf(e.e)
		})), s()), o() || (Zh.info("Payload size still too big (" + n + " kb). Cropping fields.."), r.forEach((function (e) {
			for (var t in e) {
				var i = e[t];
				"string" == typeof i && i.length > 51200 && (e[t] = i.substring(0, 51200))
			}
		})), s()), a
	};
	var Am = function (e) {
			return e.length <= 57344
		}, _m = function (e, t, i, a) {
			if (i && navigator && navigator.sendBeacon && navigator.sendBeacon(e, t)) a(); else if (Em.default.fetch) Em.default.fetch(e, {
				method: "POST",
				body: t,
				headers: {"Content-Type": "text/plain"},
				keepalive: Am(t)
			}).then((function (e) {
				return a(null, e.ok ? null : "Error")
			})).catch((function (e) {
				return a(null, e)
			})); else {
				if (Em.default.XMLHttpRequest) {
					var r = new Em.default.XMLHttpRequest;
					return r.onreadystatechange = function () {
						if (4 === r.readyState) return a(null, 200 !== r.status ? "error" : void 0)
					}, r.open("POST", e), r.setRequestHeader("Content-Type", "text/plain"), void r.send(t)
				}
				a()
			}
		}, km = Tm,
		Sm = ["env_key", "view_id", "view_sequence_number", "player_sequence_number", "beacon_domain", "player_playhead_time", "viewer_time", "mux_api_version", "event", "video_id", "player_instance_id", "player_error_code", "player_error_message", "player_error_context", "player_error_severity", "player_error_business_exception"],
		wm = ["adplay", "adplaying", "adpause", "adfirstquartile", "admidpoint", "adthirdquartile", "adended", "adresponse", "adrequest"],
		Lm = ["ad_id", "ad_creative_id", "ad_universal_id"], Rm = ["viewstart", "error", "ended", "viewend"],
		Im = function () {
			function e(t, i) {
				var a, r, n, s, o, l, d, u, h, c, m, f, p, g, v,
					E = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
				nc(this, e), lc(this, "mux", void 0), lc(this, "envKey", void 0), lc(this, "options", void 0), lc(this, "eventQueue", void 0), lc(this, "sampleRate", void 0), lc(this, "disableCookies", void 0), lc(this, "respectDoNotTrack", void 0), lc(this, "previousBeaconData", void 0), lc(this, "lastEventTime", void 0), lc(this, "rateLimited", void 0), lc(this, "pageLevelData", void 0), lc(this, "viewerData", void 0), this.mux = t, this.envKey = i, this.options = E, this.previousBeaconData = null, this.lastEventTime = 0, this.rateLimited = !1, this.eventQueue = new km(function (e, t) {
					var i = t.beaconCollectionDomain, a = t.beaconDomain;
					if (i) return "https://" + i;
					var r = a || "litix.io";
					return (e = e || "inferred").match(/^[a-z0-9]+$/) ? "https://" + e + "." + r : "https://img.litix.io/a.gif"
				}(this.envKey, this.options)), this.sampleRate = null !== (p = this.options.sampleRate) && void 0 !== p ? p : 1, this.disableCookies = null !== (g = this.options.disableCookies) && void 0 !== g && g, this.respectDoNotTrack = null !== (v = this.options.respectDoNotTrack) && void 0 !== v && v, this.previousBeaconData = null, this.lastEventTime = 0, this.rateLimited = !1, this.pageLevelData = {
					mux_api_version: this.mux.API_VERSION,
					mux_embed: this.mux.NAME,
					mux_embed_version: this.mux.VERSION,
					viewer_application_name: null === (a = this.options.platform) || void 0 === a ? void 0 : a.name,
					viewer_application_version: null === (r = this.options.platform) || void 0 === r ? void 0 : r.version,
					viewer_application_engine: null === (n = this.options.platform) || void 0 === n ? void 0 : n.layout,
					viewer_device_name: null === (s = this.options.platform) || void 0 === s ? void 0 : s.product,
					viewer_device_category: "",
					viewer_device_manufacturer: null === (o = this.options.platform) || void 0 === o ? void 0 : o.manufacturer,
					viewer_os_family: null === (d = this.options.platform) || void 0 === d || null === (l = d.os) || void 0 === l ? void 0 : l.family,
					viewer_os_architecture: null === (h = this.options.platform) || void 0 === h || null === (u = h.os) || void 0 === u ? void 0 : u.architecture,
					viewer_os_version: null === (m = this.options.platform) || void 0 === m || null === (c = m.os) || void 0 === c ? void 0 : c.version,
					viewer_connection_type: mm(),
					page_url: null === rm.default || void 0 === rm.default || null === (f = rm.default.location) || void 0 === f ? void 0 : f.href
				}, this.viewerData = this.disableCookies ? {} : function () {
					var e = lm();
					return e.mux_viewer_id = e.mux_viewer_id || qh(), e.msn = e.msn || Math.random(), dm(e), {
						mux_viewer_id: e.mux_viewer_id,
						mux_sample_number: e.msn
					}
				}()
			}

			return oc(e, [{
				key: "send", value: function (e, t) {
					if (e && null != t && t.view_id) {
						if (this.respectDoNotTrack && ec()) return Zh.info("Not sending `" + e + "` because Do Not Track is enabled");
						if (!t || "object" != typeof t) return Zh.error("A data object was expected in send() but was not provided");
						var i = this.disableCookies ? {} : function () {
								var e = lm(), t = ac.now();
								return e.session_start && (e.sst = e.session_start, delete e.session_start), e.session_id && (e.sid = e.session_id, delete e.session_id), e.session_expires && (e.sex = e.session_expires, delete e.session_expires), (!e.sex || e.sex < t) && (e.sid = qh(), e.sst = t), e.sex = t + 15e5, dm(e), {
									session_id: e.sid,
									session_start: e.sst,
									session_expires: e.sex
								}
							}(),
							a = bc(Ec({}, this.pageLevelData, t, i, this.viewerData), {event: e, env_key: this.envKey});
						a.user_id && (a.viewer_user_id = a.user_id, delete a.user_id);
						var r, n = (null !== (r = a.mux_sample_number) && void 0 !== r ? r : 0) >= this.sampleRate,
							s = vm(this._deduplicateBeaconData(e, a));
						if (this.lastEventTime = this.mux.utils.now(), n) return Zh.info("Not sending event due to sample rate restriction", e, a, s);
						if (this.envKey || Zh.info("Missing environment key (envKey) - beacons will be dropped if the video source is not a valid mux video URL", e, a, s), !this.rateLimited) if (Zh.info("Sending event", e, a, s), this.rateLimited = !this.eventQueue.queueEvent(e, s), this.mux.WINDOW_UNLOADING && "viewend" === e) this.eventQueue.destroy(!0); else if (this.mux.WINDOW_HIDDEN && "hb" === e ? this.eventQueue.flushEvents(!0) : Rm.indexOf(e) >= 0 && this.eventQueue.flushEvents(), this.rateLimited) return a.event = "eventrateexceeded", s = vm(a), this.eventQueue.queueEvent(a.event, s), Zh.error("Beaconing disabled due to rate limit.")
					}
				}
			}, {
				key: "destroy", value: function () {
					this.eventQueue.destroy(!1)
				}
			}, {
				key: "_deduplicateBeaconData", value: function (e, t) {
					var i = this, a = {}, r = t.view_id;
					if ("-1" === r || "viewstart" === e || "viewend" === e || !this.previousBeaconData || this.mux.utils.now() - this.lastEventTime >= 6e5) a = Ec({}, t), r && (this.previousBeaconData = a), r && "viewend" === e && (this.previousBeaconData = null); else {
						var n = 0 === e.indexOf("request");
						Object.entries(t).forEach((function (t) {
							var r = Vh(t, 2), s = r[0], o = r[1];
							i.previousBeaconData && (o !== i.previousBeaconData[s] || Sm.indexOf(s) > -1 || i.objectHasChanged(n, s, o, i.previousBeaconData[s]) || i.eventRequiresKey(e, s)) && (a[s] = o, i.previousBeaconData[s] = o)
						}))
					}
					return a
				}
			}, {
				key: "objectHasChanged", value: function (e, t, i, a) {
					return !(!e || 0 !== t.indexOf("request_")) && ("request_response_headers" === t || "object" != typeof i || "object" != typeof a || Object.keys(i || {}).length !== Object.keys(a || {}).length)
				}
			}, {
				key: "eventRequiresKey", value: function (e, t) {
					return !!("renditionchange" === e && 0 === t.indexOf("video_source_") || Lm.includes(t) && wm.includes(e))
				}
			}]), e
		}(), Dm = function e(t) {
			nc(this, e);
			var i = 0, a = 0, r = 0, n = 0, s = 0, o = 0, l = 0;
			t.on("requestcompleted", (function (e, o) {
				var l, d, u = o.request_start, h = o.request_response_start, c = o.request_response_end,
					m = o.request_bytes_loaded;
				if (n++, h ? (l = h - (null != u ? u : 0), d = (null != c ? c : 0) - h) : d = (null != c ? c : 0) - (null != u ? u : 0), d > 0 && m && m > 0) {
					var f = m / d * 8e3;
					s++, a += m, r += d, t.data.view_min_request_throughput = Math.min(t.data.view_min_request_throughput || 1 / 0, f), t.data.view_average_request_throughput = a / r * 8e3, t.data.view_request_count = n, l > 0 && (i += l, t.data.view_max_request_latency = Math.max(t.data.view_max_request_latency || 0, l), t.data.view_average_request_latency = i / s)
				}
			})), t.on("requestfailed", (function (e, i) {
				n++, o++, t.data.view_request_count = n, t.data.view_request_failed_count = o
			})), t.on("requestcanceled", (function (e, i) {
				n++, l++, t.data.view_request_count = n, t.data.view_request_canceled_count = l
			}))
		}, Cm = function e(t) {
			var i = this;
			nc(this, e), lc(this, "_lastEventTime", void 0), t.on("before*", (function (e, a) {
				var r = a.viewer_time, n = ac.now(), s = i._lastEventTime;
				if (i._lastEventTime = n, s && n - s > 36e5) {
					var o = Object.keys(t.data).reduce((function (e, i) {
						return 0 === i.indexOf("video_") ? Object.assign(e, lc({}, i, t.data[i])) : e
					}), {});
					t.mux.log.info("Received event after at least an hour inactivity, creating a new view"), t.emit("viewinit", Object.assign({viewer_time: r}, o)), t.playbackHeartbeat._playheadShouldBeProgressing && "play" !== e.type && "adbreakstart" !== e.type && (t.emit("play", {viewer_time: r}), "playing" !== e.type && t.emit("playing", {viewer_time: r}))
				}
			}))
		},
		xm = ["viewstart", "ended", "loadstart", "pause", "play", "playing", "ratechange", "waiting", "adplay", "adpause", "adended", "aderror", "adplaying", "adrequest", "adresponse", "adbreakstart", "adbreakend", "adfirstquartile", "admidpoint", "adthirdquartile", "rebufferstart", "rebufferend", "seeked", "error", "hb", "requestcompleted", "requestfailed", "requestcanceled", "renditionchange"],
		Mm = function (e) {
			!function (e, t) {
				if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
				e.prototype = Object.create(t && t.prototype, {
					constructor: {
						value: e,
						writable: !0,
						configurable: !0
					}
				}), t && dc(e, t)
			}(i, e);
			var t = hc(i);

			function i(e, a, r) {
				var n;
				nc(this, i), lc(rc(n = t.call(this)), "DOM_CONTENT_LOADED_EVENT_END", void 0), lc(rc(n), "NAVIGATION_START", void 0), lc(rc(n), "_destroyed", void 0), lc(rc(n), "_heartBeatTimeout", void 0), lc(rc(n), "adTracker", void 0), lc(rc(n), "dashjs", void 0), lc(rc(n), "data", void 0), lc(rc(n), "disablePlayheadRebufferTracking", void 0), lc(rc(n), "disableRebufferTracking", void 0), lc(rc(n), "errorTracker", void 0), lc(rc(n), "errorTranslator", void 0), lc(rc(n), "getAdData", void 0), lc(rc(n), "getPlayheadTime", void 0), lc(rc(n), "getStateData", void 0), lc(rc(n), "hlsjs", void 0), lc(rc(n), "id", void 0), lc(rc(n), "longResumeTracker", void 0), lc(rc(n), "minimumRebufferDuration", void 0), lc(rc(n), "mux", void 0), lc(rc(n), "oldEmit", void 0), lc(rc(n), "playbackEventDispatcher", void 0), lc(rc(n), "playbackHeartbeat", void 0), lc(rc(n), "playbackHeartbeatTime", void 0), lc(rc(n), "playheadTime", void 0), lc(rc(n), "seekingTracker", void 0), lc(rc(n), "sustainedRebufferThreshold", void 0), lc(rc(n), "watchTimeTracker", void 0), lc(rc(n), "currentFragmentPDT", void 0), lc(rc(n), "currentFragmentStart", void 0), n.DOM_CONTENT_LOADED_EVENT_END = gc.domContentLoadedEventEnd(), n.NAVIGATION_START = gc.navigationStart();
				n.mux = e, n.id = a, null != r && r.beaconDomain && n.mux.log.warn("The `beaconDomain` setting has been deprecated in favor of `beaconCollectionDomain`. Please change your integration to use `beaconCollectionDomain` instead of `beaconDomain`."), (r = Object.assign({
					debug: !1,
					minimumRebufferDuration: 250,
					sustainedRebufferThreshold: 1e3,
					playbackHeartbeatTime: 25,
					beaconDomain: "litix.io",
					sampleRate: 1,
					disableCookies: !1,
					respectDoNotTrack: !1,
					disableRebufferTracking: !1,
					disablePlayheadRebufferTracking: !1,
					errorTranslator: function (e) {
						return e
					}
				}, r)).data = r.data || {}, r.data.property_key && (r.data.env_key = r.data.property_key, delete r.data.property_key), Zh.setLevel(r.debug ? "debug" : "warn"), n.getPlayheadTime = r.getPlayheadTime, n.getStateData = r.getStateData || function () {
					return {}
				}, n.getAdData = r.getAdData || function () {
				}, n.minimumRebufferDuration = r.minimumRebufferDuration, n.sustainedRebufferThreshold = r.sustainedRebufferThreshold, n.playbackHeartbeatTime = r.playbackHeartbeatTime, n.disableRebufferTracking = r.disableRebufferTracking, n.disableRebufferTracking && n.mux.log.warn("Disabling rebuffer tracking. This should only be used in specific circumstances as a last resort when your player is known to unreliably track rebuffering."), n.disablePlayheadRebufferTracking = r.disablePlayheadRebufferTracking, n.errorTranslator = r.errorTranslator, n.playbackEventDispatcher = new Im(e, r.data.env_key, r), n.data = {
					player_instance_id: qh(),
					mux_sample_rate: r.sampleRate,
					beacon_domain: r.beaconCollectionDomain || r.beaconDomain
				}, n.data.view_sequence_number = 1, n.data.player_sequence_number = 1, n.oldEmit = n.emit, n.emit = function (e, t) {
					t = Object.assign({viewer_time: this.mux.utils.now()}, t), this.oldEmit(e, t)
				};
				var s = function () {
					void 0 === this.data.view_start && (this.data.view_start = this.mux.utils.now(), this.emit("viewstart"))
				}.bind(rc(n));
				n.on("viewinit", (function (e, t) {
					this._resetVideoData(), this._resetViewData(), this._resetErrorData(), this._updateStateData(), Object.assign(this.data, t), this._initializeViewData(), this.one("play", s), this.one("adbreakstart", s)
				}));
				var o = function (e) {
					this.emit("viewend"), this.send("viewend"), this.emit("viewinit", e)
				}.bind(rc(n));
				if (n.on("videochange", (function (e, t) {
					o(t)
				})), n.on("programchange", (function (e, t) {
					this.data.player_is_paused && this.mux.log.warn("The `programchange` event is intended to be used when the content changes mid playback without the video source changing, however the video is not currently playing. If the video source is changing please use the videochange event otherwise you will lose startup time information."), o(Object.assign(t, {view_program_changed: !0})), s(), this.emit("play"), this.emit("playing")
				})), n.on("fragmentchange", (function (e, t) {
					this.currentFragmentPDT = t.currentFragmentPDT, this.currentFragmentStart = t.currentFragmentStart
				})), n.on("destroy", n.destroy), "undefined" != typeof window && "function" == typeof window.addEventListener && "function" == typeof window.removeEventListener) {
					var l = function () {
						var e = void 0 !== n.data.view_start;
						n.mux.WINDOW_HIDDEN = "hidden" === document.visibilityState, e && n.mux.WINDOW_HIDDEN && (n.data.player_is_paused || n.emit("hb"))
					};
					window.addEventListener("visibilitychange", l, !1);
					var d = function (e) {
						e.persisted || n.destroy()
					};
					window.addEventListener("pagehide", d, !1), n.on("destroy", (function () {
						window.removeEventListener("visibilitychange", l), window.removeEventListener("pagehide", d)
					}))
				}
				n.on("playerready", (function (e, t) {
					Object.assign(this.data, t)
				})), xm.forEach((function (e) {
					n.on(e, (function (t, i) {
						0 !== e.indexOf("ad") && this._updateStateData(), Object.assign(this.data, i), this._sanitizeData()
					})), n.on("after" + e, (function () {
						("error" !== e || this.errorTracker.viewErrored) && this.send(e)
					}))
				})), n.on("viewend", (function (e, t) {
					Object.assign(n.data, t)
				}));
				return n.one("playerready", (function (e) {
					var t = this.mux.utils.now();
					this.data.player_init_time && (this.data.player_startup_time = t - this.data.player_init_time), !this.mux.PLAYER_TRACKED && this.NAVIGATION_START && (this.mux.PLAYER_TRACKED = !0, (this.data.player_init_time || this.DOM_CONTENT_LOADED_EVENT_END) && (this.data.page_load_time = Math.min(this.data.player_init_time || 1 / 0, this.DOM_CONTENT_LOADED_EVENT_END || 1 / 0) - this.NAVIGATION_START)), this.send("playerready"), delete this.data.player_startup_time, delete this.data.page_load_time
				})), n.longResumeTracker = new Cm(rc(n)), n.errorTracker = new Nc(rc(n)), new am(rc(n)), n.seekingTracker = new Xc(rc(n)), n.playheadTime = new Wc(rc(n)), n.playbackHeartbeat = new Pc(rc(n)), new zc(rc(n)), n.watchTimeTracker = new Fc(rc(n)), new $c(rc(n)), n.adTracker = new em(rc(n)), new qc(rc(n)), new Vc(rc(n)), new jc(rc(n)), new im(rc(n)), new Dm(rc(n)), r.hlsjs && n.addHLSJS(r), r.dashjs && n.addDashJS(r), n.emit("viewinit", r.data), n
			}

			return oc(i, [{
				key: "destroy", value: function () {
					this._destroyed || (this._destroyed = !0, void 0 !== this.data.view_start && (this.emit("viewend"), this.send("viewend")), this.playbackEventDispatcher.destroy(), this.removeHLSJS(), this.removeDashJS(), window.clearTimeout(this._heartBeatTimeout))
				}
			}, {
				key: "send", value: function (e) {
					if (this.data.view_id) {
						var t = Object.assign({}, this.data);
						if (void 0 === t.video_source_is_live && (t.player_source_duration === 1 / 0 || t.video_source_duration === 1 / 0 ? t.video_source_is_live = !0 : (t.player_source_duration > 0 || t.video_source_duration > 0) && (t.video_source_is_live = !1)), t.video_source_is_live || ["player_program_time", "player_manifest_newest_program_time", "player_live_edge_program_time", "player_program_time", "video_holdback", "video_part_holdback", "video_target_duration", "video_part_target_duration"].forEach((function (e) {
							t[e] = void 0
						})), t.video_source_url = t.video_source_url || t.player_source_url, t.video_source_url) {
							var i = Vh(mc(t.video_source_url), 2), a = i[0], r = i[1];
							t.video_source_domain = r, t.video_source_hostname = a
						}
						delete t.ad_request_id, this.playbackEventDispatcher.send(e, t), this.data.view_sequence_number++, this.data.player_sequence_number++, this._restartHeartBeat(), "viewend" === e && delete this.data.view_id
					}
				}
			}, {
				key: "_updateStateData", value: function () {
					Object.assign(this.data, this.getStateData()), this.playheadTime._updatePlayheadTime(), this._sanitizeData()
				}
			}, {
				key: "_sanitizeData", value: function () {
					var e = this;
					["player_width", "player_height", "video_source_width", "video_source_height", "player_playhead_time", "video_source_bitrate"].forEach((function (t) {
						var i = parseInt(e.data[t], 10);
						e.data[t] = isNaN(i) ? void 0 : i
					}));
					["player_source_url", "video_source_url"].forEach((function (t) {
						if (e.data[t]) {
							var i = e.data[t].toLowerCase();
							(0 === i.indexOf("data:") || 0 === i.indexOf("blob:")) && (e.data[t] = "MSE style URL")
						}
					}))
				}
			}, {
				key: "_resetVideoData", value: function () {
					var e = this;
					Object.keys(this.data).forEach((function (t) {
						0 === t.indexOf("video_") && delete e.data[t]
					}))
				}
			}, {
				key: "_resetViewData", value: function () {
					var e = this;
					Object.keys(this.data).forEach((function (t) {
						0 === t.indexOf("view_") && delete e.data[t]
					})), this.data.view_sequence_number = 1
				}
			}, {
				key: "_resetErrorData", value: function () {
					delete this.data.player_error_code, delete this.data.player_error_message, delete this.data.player_error_context, delete this.data.player_error_severity, delete this.data.player_error_business_exception
				}
			}, {
				key: "_initializeViewData", value: function () {
					var e = this, t = this.data.view_id = qh(), i = function () {
						t === e.data.view_id && vc(e.data, "player_view_count", 1)
					};
					this.data.player_is_paused ? this.one("play", i) : i()
				}
			}, {
				key: "_restartHeartBeat", value: function () {
					var e = this;
					window.clearTimeout(this._heartBeatTimeout), this.errorTracker.viewErrored || (this._heartBeatTimeout = window.setTimeout((function () {
						e.data.player_is_paused || e.emit("hb")
					}), 1e4))
				}
			}, {
				key: "addHLSJS", value: function (e) {
					e.hlsjs ? this.hlsjs ? this.mux.log.warn("An instance of HLS.js is already being monitored for this player.") : (this.hlsjs = e.hlsjs, function (e, t, i) {
						var a = arguments.length > 4 ? arguments[4] : void 0, r = e.log, n = e.utils.secondsToMs,
							s = function (e) {
								var t, i = parseInt(a.version);
								return 1 === i && null !== e.programDateTime && (t = e.programDateTime), 0 === i && null !== e.pdt && (t = e.pdt), t
							};
						if (gc.exists()) {
							var o = function (i, a) {
								return e.emit(t, i, a)
							}, l = function (e, t) {
								var i = t.levels, a = t.audioTracks, r = t.url, n = t.stats, s = t.networkDetails,
									l = t.sessionData, d = {}, u = {};
								i.forEach((function (e, t) {
									d[t] = {width: e.width, height: e.height, bitrate: e.bitrate, attrs: e.attrs}
								})), a.forEach((function (e, t) {
									u[t] = {name: e.name, language: e.lang, bitrate: e.bitrate}
								}));
								var h = Sc(n), c = h.bytesLoaded, m = h.requestStart, f = h.responseStart,
									p = h.responseEnd;
								o("requestcompleted", bc(Ec({}, kc(l)), {
									request_event_type: e,
									request_bytes_loaded: c,
									request_start: m,
									request_response_start: f,
									request_response_end: p,
									request_type: "manifest",
									request_hostname: cc(r),
									request_response_headers: wc(s),
									request_rendition_lists: {media: d, audio: u, video: {}}
								}))
							};
							i.on(a.Events.MANIFEST_LOADED, l);
							var d = function (e, t) {
								var i = t.details, a = t.level, r = t.networkDetails, l = t.stats, d = Sc(l),
									u = d.bytesLoaded, h = d.requestStart, c = d.responseStart, m = d.responseEnd,
									f = i.fragments[i.fragments.length - 1], p = s(f) + n(f.duration);
								o("requestcompleted", {
									request_event_type: e,
									request_bytes_loaded: u,
									request_start: h,
									request_response_start: c,
									request_response_end: m,
									request_current_level: a,
									request_type: "manifest",
									request_hostname: cc(i.url),
									request_response_headers: wc(r),
									video_holdback: i.holdBack && n(i.holdBack),
									video_part_holdback: i.partHoldBack && n(i.partHoldBack),
									video_part_target_duration: i.partTarget && n(i.partTarget),
									video_target_duration: i.targetduration && n(i.targetduration),
									video_source_is_live: i.live,
									player_manifest_newest_program_time: isNaN(p) ? void 0 : p
								})
							};
							i.on(a.Events.LEVEL_LOADED, d);
							var u = function (e, t) {
								var i = t.details, a = t.networkDetails, r = t.stats, n = Sc(r), s = n.bytesLoaded,
									l = n.requestStart, d = n.responseStart, u = n.responseEnd;
								o("requestcompleted", {
									request_event_type: e,
									request_bytes_loaded: s,
									request_start: l,
									request_response_start: d,
									request_response_end: u,
									request_type: "manifest",
									request_hostname: cc(i.url),
									request_response_headers: wc(a)
								})
							};
							i.on(a.Events.AUDIO_TRACK_LOADED, u);
							var h = function (e, t) {
								var a = t.stats, r = t.networkDetails, n = t.frag;
								a = a || n.stats;
								var s = Sc(a), l = s.bytesLoaded, d = s.requestStart, u = s.responseStart,
									h = s.responseEnd, c = r ? wc(r) : void 0, m = {
										request_event_type: e,
										request_bytes_loaded: l,
										request_start: d,
										request_response_start: u,
										request_response_end: h,
										request_hostname: r ? cc(r.responseURL) : void 0,
										request_id: c ? _c(c) : void 0,
										request_response_headers: c,
										request_media_duration: n.duration,
										request_url: null == r ? void 0 : r.responseURL
									};
								"main" === n.type ? (m.request_type = "media", m.request_current_level = n.level, m.request_video_width = (i.levels[n.level] || {}).width, m.request_video_height = (i.levels[n.level] || {}).height, m.request_labeled_bitrate = (i.levels[n.level] || {}).bitrate) : m.request_type = n.type, o("requestcompleted", m)
							};
							i.on(a.Events.FRAG_LOADED, h);
							var c = function (e, t) {
								var i = t.frag, a = i.start, r = {currentFragmentPDT: s(i), currentFragmentStart: n(a)};
								o("fragmentchange", r)
							};
							i.on(a.Events.FRAG_CHANGED, c);
							var m = function (e, t) {
								var i = t.type, r = t.details, n = t.response, s = t.fatal, l = t.frag,
									d = t.networkDetails, u = (null == l ? void 0 : l.url) || t.url || "",
									h = d ? wc(d) : void 0;
								if ((r === a.ErrorDetails.MANIFEST_LOAD_ERROR || r === a.ErrorDetails.MANIFEST_LOAD_TIMEOUT || r === a.ErrorDetails.FRAG_LOAD_ERROR || r === a.ErrorDetails.FRAG_LOAD_TIMEOUT || r === a.ErrorDetails.LEVEL_LOAD_ERROR || r === a.ErrorDetails.LEVEL_LOAD_TIMEOUT || r === a.ErrorDetails.AUDIO_TRACK_LOAD_ERROR || r === a.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT || r === a.ErrorDetails.SUBTITLE_LOAD_ERROR || r === a.ErrorDetails.SUBTITLE_LOAD_TIMEOUT || r === a.ErrorDetails.KEY_LOAD_ERROR || r === a.ErrorDetails.KEY_LOAD_TIMEOUT) && o("requestfailed", {
									request_error: r,
									request_url: u,
									request_hostname: cc(u),
									request_id: h ? _c(h) : void 0,
									request_type: r === a.ErrorDetails.FRAG_LOAD_ERROR || r === a.ErrorDetails.FRAG_LOAD_TIMEOUT ? "media" : r === a.ErrorDetails.AUDIO_TRACK_LOAD_ERROR || r === a.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT ? "audio" : r === a.ErrorDetails.SUBTITLE_LOAD_ERROR || r === a.ErrorDetails.SUBTITLE_LOAD_TIMEOUT ? "subtitle" : r === a.ErrorDetails.KEY_LOAD_ERROR || r === a.ErrorDetails.KEY_LOAD_TIMEOUT ? "encryption" : "manifest",
									request_error_code: null == n ? void 0 : n.code,
									request_error_text: null == n ? void 0 : n.text
								}), s) {
									var c,
										m = "".concat(u ? "url: ".concat(u, "\n") : "") + "".concat(n && (n.code || n.text) ? "response: ".concat(n.code, ", ").concat(n.text, "\n") : "") + "".concat(t.reason ? "failure reason: ".concat(t.reason, "\n") : "") + "".concat(t.level ? "level: ".concat(t.level, "\n") : "") + "".concat(t.parent ? "parent stream controller: ".concat(t.parent, "\n") : "") + "".concat(t.buffer ? "buffer length: ".concat(t.buffer, "\n") : "") + "".concat(t.error ? "error: ".concat(t.error, "\n") : "") + "".concat(t.event ? "event: ".concat(t.event, "\n") : "") + "".concat(t.err ? "error message: ".concat(null === (c = t.err) || void 0 === c ? void 0 : c.message, "\n") : "");
									o("error", {player_error_code: i, player_error_message: r, player_error_context: m})
								}
							};
							i.on(a.Events.ERROR, m);
							var f = function (e, t) {
								var i = t.frag, a = i && i._url || "";
								o("requestcanceled", {
									request_event_type: e,
									request_url: a,
									request_type: "media",
									request_hostname: cc(a)
								})
							};
							i.on(a.Events.FRAG_LOAD_EMERGENCY_ABORTED, f);
							var p = function (e, t) {
								var a = t.level, n = i.levels[a];
								if (n && n.attrs && n.attrs.BANDWIDTH) {
									var s, l = n.attrs.BANDWIDTH, d = parseFloat(n.attrs["FRAME-RATE"]);
									isNaN(d) || (s = d), l ? o("renditionchange", {
										video_source_fps: s,
										video_source_bitrate: l,
										video_source_width: n.width,
										video_source_height: n.height,
										video_source_rendition_name: n.name,
										video_source_codec: null == n ? void 0 : n.videoCodec
									}) : r.warn("missing BANDWIDTH from HLS manifest parsed by HLS.js")
								}
							};
							i.on(a.Events.LEVEL_SWITCHED, p), i._stopMuxMonitor = function () {
								i.off(a.Events.MANIFEST_LOADED, l), i.off(a.Events.LEVEL_LOADED, d), i.off(a.Events.AUDIO_TRACK_LOADED, u), i.off(a.Events.FRAG_LOADED, h), i.off(a.Events.FRAG_CHANGED, c), i.off(a.Events.ERROR, m), i.off(a.Events.FRAG_LOAD_EMERGENCY_ABORTED, f), i.off(a.Events.LEVEL_SWITCHED, p), i.off(a.Events.DESTROYING, i._stopMuxMonitor), delete i._stopMuxMonitor
							}, i.on(a.Events.DESTROYING, i._stopMuxMonitor)
						} else r.warn("performance timing not supported. Not tracking HLS.js.")
					}(this.mux, this.id, e.hlsjs, {}, e.Hls || window.Hls)) : this.mux.log.warn("You must pass a valid hlsjs instance in order to track it.")
				}
			}, {
				key: "removeHLSJS", value: function () {
					this.hlsjs && (function (e) {
						e && "function" == typeof e._stopMuxMonitor && e._stopMuxMonitor()
					}(this.hlsjs), this.hlsjs = void 0)
				}
			}, {
				key: "addDashJS", value: function (e) {
					e.dashjs ? this.dashjs ? this.mux.log.warn("An instance of Dash.js is already being monitored for this player.") : (this.dashjs = e.dashjs, Ic(this.mux, this.id, e.dashjs)) : this.mux.log.warn("You must pass a valid dashjs instance in order to track it.")
				}
			}, {
				key: "removeDashJS", value: function () {
					this.dashjs && (function (e) {
						e && "function" == typeof e._stopMuxMonitor && e._stopMuxMonitor()
					}(this.dashjs), this.dashjs = void 0)
				}
			}]), i
		}(xc), Om = Mm;
	kh();
	var Pm = Th(Wh());
	var Nm = ["loadstart", "pause", "play", "playing", "seeking", "seeked", "timeupdate", "ratechange", "stalled", "waiting", "error", "ended"],
		Um = {1: "MEDIA_ERR_ABORTED", 2: "MEDIA_ERR_NETWORK", 3: "MEDIA_ERR_DECODE", 4: "MEDIA_ERR_SRC_NOT_SUPPORTED"};
	var Fm, Bm = Th(Ah());
	Bm.default && Bm.default.WeakMap && (Fm = new WeakMap);
	var $m = "#EXT-X-TARGETDURATION", Hm = "#EXT-X-PART-INF", Wm = "#EXT-X-SERVER-CONTROL", Gm = "#EXTINF",
		Vm = "#EXT-X-PROGRAM-DATE-TIME", Km = "#EXT-X-VERSION", qm = "#EXT-X-SESSION-DATA", Ym = function (e) {
			return this.buffer = "", this.manifest = {
				segments: [],
				serverControl: {},
				sessionData: {}
			}, this.currentUri = {}, this.process(e), this.manifest
		};
	Ym.prototype.process = function (e) {
		var t;
		for (this.buffer += e, t = this.buffer.indexOf("\n"); t > -1; t = this.buffer.indexOf("\n")) this.processLine(this.buffer.substring(0, t)), this.buffer = this.buffer.substring(t + 1)
	}, Ym.prototype.processLine = function (e) {
		var t = e.indexOf(":"), i = ef(e, t), a = i[0], r = 2 === i.length ? Xm(i[1]) : void 0;
		if ("#" !== a[0]) this.currentUri.uri = a, this.manifest.segments.push(this.currentUri), this.manifest.targetDuration && !("duration" in this.currentUri) && (this.currentUri.duration = this.manifest.targetDuration), this.currentUri = {}; else switch (a) {
			case $m:
				if (!isFinite(r) || r < 0) return;
				this.manifest.targetDuration = r, this.setHoldBack();
				break;
			case Hm:
				jm(this.manifest, i), this.manifest.partInf.partTarget && (this.manifest.partTargetDuration = this.manifest.partInf.partTarget), this.setHoldBack();
				break;
			case Wm:
				jm(this.manifest, i), this.setHoldBack();
				break;
			case Gm:
				0 === r ? this.currentUri.duration = .01 : r > 0 && (this.currentUri.duration = r);
				break;
			case Vm:
				var n = r, s = new Date(n);
				this.manifest.dateTimeString || (this.manifest.dateTimeString = n, this.manifest.dateTimeObject = s), this.currentUri.dateTimeString = n, this.currentUri.dateTimeObject = s;
				break;
			case Km:
				jm(this.manifest, i);
				break;
			case qm:
				var o = tf(i[1]), l = kc(o);
				Object.assign(this.manifest.sessionData, l)
		}
	}, Ym.prototype.setHoldBack = function () {
		var e = this.manifest, t = e.serverControl, i = e.targetDuration, a = e.partTargetDuration;
		if (t) {
			var r = "holdBack", n = "partHoldBack", s = i && 3 * i, o = a && 2 * a;
			i && !t.hasOwnProperty(r) && (t[r] = s), s && t[r] < s && (t[r] = s), a && !t.hasOwnProperty(n) && (t[n] = 3 * a), a && t[n] < o && (t[n] = o)
		}
	};
	var jm = function (e, t) {
		var i, a = zm(t[0].replace("#EXT-X-", ""));
		Jm(t[1]) ? (i = {}, i = Object.assign(Zm(t[1]), i)) : i = Xm(t[1]), e[a] = i
	}, zm = function (e) {
		return e.toLowerCase().replace(/-(\w)/g, (function (e) {
			return e[1].toUpperCase()
		}))
	}, Xm = function (e) {
		if ("yes" === e.toLowerCase() || "no" === e.toLowerCase()) return "yes" === e.toLowerCase();
		var t = -1 !== e.indexOf(":") ? e : parseFloat(e);
		return isNaN(t) ? e : t
	}, Qm = function (e) {
		var t = {}, i = e.split("=");
		i.length > 1 && (t[zm(i[0])] = Xm(i[1]));
		return t
	}, Zm = function (e) {
		for (var t = e.split(","), i = {}, a = 0; t.length > a; a++) {
			var r = t[a], n = Qm(r);
			i = Object.assign(n, i)
		}
		return i
	}, Jm = function (e) {
		return e.indexOf("=") > -1
	}, ef = function (e, t) {
		return -1 === t ? [e] : [e.substring(0, t), e.substring(t + 1)]
	}, tf = function (e) {
		var t = {};
		if (e) {
			var i = e.search(",");
			return [e.slice(0, i), e.slice(i + 1)].forEach((function (e, i) {
				for (var a = e.replace(/['"]+/g, "").split("="), r = 0; r < a.length; r++) "DATA-ID" === a[r] && (t["DATA-ID"] = a[1 - r]), "VALUE" === a[r] && (t.VALUE = a[1 - r])
			})), {data: t}
		}
	}, af = Ym, rf = {
		safeCall: function (e, t, i, a) {
			var r = a;
			if (e && "function" == typeof e[t]) try {
				r = e[t].apply(e, i)
			} catch (e) {
				Zh.info("safeCall error", e)
			}
			return r
		},
		safeIncrement: vc,
		getComputedStyle: function (e, t) {
			return e && t && Bm.default && "function" == typeof Bm.default.getComputedStyle ? (Fm && Fm.has(e) && (i = Fm.get(e)), i || (i = Bm.default.getComputedStyle(e, null), Fm && Fm.set(e, i)), i.getPropertyValue(t)) : "";
			var i
		},
		secondsToMs: function (e) {
			return Math.floor(1e3 * e)
		},
		assign: Object.assign,
		headersStringToObject: Ac,
		cdnHeadersToRequestId: _c,
		extractHostnameAndDomain: mc,
		extractHostname: cc,
		manifestParser: af,
		generateShortID: Yh,
		generateUUID: qh,
		now: ac.now
	}, nf = rf, sf = {
		PLAYER_READY: "playerready",
		VIEW_INIT: "viewinit",
		VIDEO_CHANGE: "videochange",
		PLAY: "play",
		PAUSE: "pause",
		PLAYING: "playing",
		TIME_UPDATE: "timeupdate",
		SEEKING: "seeking",
		SEEKED: "seeked",
		REBUFFER_START: "rebufferstart",
		REBUFFER_END: "rebufferend",
		ERROR: "error",
		ENDED: "ended",
		RENDITION_CHANGE: "renditionchange",
		ORIENTATION_CHANGE: "orientationchange",
		AD_REQUEST: "adrequest",
		AD_RESPONSE: "adresponse",
		AD_BREAK_START: "adbreakstart",
		AD_PLAY: "adplay",
		AD_PLAYING: "adplaying",
		AD_PAUSE: "adpause",
		AD_FIRST_QUARTILE: "adfirstquartile",
		AD_MID_POINT: "admidpoint",
		AD_THIRD_QUARTILE: "adthirdquartile",
		AD_ENDED: "adended",
		AD_BREAK_END: "adbreakend",
		AD_ERROR: "aderror",
		REQUEST_COMPLETED: "requestcompleted",
		REQUEST_FAILED: "requestfailed",
		REQUEST_CANCELLED: "requestcanceled"
	}, of = {}, lf = function (e) {
		var t = arguments;
		"string" == typeof e ? lf.hasOwnProperty(e) ? Kh.default.setTimeout((function () {
			t = Array.prototype.splice.call(t, 1), lf[e].apply(null, t)
		}), 0) : Zh.warn("`" + e + "` is an unknown task") : "function" == typeof e ? Kh.default.setTimeout((function () {
			e(lf)
		}), 0) : Zh.warn("`" + e + "` is invalid.")
	}, df = {
		loaded: ac.now(),
		NAME: "mux-embed",
		VERSION: "5.2.0",
		API_VERSION: "2.1",
		PLAYER_TRACKED: !1,
		monitor: function (e, t) {
			return function (e, t, i) {
				var a = Vh(zh(t), 3), r = a[0], n = a[1], s = a[2], o = e.log, l = e.utils.getComputedStyle,
					d = e.utils.secondsToMs;
				if (!r) return o.error("No element was found with the `" + n + "` query selector.");
				if ("video" !== s && "audio" !== s) return o.error("The element of `" + n + "` was not a media element.");
				r.mux && (r.mux.destroy(), delete r.mux, o.warn("Already monitoring this video element, replacing existing event listeners")), (i = Object.assign({automaticErrorTracking: !0}, i)).data = Object.assign({
					player_software: "HTML5 Video Element",
					player_mux_plugin_name: "VideoElementMonitor",
					player_mux_plugin_version: e.VERSION
				}, i.data), i.getPlayheadTime = function () {
					return d(r.currentTime)
				}, i.getStateData = function () {
					var e, t = this.hlsjs && this.hlsjs.url,
						a = this.dashjs && _h("function" === this.dashjs.getSource) && this.dashjs.getSource(), n = {
							player_is_paused: r.paused,
							player_playhead_time: d(r.currentTime),
							player_width: parseInt(l(r, "width")),
							player_height: parseInt(l(r, "height")),
							player_autoplay_on: r.autoplay,
							player_preload_on: r.preload,
							player_language_code: r.lang,
							player_is_fullscreen: Pm.default && !!(Pm.default.fullscreenElement || Pm.default.webkitFullscreenElement || Pm.default.mozFullScreenElement || Pm.default.msFullscreenElement),
							video_poster_url: r.poster,
							video_source_url: t || a || r.currentSrc,
							video_source_duration: d(r.duration),
							video_source_height: r.videoHeight,
							video_source_width: r.videoWidth,
							view_dropped_frame_count: null == r || null === (e = r.getVideoPlaybackQuality) || void 0 === e ? void 0 : e.call(r).droppedVideoFrames
						}, s = i.getPlayheadTime();
					if (r.getStartDate && s > 0) {
						var o = r.getStartDate();
						if (o && "function" == typeof o.getTime && o.getTime()) {
							var u = o.getTime();
							if (n.player_program_time = u + s, r.seekable.length > 0) {
								var h = u + r.seekable.end(r.seekable.length - 1);
								n.player_live_edge_program_time = h
							}
						}
					}
					return n
				}, r.mux = r.mux || {}, r.mux.deleted = !1, r.mux.emit = function (t, i) {
					e.emit(n, t, i)
				};
				var u = function () {
					o.error("The monitor for this video element has already been destroyed.")
				};
				r.mux.destroy = function () {
					Object.keys(r.mux.listeners).forEach((function (e) {
						r.removeEventListener(e, r.mux.listeners[e], !1)
					})), delete r.mux.listeners, r.mux.destroy = u, r.mux.swapElement = u, r.mux.emit = u, r.mux.addHLSJS = u, r.mux.addDashJS = u, r.mux.removeHLSJS = u, r.mux.removeDashJS = u, r.mux.deleted = !0, e.emit(n, "destroy")
				}, r.mux.swapElement = function (t) {
					var i = Vh(zh(t), 3), a = i[0], n = i[1], s = i[2];
					return a ? "video" !== s && "audio" !== s ? e.log.error("The element of `" + n + "` was not a media element.") : (a.muxId = r.muxId, delete r.muxId, a.mux = a.mux || {}, a.mux.listeners = Object.assign({}, r.mux.listeners), delete r.mux.listeners, Object.keys(a.mux.listeners).forEach((function (e) {
						r.removeEventListener(e, a.mux.listeners[e], !1), a.addEventListener(e, a.mux.listeners[e], !1)
					})), a.mux.swapElement = r.mux.swapElement, a.mux.destroy = r.mux.destroy, delete r.mux, void (r = a)) : e.log.error("No element was found with the `" + n + "` query selector.")
				}, r.mux.addHLSJS = function (t) {
					e.addHLSJS(n, t)
				}, r.mux.addDashJS = function (t) {
					e.addDashJS(n, t)
				}, r.mux.removeHLSJS = function () {
					e.removeHLSJS(n)
				}, r.mux.removeDashJS = function () {
					e.removeDashJS(n)
				}, e.init(n, i), e.emit(n, "playerready"), r.paused || (e.emit(n, "play"), r.readyState > 2 && e.emit(n, "playing")), r.mux.listeners = {}, Nm.forEach((function (t) {
					"error" === t && !i.automaticErrorTracking || (r.mux.listeners[t] = function () {
						var i = {};
						if ("error" === t) {
							if (!r.error || 1 === r.error.code) return;
							i.player_error_code = r.error.code, i.player_error_message = Um[r.error.code] || r.error.message
						}
						e.emit(n, t, i)
					}, r.addEventListener(t, r.mux.listeners[t], !1))
				}))
			}(lf, e, t)
		},
		destroyMonitor: function (e) {
			var t = Vh(zh(e), 1)[0];
			t && t.mux && "function" == typeof t.mux.destroy ? t.mux.destroy() : Zh.error("A video element monitor for `" + e + "` has not been initialized via `mux.monitor`.")
		},
		addHLSJS: function (e, t) {
			var i = jh(e);
			of[i] ? of[i].addHLSJS(t) : Zh.error("A monitor for `" + i + "` has not been initialized.")
		},
		addDashJS: function (e, t) {
			var i = jh(e);
			of[i] ? of[i].addDashJS(t) : Zh.error("A monitor for `" + i + "` has not been initialized.")
		},
		removeHLSJS: function (e) {
			var t = jh(e);
			of[t] ? of[t].removeHLSJS() : Zh.error("A monitor for `" + t + "` has not been initialized.")
		},
		removeDashJS: function (e) {
			var t = jh(e);
			of[t] ? of[t].removeDashJS() : Zh.error("A monitor for `" + t + "` has not been initialized.")
		},
		init: function (e, t) {
			ec() && t && t.respectDoNotTrack && Zh.info("The browser's Do Not Track flag is enabled - Mux beaconing is disabled.");
			var i = jh(e);
			of[i] = new Om(lf, i, t)
		},
		emit: function (e, t, i) {
			var a = jh(e);
			of[a] ? (of[a].emit(t, i), "destroy" === t && delete of[a]) : Zh.error("A monitor for `" + a + "` has not been initialized.")
		},
		checkDoNotTrack: ec,
		log: Zh,
		utils: nf,
		events: sf,
		WINDOW_HIDDEN: !1,
		WINDOW_UNLOADING: !1
	};
	Object.assign(lf, df), void 0 !== Kh.default && "function" == typeof Kh.default.addEventListener && Kh.default.addEventListener("pagehide", (function (e) {
		e.persisted || (lf.WINDOW_UNLOADING = !0)
	}), !1);
	var uf = lf;
	var hf = {exports: {}};
	!function (e, t) {
		var i, a, r, n, s;
		i = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, a = /^(?=([^\/?#]*))\1([^]*)$/, r = /(?:\/|^)\.(?=\/)/g, n = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, s = {
			buildAbsoluteURL: function (e, t, i) {
				if (i = i || {}, e = e.trim(), !(t = t.trim())) {
					if (!i.alwaysNormalize) return e;
					var r = s.parseURL(e);
					if (!r) throw new Error("Error trying to parse base URL.");
					return r.path = s.normalizePath(r.path), s.buildURLFromParts(r)
				}
				var n = s.parseURL(t);
				if (!n) throw new Error("Error trying to parse relative URL.");
				if (n.scheme) return i.alwaysNormalize ? (n.path = s.normalizePath(n.path), s.buildURLFromParts(n)) : t;
				var o = s.parseURL(e);
				if (!o) throw new Error("Error trying to parse base URL.");
				if (!o.netLoc && o.path && "/" !== o.path[0]) {
					var l = a.exec(o.path);
					o.netLoc = l[1], o.path = l[2]
				}
				o.netLoc && !o.path && (o.path = "/");
				var d = {
					scheme: o.scheme,
					netLoc: n.netLoc,
					path: null,
					params: n.params,
					query: n.query,
					fragment: n.fragment
				};
				if (!n.netLoc && (d.netLoc = o.netLoc, "/" !== n.path[0])) if (n.path) {
					var u = o.path, h = u.substring(0, u.lastIndexOf("/") + 1) + n.path;
					d.path = s.normalizePath(h)
				} else d.path = o.path, n.params || (d.params = o.params, n.query || (d.query = o.query));
				return null === d.path && (d.path = i.alwaysNormalize ? s.normalizePath(n.path) : n.path), s.buildURLFromParts(d)
			}, parseURL: function (e) {
				var t = i.exec(e);
				return t ? {
					scheme: t[1] || "",
					netLoc: t[2] || "",
					path: t[3] || "",
					params: t[4] || "",
					query: t[5] || "",
					fragment: t[6] || ""
				} : null
			}, normalizePath: function (e) {
				for (e = e.split("").reverse().join("").replace(r, ""); e.length !== (e = e.replace(n, "")).length;) ;
				return e.split("").reverse().join("")
			}, buildURLFromParts: function (e) {
				return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment
			}
		}, e.exports = s
	}(hf);
	var cf = hf.exports;

	function mf(e, t) {
		var i = Object.keys(e);
		if (Object.getOwnPropertySymbols) {
			var a = Object.getOwnPropertySymbols(e);
			t && (a = a.filter((function (t) {
				return Object.getOwnPropertyDescriptor(e, t).enumerable
			}))), i.push.apply(i, a)
		}
		return i
	}

	function ff(e) {
		for (var t = 1; t < arguments.length; t++) {
			var i = null != arguments[t] ? arguments[t] : {};
			t % 2 ? mf(Object(i), !0).forEach((function (t) {
				gf(e, t, i[t])
			})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : mf(Object(i)).forEach((function (t) {
				Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
			}))
		}
		return e
	}

	function pf(e) {
		var t = function (e, t) {
			if ("object" != typeof e || !e) return e;
			var i = e[Symbol.toPrimitive];
			if (void 0 !== i) {
				var a = i.call(e, t || "default");
				if ("object" != typeof a) return a;
				throw new TypeError("@@toPrimitive must return a primitive value.")
			}
			return ("string" === t ? String : Number)(e)
		}(e, "string");
		return "symbol" == typeof t ? t : String(t)
	}

	function gf(e, t, i) {
		return (t = pf(t)) in e ? Object.defineProperty(e, t, {
			value: i,
			enumerable: !0,
			configurable: !0,
			writable: !0
		}) : e[t] = i, e
	}

	function vf() {
		return vf = Object.assign ? Object.assign.bind() : function (e) {
			for (var t = 1; t < arguments.length; t++) {
				var i = arguments[t];
				for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (e[a] = i[a])
			}
			return e
		}, vf.apply(this, arguments)
	}

	var Ef = Number.isFinite || function (e) {
		return "number" == typeof e && isFinite(e)
	}, bf = Number.isSafeInteger || function (e) {
		return "number" == typeof e && Math.abs(e) <= yf
	}, yf = Number.MAX_SAFE_INTEGER || 9007199254740991, Tf = function (e) {
		return e.MEDIA_ATTACHING = "hlsMediaAttaching", e.MEDIA_ATTACHED = "hlsMediaAttached", e.MEDIA_DETACHING = "hlsMediaDetaching", e.MEDIA_DETACHED = "hlsMediaDetached", e.BUFFER_RESET = "hlsBufferReset", e.BUFFER_CODECS = "hlsBufferCodecs", e.BUFFER_CREATED = "hlsBufferCreated", e.BUFFER_APPENDING = "hlsBufferAppending", e.BUFFER_APPENDED = "hlsBufferAppended", e.BUFFER_EOS = "hlsBufferEos", e.BUFFER_FLUSHING = "hlsBufferFlushing", e.BUFFER_FLUSHED = "hlsBufferFlushed", e.MANIFEST_LOADING = "hlsManifestLoading", e.MANIFEST_LOADED = "hlsManifestLoaded", e.MANIFEST_PARSED = "hlsManifestParsed", e.LEVEL_SWITCHING = "hlsLevelSwitching", e.LEVEL_SWITCHED = "hlsLevelSwitched", e.LEVEL_LOADING = "hlsLevelLoading", e.LEVEL_LOADED = "hlsLevelLoaded", e.LEVEL_UPDATED = "hlsLevelUpdated", e.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", e.LEVELS_UPDATED = "hlsLevelsUpdated", e.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", e.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", e.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", e.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", e.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", e.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", e.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", e.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", e.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", e.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", e.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", e.CUES_PARSED = "hlsCuesParsed", e.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", e.INIT_PTS_FOUND = "hlsInitPtsFound", e.FRAG_LOADING = "hlsFragLoading", e.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", e.FRAG_LOADED = "hlsFragLoaded", e.FRAG_DECRYPTED = "hlsFragDecrypted", e.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", e.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", e.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", e.FRAG_PARSED = "hlsFragParsed", e.FRAG_BUFFERED = "hlsFragBuffered", e.FRAG_CHANGED = "hlsFragChanged", e.FPS_DROP = "hlsFpsDrop", e.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", e.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated", e.ERROR = "hlsError", e.DESTROYING = "hlsDestroying", e.KEY_LOADING = "hlsKeyLoading", e.KEY_LOADED = "hlsKeyLoaded", e.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", e.BACK_BUFFER_REACHED = "hlsBackBufferReached", e.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded", e
	}({}), Af = function (e) {
		return e.NETWORK_ERROR = "networkError", e.MEDIA_ERROR = "mediaError", e.KEY_SYSTEM_ERROR = "keySystemError", e.MUX_ERROR = "muxError", e.OTHER_ERROR = "otherError", e
	}({}), _f = function (e) {
		return e.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", e.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", e.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", e.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", e.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", e.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", e.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", e.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", e.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", e.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", e.MANIFEST_LOAD_ERROR = "manifestLoadError", e.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", e.MANIFEST_PARSING_ERROR = "manifestParsingError", e.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", e.LEVEL_EMPTY_ERROR = "levelEmptyError", e.LEVEL_LOAD_ERROR = "levelLoadError", e.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", e.LEVEL_PARSING_ERROR = "levelParsingError", e.LEVEL_SWITCH_ERROR = "levelSwitchError", e.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", e.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", e.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", e.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", e.FRAG_LOAD_ERROR = "fragLoadError", e.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", e.FRAG_DECRYPT_ERROR = "fragDecryptError", e.FRAG_PARSING_ERROR = "fragParsingError", e.FRAG_GAP = "fragGap", e.REMUX_ALLOC_ERROR = "remuxAllocError", e.KEY_LOAD_ERROR = "keyLoadError", e.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", e.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", e.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", e.BUFFER_APPEND_ERROR = "bufferAppendError", e.BUFFER_APPENDING_ERROR = "bufferAppendingError", e.BUFFER_STALLED_ERROR = "bufferStalledError", e.BUFFER_FULL_ERROR = "bufferFullError", e.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", e.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", e.INTERNAL_EXCEPTION = "internalException", e.INTERNAL_ABORTED = "aborted", e.UNKNOWN = "unknown", e
	}({}), kf = function () {
	}, Sf = {trace: kf, debug: kf, log: kf, warn: kf, info: kf, error: kf}, wf = Sf;

	function Lf(e, ...t) {
		t.forEach((function (t) {
			wf[t] = e[t] ? e[t].bind(e) : function (e) {
				let t = self.console[e];
				return t ? t.bind(self.console, `[${e}] >`) : kf
			}(t)
		}))
	}

	var Rf = wf, If = /^(\d+)x(\d+)$/, Df = /(.+?)=(".*?"|.*?)(?:,|$)/g, Cf = class e {
		constructor(t) {
			"string" == typeof t && (t = e.parseAttrList(t)), vf(this, t)
		}

		get clientAttrs() {
			return Object.keys(this).filter((e => "X-" === e.substring(0, 2)))
		}

		static parseAttrList(e) {
			let t, i = {};
			for (Df.lastIndex = 0; null !== (t = Df.exec(e));) {
				let e = t[2];
				0 === e.indexOf('"') && e.lastIndexOf('"') === e.length - 1 && (e = e.slice(1, -1)), i[t[1].trim()] = e
			}
			return i
		}

		decimalInteger(e) {
			let t = parseInt(this[e], 10);
			return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
		}

		hexadecimalInteger(e) {
			if (this[e]) {
				let t = (this[e] || "0x").slice(2);
				t = (1 & t.length ? "0" : "") + t;
				let i = new Uint8Array(t.length / 2);
				for (let e = 0; e < t.length / 2; e++) i[e] = parseInt(t.slice(2 * e, 2 * e + 2), 16);
				return i
			}
			return null
		}

		hexadecimalIntegerAsNumber(e) {
			let t = parseInt(this[e], 16);
			return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
		}

		decimalFloatingPoint(e) {
			return parseFloat(this[e])
		}

		optionalFloat(e, t) {
			let i = this[e];
			return i ? parseFloat(i) : t
		}

		enumeratedString(e) {
			return this[e]
		}

		bool(e) {
			return "YES" === this[e]
		}

		decimalResolution(e) {
			let t = If.exec(this[e]);
			if (null !== t) return {width: parseInt(t[1], 10), height: parseInt(t[2], 10)}
		}
	};

	function xf(e) {
		return "ID" !== e && "CLASS" !== e && "START-DATE" !== e && "DURATION" !== e && "END-DATE" !== e && "END-ON-NEXT" !== e
	}

	function Mf(e) {
		return "SCTE35-OUT" === e || "SCTE35-IN" === e
	}

	var Of = class {
		constructor(e, t) {
			if (this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, t) {
				let i = t.attr;
				for (let t in i) if (Object.prototype.hasOwnProperty.call(e, t) && e[t] !== i[t]) {
					Rf.warn(`DATERANGE tag attribute: "${t}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = t;
					break
				}
				e = vf(new Cf({}), i, e)
			}
			if (this.attr = e, this._startDate = new Date(e["START-DATE"]), "END-DATE" in this.attr) {
				let e = new Date(this.attr["END-DATE"]);
				Ef(e.getTime()) && (this._endDate = e)
			}
		}

		get id() {
			return this.attr.ID
		}

		get class() {
			return this.attr.CLASS
		}

		get startDate() {
			return this._startDate
		}

		get endDate() {
			if (this._endDate) return this._endDate;
			let e = this.duration;
			return null !== e ? new Date(this._startDate.getTime() + 1e3 * e) : null
		}

		get duration() {
			if ("DURATION" in this.attr) {
				let e = this.attr.decimalFloatingPoint("DURATION");
				if (Ef(e)) return e
			} else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
			return null
		}

		get plannedDuration() {
			return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null
		}

		get endOnNext() {
			return this.attr.bool("END-ON-NEXT")
		}

		get isValid() {
			return !!this.id && !this._badValueForSameId && Ef(this.startDate.getTime()) && (null === this.duration || this.duration >= 0) && (!this.endOnNext || !!this.class)
		}
	}, Pf = class {
		constructor() {
			this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
				start: 0,
				first: 0,
				end: 0
			}, this.parsing = {start: 0, end: 0}, this.buffering = {start: 0, first: 0, end: 0}
		}
	}, Nf = "audio", Uf = "video", Ff = "audiovideo", Bf = class {
		constructor(e) {
			this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = {
				[Nf]: null,
				[Uf]: null,
				[Ff]: null
			}, this.baseurl = e
		}

		get byteRange() {
			return this._byteRange ? this._byteRange : []
		}

		get byteRangeStartOffset() {
			return this.byteRange[0]
		}

		get byteRangeEndOffset() {
			return this.byteRange[1]
		}

		get url() {
			return !this._url && this.baseurl && this.relurl && (this._url = cf.buildAbsoluteURL(this.baseurl, this.relurl, {alwaysNormalize: !0})), this._url || ""
		}

		set url(e) {
			this._url = e
		}

		setByteRange(e, t) {
			let i, a = e.split("@", 2);
			i = 1 === a.length ? (null == t ? void 0 : t.byteRangeEndOffset) || 0 : parseInt(a[1]), this._byteRange = [i, parseInt(a[0]) + i]
		}
	}, $f = class extends Bf {
		constructor(e, t) {
			super(t), this._decryptdata = null, this.rawProgramDateTime = null, this.programDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.stats = new Pf, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.urlId = 0, this.type = e
		}

		get decryptdata() {
			let {levelkeys: e} = this;
			if (!e && !this._decryptdata) return null;
			if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
				let e = this.levelkeys.identity;
				if (e) this._decryptdata = e.getDecryptData(this.sn); else {
					let e = Object.keys(this.levelkeys);
					if (1 === e.length) return this._decryptdata = this.levelkeys[e[0]].getDecryptData(this.sn)
				}
			}
			return this._decryptdata
		}

		get end() {
			return this.start + this.duration
		}

		get endProgramDateTime() {
			if (null === this.programDateTime || !Ef(this.programDateTime)) return null;
			let e = Ef(this.duration) ? this.duration : 0;
			return this.programDateTime + 1e3 * e
		}

		get encrypted() {
			var e;
			if (null != (e = this._decryptdata) && e.encrypted) return !0;
			if (this.levelkeys) {
				let e = Object.keys(this.levelkeys), t = e.length;
				if (t > 1 || 1 === t && this.levelkeys[e[0]].encrypted) return !0
			}
			return !1
		}

		setKeyFormat(e) {
			if (this.levelkeys) {
				let t = this.levelkeys[e];
				t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn))
			}
		}

		abortRequests() {
			var e, t;
			null == (e = this.loader) || e.abort(), null == (t = this.keyLoader) || t.abort()
		}

		setElementaryStreamInfo(e, t, i, a, r, n = !1) {
			let {elementaryStreams: s} = this, o = s[e];
			o ? (o.startPTS = Math.min(o.startPTS, t), o.endPTS = Math.max(o.endPTS, i), o.startDTS = Math.min(o.startDTS, a), o.endDTS = Math.max(o.endDTS, r)) : s[e] = {
				startPTS: t,
				endPTS: i,
				startDTS: a,
				endDTS: r,
				partial: n
			}
		}

		clearElementaryStreamInfo() {
			let {elementaryStreams: e} = this;
			e[Nf] = null, e[Uf] = null, e[Ff] = null
		}
	}, Hf = class extends Bf {
		constructor(e, t, i, a, r) {
			super(i), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.stats = new Pf, this.duration = e.decimalFloatingPoint("DURATION"), this.gap = e.bool("GAP"), this.independent = e.bool("INDEPENDENT"), this.relurl = e.enumeratedString("URI"), this.fragment = t, this.index = a;
			let n = e.enumeratedString("BYTERANGE");
			n && this.setByteRange(n, r), r && (this.fragOffset = r.fragOffset + r.duration)
		}

		get start() {
			return this.fragment.start + this.fragOffset
		}

		get end() {
			return this.start + this.duration
		}

		get loaded() {
			let {elementaryStreams: e} = this;
			return !!(e.audio || e.video || e.audiovideo)
		}
	};

	function Wf(e) {
		return Uint8Array.from(atob(e), (e => e.charCodeAt(0)))
	}

	function Gf(e) {
		let t = e.split(":"), i = null;
		if ("data" === t[0] && 2 === t.length) {
			let e = t[1].split(";"), a = e[e.length - 1].split(",");
			if (2 === a.length) {
				let t = "base64" === a[0], r = a[1];
				t ? (e.splice(-1, 1), i = Wf(r)) : i = function (e) {
					let t = Vf(e).subarray(0, 16), i = new Uint8Array(16);
					return i.set(t, 16 - t.length), i
				}(r)
			}
		}
		return i
	}

	function Vf(e) {
		return Uint8Array.from(unescape(encodeURIComponent(e)), (e => e.charCodeAt(0)))
	}

	var Kf = "undefined" != typeof self ? self : void 0, qf = {
			CLEARKEY: "org.w3.clearkey",
			FAIRPLAY: "com.apple.fps",
			PLAYREADY: "com.microsoft.playready",
			WIDEVINE: "com.widevine.alpha"
		}, Yf = "org.w3.clearkey", jf = "com.apple.streamingkeydelivery", zf = "com.microsoft.playready",
		Xf = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";

	function Qf(e) {
		switch (e) {
			case jf:
				return qf.FAIRPLAY;
			case zf:
				return qf.PLAYREADY;
			case Xf:
				return qf.WIDEVINE;
			case Yf:
				return qf.CLEARKEY
		}
	}

	var Zf = "edef8ba979d64acea3c827dcd51d21ed";

	function Jf(e) {
		switch (e) {
			case qf.FAIRPLAY:
				return jf;
			case qf.PLAYREADY:
				return zf;
			case qf.WIDEVINE:
				return Xf;
			case qf.CLEARKEY:
				return Yf
		}
	}

	function ep(e) {
		let {drmSystems: t, widevineLicenseUrl: i} = e,
			a = t ? [qf.FAIRPLAY, qf.WIDEVINE, qf.PLAYREADY, qf.CLEARKEY].filter((e => !!t[e])) : [];
		return !a[qf.WIDEVINE] && i && a.push(qf.WIDEVINE), a
	}

	var tp = function (e) {
		return null != Kf && null != (e = Kf.navigator) && e.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null
	}();

	function ip(e, t, i) {
		return Uint8Array.prototype.slice ? e.slice(t, i) : new Uint8Array(Array.prototype.slice.call(e, t, i))
	}

	var ap,
		rp = (e, t) => t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128,
		np = (e, t) => t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128,
		sp = (e, t) => {
			let i = t, a = 0;
			for (; rp(e, t);) {
				a += 10, a += op(e, t + 6), np(e, t + 10) && (a += 10), t += a
			}
			if (a > 0) return e.subarray(i, i + a)
		}, op = (e, t) => {
			let i = 0;
			return i = (127 & e[t]) << 21, i |= (127 & e[t + 1]) << 14, i |= (127 & e[t + 2]) << 7, i |= 127 & e[t + 3], i
		}, lp = (e, t) => rp(e, t) && op(e, t + 6) + 10 <= e.length - t, dp = e => {
			let t = cp(e);
			for (let e = 0; e < t.length; e++) {
				let i = t[e];
				if (up(i)) return vp(i)
			}
		}, up = e => e && "PRIV" === e.key && "com.apple.streaming.transportStreamTimestamp" === e.info, hp = e => {
			let t = String.fromCharCode(e[0], e[1], e[2], e[3]), i = op(e, 4);
			return {type: t, size: i, data: e.subarray(10, 10 + i)}
		}, cp = e => {
			let t = 0, i = [];
			for (; rp(e, t);) {
				let a = op(e, t + 6);
				t += 10;
				let r = t + a;
				for (; t + 8 < r;) {
					let a = hp(e.subarray(t)), r = mp(a);
					r && i.push(r), t += a.size + 10
				}
				np(e, t) && (t += 10)
			}
			return i
		}, mp = e => "PRIV" === e.type ? fp(e) : "W" === e.type[0] ? gp(e) : pp(e), fp = e => {
			if (e.size < 2) return;
			let t = Ep(e.data, !0), i = new Uint8Array(e.data.subarray(t.length + 1));
			return {key: e.type, info: t, data: i.buffer}
		}, pp = e => {
			if (e.size < 2) return;
			if ("TXXX" === e.type) {
				let t = 1, i = Ep(e.data.subarray(t), !0);
				t += i.length + 1;
				let a = Ep(e.data.subarray(t));
				return {key: e.type, info: i, data: a}
			}
			let t = Ep(e.data.subarray(1));
			return {key: e.type, data: t}
		}, gp = e => {
			if ("WXXX" === e.type) {
				if (e.size < 2) return;
				let t = 1, i = Ep(e.data.subarray(t), !0);
				t += i.length + 1;
				let a = Ep(e.data.subarray(t));
				return {key: e.type, info: i, data: a}
			}
			let t = Ep(e.data);
			return {key: e.type, data: t}
		}, vp = e => {
			if (8 === e.data.byteLength) {
				let t = new Uint8Array(e.data), i = 1 & t[3], a = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7];
				return a /= 45, i && (a += 47721858.84), Math.round(a)
			}
		}, Ep = (e, t = !1) => {
			let i = function () {
				if (!navigator.userAgent.includes("PlayStation 4")) return !ap && void 0 !== self.TextDecoder && (ap = new self.TextDecoder("utf-8")), ap
			}();
			if (i) {
				let a = i.decode(e);
				if (t) {
					let e = a.indexOf("\0");
					return -1 !== e ? a.substring(0, e) : a
				}
				return a.replace(/\0/g, "")
			}
			let a, r, n, s = e.length, o = "", l = 0;
			for (; l < s;) {
				if (a = e[l++], 0 === a && t) return o;
				if (0 !== a && 3 !== a) switch (a >> 4) {
					case 0:
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7:
						o += String.fromCharCode(a);
						break;
					case 12:
					case 13:
						r = e[l++], o += String.fromCharCode((31 & a) << 6 | 63 & r);
						break;
					case 14:
						r = e[l++], n = e[l++], o += String.fromCharCode((15 & a) << 12 | (63 & r) << 6 | (63 & n) << 0)
				}
			}
			return o
		};
	var bp = function (e) {
		let t = "";
		for (let i = 0; i < e.length; i++) {
			let a = e[i].toString(16);
			a.length < 2 && (a = "0" + a), t += a
		}
		return t
	}, yp = Math.pow(2, 32) - 1, Tp = [].push, Ap = {video: 1, audio: 2, id3: 3, text: 4};

	function _p(e) {
		return String.fromCharCode.apply(null, e)
	}

	function kp(e, t) {
		let i = e[t] << 8 | e[t + 1];
		return i < 0 ? 65536 + i : i
	}

	function Sp(e, t) {
		let i = Lp(e, t);
		return i < 0 ? 4294967296 + i : i
	}

	function wp(e, t) {
		let i = Sp(e, t);
		return i *= Math.pow(2, 32), i += Sp(e, t + 4), i
	}

	function Lp(e, t) {
		return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]
	}

	function Rp(e, t, i) {
		e[t] = i >> 24, e[t + 1] = i >> 16 & 255, e[t + 2] = i >> 8 & 255, e[t + 3] = 255 & i
	}

	function Ip(e, t) {
		let i = [];
		if (!t.length) return i;
		let a = e.byteLength;
		for (let r = 0; r < a;) {
			let n = Sp(e, r), s = n > 1 ? r + n : a;
			if (_p(e.subarray(r + 4, r + 8)) === t[0]) if (1 === t.length) i.push(e.subarray(r + 8, s)); else {
				let a = Ip(e.subarray(r + 8, s), t.slice(1));
				a.length && Tp.apply(i, a)
			}
			r = s
		}
		return i
	}

	function Dp(e) {
		let t = [], i = e[0], a = 8, r = Sp(e, a);
		a += 4;
		let n = 0, s = 0;
		0 === i ? (n = Sp(e, a), s = Sp(e, a + 4), a += 8) : (n = wp(e, a), s = wp(e, a + 8), a += 16), a += 2;
		let o = e.length + s, l = kp(e, a);
		a += 2;
		for (let i = 0; i < l; i++) {
			let i = a, n = Sp(e, i);
			i += 4;
			let s = 2147483647 & n;
			if ((2147483648 & n) >>> 31 == 1) return Rf.warn("SIDX has hierarchical references (not supported)"), null;
			let l = Sp(e, i);
			i += 4, t.push({
				referenceSize: s,
				subsegmentDuration: l,
				info: {duration: l / r, start: o, end: o + s - 1}
			}), o += s, i += 4, a = i
		}
		return {earliestPresentationTime: n, timescale: r, version: i, referencesCount: l, references: t}
	}

	function Cp(e) {
		let t = [], i = Ip(e, ["moov", "trak"]);
		for (let e = 0; e < i.length; e++) {
			let a = i[e], r = Ip(a, ["tkhd"])[0];
			if (r) {
				let e = r[0], i = Sp(r, 0 === e ? 12 : 20), n = Ip(a, ["mdia", "mdhd"])[0];
				if (n) {
					e = n[0];
					let r = Sp(n, 0 === e ? 12 : 20), s = Ip(a, ["mdia", "hdlr"])[0];
					if (s) {
						let e = _p(s.subarray(8, 12)), n = {soun: Nf, vide: Uf}[e];
						if (n) {
							let e = xp(Ip(a, ["mdia", "minf", "stbl", "stsd"])[0]);
							t[i] = {timescale: r, type: n}, t[n] = ff({timescale: r, id: i}, e)
						}
					}
				}
			}
		}
		return Ip(e, ["moov", "mvex", "trex"]).forEach((e => {
			let i = Sp(e, 4), a = t[i];
			a && (a.default = {duration: Sp(e, 12), flags: Sp(e, 20)})
		})), t
	}

	function xp(e) {
		let t = e.subarray(8), i = t.subarray(86), a = _p(t.subarray(4, 8)), r = a, n = "enca" === a || "encv" === a;
		if (n) {
			let e = Ip(t, [a])[0].subarray("enca" === a ? 28 : 78);
			Ip(e, ["sinf"]).forEach((e => {
				let t = Ip(e, ["schm"])[0];
				if (t) {
					let i = _p(t.subarray(4, 8));
					if ("cbcs" === i || "cenc" === i) {
						let t = Ip(e, ["frma"])[0];
						t && (r = _p(t))
					}
				}
			}))
		}
		switch (r) {
			case"avc1":
			case"avc2":
			case"avc3":
			case"avc4": {
				let e = Ip(i, ["avcC"])[0];
				r += "." + Op(e[1]) + Op(e[2]) + Op(e[3]);
				break
			}
			case"mp4a": {
				let e = Ip(t, [a])[0], i = Ip(e.subarray(28), ["esds"])[0];
				if (i && i.length > 12) {
					let e = 4;
					if (3 !== i[e++]) break;
					e = Mp(i, e), e += 2;
					let t = i[e++];
					if (128 & t && (e += 2), 64 & t && (e += i[e++]), 4 !== i[e++]) break;
					e = Mp(i, e);
					let a = i[e++];
					if (64 !== a) break;
					if (r += "." + Op(a), e += 12, 5 !== i[e++]) break;
					e = Mp(i, e);
					let n = i[e++], s = (248 & n) >> 3;
					31 === s && (s += 1 + ((7 & n) << 3) + ((224 & i[e]) >> 5)), r += "." + s
				}
				break
			}
			case"hvc1":
			case"hev1": {
				let e = Ip(i, ["hvcC"])[0], t = e[1], a = ["", "A", "B", "C"][t >> 6], n = 31 & t, s = Sp(e, 2),
					o = (32 & t) >> 5 ? "H" : "L", l = e[12], d = e.subarray(6, 12);
				r += "." + a + n, r += "." + s.toString(16).toUpperCase(), r += "." + o + l;
				let u = "";
				for (let e = d.length; e--;) {
					let t = d[e];
					(t || u) && (u = "." + t.toString(16).toUpperCase() + u)
				}
				r += u;
				break
			}
			case"dvh1":
			case"dvhe": {
				let e = Ip(i, ["dvcC"])[0], t = e[2] >> 1 & 127, a = e[2] << 5 & 32 | e[3] >> 3 & 31;
				r += "." + Pp(t) + "." + Pp(a);
				break
			}
			case"vp09": {
				let e = Ip(i, ["vpcC"])[0], t = e[4], a = e[5], n = e[6] >> 4 & 15;
				r += "." + Pp(t) + "." + Pp(a) + "." + Pp(n);
				break
			}
			case"av01": {
				let e = Ip(i, ["av1C"])[0], t = e[1] >>> 5, a = 31 & e[1], n = e[2] >>> 7 ? "H" : "M",
					s = (64 & e[2]) >> 6, o = (32 & e[2]) >> 5, l = 2 === t && s ? o ? 12 : 10 : s ? 10 : 8,
					d = (16 & e[2]) >> 4, u = (8 & e[2]) >> 3, h = (4 & e[2]) >> 2, c = 3 & e[2], m = 1, f = 1, p = 1,
					g = 0;
				r += "." + t + "." + Pp(a) + n + "." + Pp(l) + "." + d + "." + u + h + c + "." + Pp(m) + "." + Pp(f) + "." + Pp(p) + "." + g;
				break
			}
		}
		return {codec: r, encrypted: n}
	}

	function Mp(e, t) {
		let i = t + 5;
		for (; 128 & e[t++] && t < i;) ;
		return t
	}

	function Op(e) {
		return ("0" + e.toString(16).toUpperCase()).slice(-2)
	}

	function Pp(e) {
		return (e < 10 ? "0" : "") + e
	}

	function Np(e) {
		let t = Ip(e, ["schm"])[0];
		if (t) {
			let i = _p(t.subarray(4, 8));
			if ("cbcs" === i || "cenc" === i) return Ip(e, ["schi", "tenc"])[0]
		}
		return Rf.error("[eme] missing 'schm' box"), null
	}

	function Up(e) {
		let t = Sp(e, 0), i = 8;
		1 & t && (i += 4), 4 & t && (i += 4);
		let a = 0, r = Sp(e, 4);
		for (let n = 0; n < r; n++) {
			if (256 & t) {
				a += Sp(e, i), i += 4
			}
			512 & t && (i += 4), 1024 & t && (i += 4), 2048 & t && (i += 4)
		}
		return a
	}

	function Fp(e, t) {
		let i = new Uint8Array(e.length + t.length);
		return i.set(e), i.set(t, e.length), i
	}

	function Bp(e, t) {
		let i = [], a = t.samples, r = t.timescale, n = t.id, s = !1;
		return Ip(a, ["moof"]).map((o => {
			let l = o.byteOffset - 8;
			Ip(o, ["traf"]).map((o => {
				let d = Ip(o, ["tfdt"]).map((e => {
					let t = e[0], i = Sp(e, 4);
					return 1 === t && (i *= Math.pow(2, 32), i += Sp(e, 8)), i / r
				}))[0];
				return void 0 !== d && (e = d), Ip(o, ["tfhd"]).map((d => {
					let u = Sp(d, 4), h = 16777215 & Sp(d, 0), c = 0, m = 0 != (16 & h), f = 0, p = 0 != (32 & h),
						g = 8;
					u === n && (0 != (1 & h) && (g += 8), 0 != (2 & h) && (g += 4), 0 != (8 & h) && (c = Sp(d, g), g += 4), m && (f = Sp(d, g), g += 4), p && (g += 4), "video" === t.type && (s = function (e) {
						if (!e) return !1;
						let t = e.indexOf("."), i = t < 0 ? e : e.substring(0, t);
						return "hvc1" === i || "hev1" === i || "dvh1" === i || "dvhe" === i
					}(t.codec)), Ip(o, ["trun"]).map((n => {
						let o = n[0], d = 16777215 & Sp(n, 0), u = 0 != (1 & d), h = 0, m = 0 != (4 & d),
							p = 0 != (256 & d), g = 0, v = 0 != (512 & d), E = 0, b = 0 != (1024 & d),
							y = 0 != (2048 & d), T = 0, A = Sp(n, 4), _ = 8;
						u && (h = Sp(n, _), _ += 4), m && (_ += 4);
						let k = h + l;
						for (let l = 0; l < A; l++) {
							if (p ? (g = Sp(n, _), _ += 4) : g = c, v ? (E = Sp(n, _), _ += 4) : E = f, b && (_ += 4), y && (T = 0 === o ? Sp(n, _) : Lp(n, _), _ += 4), t.type === Uf) {
								let t = 0;
								for (; t < E;) {
									let n = Sp(a, k);
									if (k += 4, $p(s, a[k])) {
										Hp(a.subarray(k, k + n), s ? 2 : 1, e + T / r, i)
									}
									k += n, t += n + 4
								}
							}
							e += g / r
						}
					})))
				}))
			}))
		})), i
	}

	function $p(e, t) {
		if (e) {
			let e = t >> 1 & 63;
			return 39 === e || 40 === e
		}
		return 6 == (31 & t)
	}

	function Hp(e, t, i, a) {
		let r = Wp(e), n = 0;
		n += t;
		let s = 0, o = 0, l = 0;
		for (; n < r.length;) {
			s = 0;
			do {
				if (n >= r.length) break;
				l = r[n++], s += l
			} while (255 === l);
			o = 0;
			do {
				if (n >= r.length) break;
				l = r[n++], o += l
			} while (255 === l);
			let e = r.length - n, t = n;
			if (o < e) n += o; else if (o > e) {
				Rf.error(`Malformed SEI payload. ${o} is too small, only ${e} bytes left to parse.`);
				break
			}
			if (4 === s) {
				if (181 === r[t++]) {
					let e = kp(r, t);
					if (t += 2, 49 === e) {
						let e = Sp(r, t);
						if (t += 4, 1195456820 === e) {
							let e = r[t++];
							if (3 === e) {
								let n = r[t++], o = 64 & n, l = o ? 2 + 3 * (31 & n) : 0, d = new Uint8Array(l);
								if (o) {
									d[0] = n;
									for (let e = 1; e < l; e++) d[e] = r[t++]
								}
								a.push({type: e, payloadType: s, pts: i, bytes: d})
							}
						}
					}
				}
			} else if (5 === s && o > 16) {
				let e = [];
				for (let i = 0; i < 16; i++) {
					let a = r[t++].toString(16);
					e.push(1 == a.length ? "0" + a : a), (3 === i || 5 === i || 7 === i || 9 === i) && e.push("-")
				}
				let n = o - 16, l = new Uint8Array(n);
				for (let e = 0; e < n; e++) l[e] = r[t++];
				a.push({payloadType: s, pts: i, uuid: e.join(""), userData: Ep(l), userDataBytes: l})
			}
		}
	}

	function Wp(e) {
		let t = e.byteLength, i = [], a = 1;
		for (; a < t - 2;) 0 === e[a] && 0 === e[a + 1] && 3 === e[a + 2] ? (i.push(a + 2), a += 2) : a++;
		if (0 === i.length) return e;
		let r = t - i.length, n = new Uint8Array(r), s = 0;
		for (a = 0; a < r; s++, a++) s === i[0] && (s++, i.shift()), n[a] = e[s];
		return n
	}

	function Gp(e, t, i) {
		if (16 !== e.byteLength) throw new RangeError("Invalid system id");
		let a, r, n;
		if (t) {
			a = 1, r = new Uint8Array(16 * t.length);
			for (let e = 0; e < t.length; e++) {
				let i = t[e];
				if (16 !== i.byteLength) throw new RangeError("Invalid key");
				r.set(i, 16 * e)
			}
		} else a = 0, r = new Uint8Array;
		a > 0 ? (n = new Uint8Array(4), t.length > 0 && new DataView(n.buffer).setUint32(0, t.length, !1)) : n = new Uint8Array;
		let s = new Uint8Array(4);
		return i && i.byteLength > 0 && new DataView(s.buffer).setUint32(0, i.byteLength, !1), function (e, ...t) {
			let i = t.length, a = 8, r = i;
			for (; r--;) a += t[r].byteLength;
			let n = new Uint8Array(a);
			for (n[0] = a >> 24 & 255, n[1] = a >> 16 & 255, n[2] = a >> 8 & 255, n[3] = 255 & a, n.set(e, 4), r = 0, a = 8; r < i; r++) n.set(t[r], a), a += t[r].byteLength;
			return n
		}([112, 115, 115, 104], new Uint8Array([a, 0, 0, 0]), e, n, r, s, i || new Uint8Array)
	}

	var Vp = {}, Kp = class e {
		constructor(e, t, i, a = [1], r = null) {
			this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = i, this.keyFormatVersions = a, this.iv = r, this.encrypted = !!e && "NONE" !== e, this.isCommonEncryption = this.encrypted && "AES-128" !== e
		}

		static clearKeyUriToKeyIdMap() {
			Vp = {}
		}

		isSupported() {
			if (this.method) {
				if ("AES-128" === this.method || "NONE" === this.method) return !0;
				if ("identity" === this.keyFormat) return "SAMPLE-AES" === this.method;
				switch (this.keyFormat) {
					case jf:
					case Xf:
					case zf:
					case Yf:
						return -1 !== ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method)
				}
			}
			return !1
		}

		getDecryptData(t) {
			if (!this.encrypted || !this.uri) return null;
			if ("AES-128" === this.method && this.uri && !this.iv) {
				"number" != typeof t && ("AES-128" === this.method && !this.iv && Rf.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), t = 0);
				let i = function (e) {
					let t = new Uint8Array(16);
					for (let i = 12; i < 16; i++) t[i] = e >> 8 * (15 - i) & 255;
					return t
				}(t);
				return new e(this.method, this.uri, "identity", this.keyFormatVersions, i)
			}
			let i = Gf(this.uri);
			if (i) switch (this.keyFormat) {
				case Xf:
					this.pssh = i, i.length >= 22 && (this.keyId = i.subarray(i.length - 22, i.length - 6));
					break;
				case zf: {
					let e = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
					this.pssh = Gp(e, null, i);
					let t = new Uint16Array(i.buffer, i.byteOffset, i.byteLength / 2),
						a = String.fromCharCode.apply(null, Array.from(t)), r = a.substring(a.indexOf("<"), a.length),
						n = (new DOMParser).parseFromString(r, "text/xml").getElementsByTagName("KID")[0];
					if (n) {
						let e = n.childNodes[0] ? n.childNodes[0].nodeValue : n.getAttribute("VALUE");
						if (e) {
							let t = Wf(e).subarray(0, 16);
							(function (e) {
								let t = function (e, t, i) {
									let a = e[t];
									e[t] = e[i], e[i] = a
								};
								t(e, 0, 3), t(e, 1, 2), t(e, 4, 5), t(e, 6, 7)
							})(t), this.keyId = t
						}
					}
					break
				}
				default: {
					let e = i.subarray(0, 16);
					if (16 !== e.length) {
						let t = new Uint8Array(16);
						t.set(e, 16 - e.length), e = t
					}
					this.keyId = e;
					break
				}
			}
			if (!this.keyId || 16 !== this.keyId.byteLength) {
				let e = Vp[this.uri];
				if (!e) {
					let t = Object.keys(Vp).length % Number.MAX_SAFE_INTEGER;
					e = new Uint8Array(16), new DataView(e.buffer, 12, 4).setUint32(0, t), Vp[this.uri] = e
				}
				this.keyId = e
			}
			return this
		}
	};
	var qp = /\{\$([a-zA-Z0-9-_]+)\}/g;

	function Yp(e) {
		return qp.test(e)
	}

	function jp(e, t, i) {
		if (null !== e.variableList || e.hasVariableRefs) for (let a = i.length; a--;) {
			let r = i[a], n = t[r];
			n && (t[r] = zp(e, n))
		}
	}

	function zp(e, t) {
		if (null !== e.variableList || e.hasVariableRefs) {
			let i = e.variableList;
			return t.replace(qp, (t => {
				let a = t.substring(2, t.length - 1), r = null == i ? void 0 : i[a];
				return void 0 === r ? (e.playlistParsingError || (e.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${a}"`)), t) : r
			}))
		}
		return t
	}

	function Xp(e, t, i) {
		let a, r, n = e.variableList;
		if (n || (e.variableList = n = {}), "QUERYPARAM" in t) {
			a = t.QUERYPARAM;
			try {
				let e = new self.URL(i).searchParams;
				if (!e.has(a)) throw new Error(`"${a}" does not match any query parameter in URI: "${i}"`);
				r = e.get(a)
			} catch (t) {
				e.playlistParsingError || (e.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${t.message}`))
			}
		} else a = t.NAME, r = t.VALUE;
		a in n ? e.playlistParsingError || (e.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${a}"`)) : n[a] = r || ""
	}

	function Qp(e, t, i) {
		let a = t.IMPORT;
		if (i && a in i) {
			let t = e.variableList;
			t || (e.variableList = t = {}), t[a] = i[a]
		} else e.playlistParsingError || (e.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${a}"`))
	}

	function Zp(e = !0) {
		return "undefined" == typeof self ? void 0 : (e || !self.MediaSource) && self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource
	}

	var Jp = {
		audio: {
			a3ds: 1,
			"ac-3": .95,
			"ac-4": 1,
			alac: .9,
			alaw: 1,
			dra1: 1,
			"dts+": 1,
			"dts-": 1,
			dtsc: 1,
			dtse: 1,
			dtsh: 1,
			"ec-3": .9,
			enca: 1,
			fLaC: .9,
			flac: .9,
			FLAC: .9,
			g719: 1,
			g726: 1,
			m4ae: 1,
			mha1: 1,
			mha2: 1,
			mhm1: 1,
			mhm2: 1,
			mlpa: 1,
			mp4a: 1,
			"raw ": 1,
			Opus: 1,
			opus: 1,
			samr: 1,
			sawb: 1,
			sawp: 1,
			sevc: 1,
			sqcp: 1,
			ssmv: 1,
			twos: 1,
			ulaw: 1
		},
		video: {
			avc1: 1,
			avc2: 1,
			avc3: 1,
			avc4: 1,
			avcp: 1,
			av01: .8,
			drac: 1,
			dva1: 1,
			dvav: 1,
			dvh1: .7,
			dvhe: .7,
			encv: 1,
			hev1: .75,
			hvc1: .75,
			mjp2: 1,
			mp4v: 1,
			mvc1: 1,
			mvc2: 1,
			mvc3: 1,
			mvc4: 1,
			resv: 1,
			rv60: 1,
			s263: 1,
			svc1: 1,
			svc2: 1,
			"vc-1": 1,
			vp08: 1,
			vp09: .9
		},
		text: {stpp: 1, wvtt: 1}
	};

	function eg(e, t, i = !0) {
		return !e.split(",").some((e => !tg(e, t, i)))
	}

	function tg(e, t, i = !0) {
		var a;
		let r = Zp(i);
		return null != (a = null == r ? void 0 : r.isTypeSupported(ig(e, t))) && a
	}

	function ig(e, t) {
		return `${t}/mp4;codecs="${e}"`
	}

	function ag(e) {
		if (e) {
			let t = e.substring(0, 4);
			return Jp.video[t]
		}
		return 2
	}

	function rg(e) {
		return e.split(",").reduce(((e, t) => {
			let i = Jp.video[t];
			return i ? (2 * i + e) / (e ? 3 : 2) : (Jp.audio[t] + e) / (e ? 2 : 1)
		}), 0)
	}

	var ng = {};
	var sg = /flac|opus/i;

	function og(e, t = !0) {
		return e.replace(sg, (e => function (e, t = !0) {
			if (ng[e]) return ng[e];
			let i = {flac: ["flac", "fLaC", "FLAC"], opus: ["opus", "Opus"]}[e];
			for (let a = 0; a < i.length; a++) if (tg(i[a], "audio", t)) return ng[e] = i[a], i[a];
			return e
		}(e.toLowerCase(), t)))
	}

	function lg(e, t) {
		return e && "mp4a" !== e ? e : t && t.split(",")[0]
	}

	var dg = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g,
		ug = /#EXT-X-MEDIA:(.*)/g, hg = /^#EXT(?:INF|-X-TARGETDURATION):/m,
		cg = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"), "g"),
		mg = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|")),
		fg = class e {
			static findGroup(e, t) {
				for (let i = 0; i < e.length; i++) {
					let a = e[i];
					if (a.id === t) return a
				}
			}

			static resolve(e, t) {
				return cf.buildAbsoluteURL(t, e, {alwaysNormalize: !0})
			}

			static isMediaPlaylist(e) {
				return hg.test(e)
			}

			static parseMasterPlaylist(t, i) {
				let a, r = {
					contentSteering: null,
					levels: [],
					playlistParsingError: null,
					sessionData: null,
					sessionKeys: null,
					startTimeOffset: null,
					variableList: null,
					hasVariableRefs: Yp(t)
				}, n = [];
				for (dg.lastIndex = 0; null != (a = dg.exec(t));) if (a[1]) {
					var s;
					let t = new Cf(a[1]);
					jp(r, t, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]);
					let o = zp(r, a[2]), l = {
						attrs: t,
						bitrate: t.decimalInteger("BANDWIDTH") || t.decimalInteger("AVERAGE-BANDWIDTH"),
						name: t.NAME,
						url: e.resolve(o, i)
					}, d = t.decimalResolution("RESOLUTION");
					d && (l.width = d.width, l.height = d.height), vg(t.CODECS, l), null != (s = l.unknownCodecs) && s.length || n.push(l), r.levels.push(l)
				} else if (a[3]) {
					let t = a[3], n = a[4];
					switch (t) {
						case"SESSION-DATA": {
							let e = new Cf(n);
							jp(r, e, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]);
							let t = e["DATA-ID"];
							t && (null === r.sessionData && (r.sessionData = {}), r.sessionData[t] = e);
							break
						}
						case"SESSION-KEY": {
							let e = pg(n, i, r);
							e.encrypted && e.isSupported() ? (null === r.sessionKeys && (r.sessionKeys = []), r.sessionKeys.push(e)) : Rf.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${n}"`);
							break
						}
						case"DEFINE": {
							let e = new Cf(n);
							jp(r, e, ["NAME", "VALUE", "QUERYPARAM"]), Xp(r, e, i)
						}
							break;
						case"CONTENT-STEERING": {
							let t = new Cf(n);
							jp(r, t, ["SERVER-URI", "PATHWAY-ID"]), r.contentSteering = {
								uri: e.resolve(t["SERVER-URI"], i),
								pathwayId: t["PATHWAY-ID"] || "."
							};
							break
						}
						case"START":
							r.startTimeOffset = gg(n)
					}
				}
				let o = n.length > 0 && n.length < r.levels.length;
				return r.levels = o ? n : r.levels, 0 === r.levels.length && (r.playlistParsingError = new Error("no levels found in manifest")), r
			}

			static parseMasterPlaylistMedia(t, i, a) {
				let r, n = {}, s = a.levels, o = {
					AUDIO: s.map((e => ({id: e.attrs.AUDIO, audioCodec: e.audioCodec}))),
					SUBTITLES: s.map((e => ({id: e.attrs.SUBTITLES, textCodec: e.textCodec}))),
					"CLOSED-CAPTIONS": []
				}, l = 0;
				for (ug.lastIndex = 0; null !== (r = ug.exec(t));) {
					let t = new Cf(r[1]), s = t.TYPE;
					if (s) {
						let r = o[s], d = n[s] || [];
						n[s] = d, jp(a, t, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]);
						let u = t.LANGUAGE, h = t["ASSOC-LANGUAGE"], c = t.CHANNELS, m = t.CHARACTERISTICS,
							f = t["INSTREAM-ID"], p = {
								attrs: t,
								bitrate: 0,
								id: l++,
								groupId: t["GROUP-ID"] || "",
								name: t.NAME || u || "",
								type: s,
								default: t.bool("DEFAULT"),
								autoselect: t.bool("AUTOSELECT"),
								forced: t.bool("FORCED"),
								lang: u,
								url: t.URI ? e.resolve(t.URI, i) : ""
							};
						if (h && (p.assocLang = h), c && (p.channels = c), m && (p.characteristics = m), f && (p.instreamId = f), null != r && r.length) {
							let t = e.findGroup(r, p.groupId) || r[0];
							Eg(p, t, "audioCodec"), Eg(p, t, "textCodec")
						}
						d.push(p)
					}
				}
				return n
			}

			static parseLevelPlaylist(e, t, i, a, r, n) {
				let s, o, l, d = new class {
						constructor(e) {
							this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e
						}

						get hasProgramDateTime() {
							return !!this.fragments.length && Ef(this.fragments[this.fragments.length - 1].programDateTime)
						}

						get levelTargetDuration() {
							return this.averagetargetduration || this.targetduration || 10
						}

						get drift() {
							let e = this.driftEndTime - this.driftStartTime;
							return e > 0 ? 1e3 * (this.driftEnd - this.driftStart) / e : 1
						}

						get edge() {
							return this.partEnd || this.fragmentEnd
						}

						get partEnd() {
							var e;
							return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd
						}

						get fragmentEnd() {
							var e;
							return null != (e = this.fragments) && e.length ? this.fragments[this.fragments.length - 1].end : 0
						}

						get age() {
							return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
						}

						get lastPartIndex() {
							var e;
							return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].index : -1
						}

						get lastPartSn() {
							var e;
							return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
						}

						reloaded(e) {
							if (!e) return this.advanced = !0, void (this.updated = !0);
							let t = this.lastPartSn - e.lastPartSn, i = this.lastPartIndex - e.lastPartIndex;
							this.updated = this.endSN !== e.endSN || !!i || !!t || !this.live, this.advanced = this.endSN > e.endSN || t > 0 || 0 === t && i > 0, this.updated || this.advanced ? this.misses = Math.floor(.6 * e.misses) : this.misses = e.misses + 1, this.availabilityDelay = e.availabilityDelay
						}
					}(t), u = d.fragments, h = null, c = 0, m = 0, f = 0, p = 0, g = null, v = new $f(a, t), E = -1, b = !1,
					y = null;
				for (cg.lastIndex = 0, d.m3u8 = e, d.hasVariableRefs = Yp(e); null !== (s = cg.exec(e));) {
					b && (b = !1, v = new $f(a, t), v.start = f, v.sn = c, v.cc = p, v.level = i, h && (v.initSegment = h, v.rawProgramDateTime = h.rawProgramDateTime, h.rawProgramDateTime = null, y && (v.setByteRange(y), y = null)));
					let e = s[1];
					if (e) {
						v.duration = parseFloat(e);
						let t = (" " + s[2]).slice(1);
						v.title = t || null, v.tagList.push(t ? ["INF", e, t] : ["INF", e])
					} else if (s[3]) {
						if (Ef(v.duration)) {
							v.start = f, l && Tg(v, l, d), v.sn = c, v.level = i, v.cc = p, u.push(v);
							let e = (" " + s[3]).slice(1);
							v.relurl = zp(d, e), bg(v, g), g = v, f += v.duration, c++, m = 0, b = !0
						}
					} else if (s[4]) {
						let e = (" " + s[4]).slice(1);
						g ? v.setByteRange(e, g) : v.setByteRange(e)
					} else if (s[5]) v.rawProgramDateTime = (" " + s[5]).slice(1), v.tagList.push(["PROGRAM-DATE-TIME", v.rawProgramDateTime]), -1 === E && (E = u.length); else {
						if (s = s[0].match(mg), !s) {
							Rf.warn("No matches on slow regex match for level playlist!");
							continue
						}
						for (o = 1; o < s.length && void 0 === s[o]; o++) ;
						let e = (" " + s[o]).slice(1), r = (" " + s[o + 1]).slice(1),
							f = s[o + 2] ? (" " + s[o + 2]).slice(1) : "";
						switch (e) {
							case"PLAYLIST-TYPE":
								d.type = r.toUpperCase();
								break;
							case"MEDIA-SEQUENCE":
								c = d.startSN = parseInt(r);
								break;
							case"SKIP": {
								let e = new Cf(r);
								jp(d, e, ["RECENTLY-REMOVED-DATERANGES"]);
								let t = e.decimalInteger("SKIPPED-SEGMENTS");
								if (Ef(t)) {
									d.skippedSegments = t;
									for (let e = t; e--;) u.unshift(null);
									c += t
								}
								let i = e.enumeratedString("RECENTLY-REMOVED-DATERANGES");
								i && (d.recentlyRemovedDateranges = i.split("\t"));
								break
							}
							case"TARGETDURATION":
								d.targetduration = Math.max(parseInt(r), 1);
								break;
							case"VERSION":
								d.version = parseInt(r);
								break;
							case"INDEPENDENT-SEGMENTS":
							case"EXTM3U":
								break;
							case"ENDLIST":
								d.live = !1;
								break;
							case"#":
								(r || f) && v.tagList.push(f ? [r, f] : [r]);
								break;
							case"DISCONTINUITY":
								p++, v.tagList.push(["DIS"]);
								break;
							case"GAP":
								v.gap = !0, v.tagList.push([e]);
								break;
							case"BITRATE":
								v.tagList.push([e, r]);
								break;
							case"DATERANGE": {
								let e = new Cf(r);
								jp(d, e, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]), jp(d, e, e.clientAttrs);
								let t = new Of(e, d.dateRanges[e.ID]);
								t.isValid || d.skippedSegments ? d.dateRanges[t.id] = t : Rf.warn(`Ignoring invalid DATERANGE tag: "${r}"`), v.tagList.push(["EXT-X-DATERANGE", r]);
								break
							}
							case"DEFINE": {
								let e = new Cf(r);
								jp(d, e, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]), "IMPORT" in e ? Qp(d, e, n) : Xp(d, e, t)
							}
								break;
							case"DISCONTINUITY-SEQUENCE":
								p = parseInt(r);
								break;
							case"KEY": {
								let e = pg(r, t, d);
								if (e.isSupported()) {
									if ("NONE" === e.method) {
										l = void 0;
										break
									}
									l || (l = {}), l[e.keyFormat] && (l = vf({}, l)), l[e.keyFormat] = e
								} else Rf.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${r}"`);
								break
							}
							case"START":
								d.startTimeOffset = gg(r);
								break;
							case"MAP": {
								let e = new Cf(r);
								if (jp(d, e, ["BYTERANGE", "URI"]), v.duration) {
									let r = new $f(a, t);
									yg(r, e, i, l), h = r, v.initSegment = h, h.rawProgramDateTime && !v.rawProgramDateTime && (v.rawProgramDateTime = h.rawProgramDateTime)
								} else {
									let t = v.byteRangeEndOffset;
									if (t) {
										let e = v.byteRangeStartOffset;
										y = `${t - e}@${e}`
									} else y = null;
									yg(v, e, i, l), h = v, b = !0
								}
								break
							}
							case"SERVER-CONTROL": {
								let e = new Cf(r);
								d.canBlockReload = e.bool("CAN-BLOCK-RELOAD"), d.canSkipUntil = e.optionalFloat("CAN-SKIP-UNTIL", 0), d.canSkipDateRanges = d.canSkipUntil > 0 && e.bool("CAN-SKIP-DATERANGES"), d.partHoldBack = e.optionalFloat("PART-HOLD-BACK", 0), d.holdBack = e.optionalFloat("HOLD-BACK", 0);
								break
							}
							case"PART-INF": {
								let e = new Cf(r);
								d.partTarget = e.decimalFloatingPoint("PART-TARGET");
								break
							}
							case"PART": {
								let e = d.partList;
								e || (e = d.partList = []);
								let i = m > 0 ? e[e.length - 1] : void 0, a = m++, n = new Cf(r);
								jp(d, n, ["BYTERANGE", "URI"]);
								let s = new Hf(n, v, t, a, i);
								e.push(s), v.duration += s.duration;
								break
							}
							case"PRELOAD-HINT": {
								let e = new Cf(r);
								jp(d, e, ["URI"]), d.preloadHint = e;
								break
							}
							case"RENDITION-REPORT": {
								let e = new Cf(r);
								jp(d, e, ["URI"]), d.renditionReports = d.renditionReports || [], d.renditionReports.push(e);
								break
							}
							default:
								Rf.warn(`line parsed but not handled: ${s}`)
						}
					}
				}
				g && !g.relurl ? (u.pop(), f -= g.duration, d.partList && (d.fragmentHint = g)) : d.partList && (bg(v, g), v.cc = p, d.fragmentHint = v, l && Tg(v, l, d));
				let T = u.length, A = u[0], _ = u[T - 1];
				if (f += d.skippedSegments * d.targetduration, f > 0 && T && _) {
					d.averagetargetduration = f / T;
					let e = _.sn;
					d.endSN = "initSegment" !== e ? e : 0, d.live || (_.endList = !0), A && (d.startCC = A.cc)
				} else d.endSN = 0, d.startCC = 0;
				return d.fragmentHint && (f += d.fragmentHint.duration), d.totalduration = f, d.endCC = p, E > 0 && function (e, t) {
					let i = e[t];
					for (let a = t; a--;) {
						let t = e[a];
						if (!t) return;
						t.programDateTime = i.programDateTime - 1e3 * t.duration, i = t
					}
				}(u, E), d
			}
		};

	function pg(e, t, i) {
		var a, r;
		let n = new Cf(e);
		jp(i, n, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]);
		let s = null != (a = n.METHOD) ? a : "", o = n.URI, l = n.hexadecimalInteger("IV"), d = n.KEYFORMATVERSIONS,
			u = null != (r = n.KEYFORMAT) ? r : "identity";
		o && n.IV && !l && Rf.error(`Invalid IV: ${n.IV}`);
		let h = o ? fg.resolve(o, t) : "", c = (d || "1").split("/").map(Number).filter(Number.isFinite);
		return new Kp(s, h, u, c, l)
	}

	function gg(e) {
		let t = new Cf(e).decimalFloatingPoint("TIME-OFFSET");
		return Ef(t) ? t : null
	}

	function vg(e, t) {
		let i = (e || "").split(/[ ,]+/).filter((e => e));
		["video", "audio", "text"].forEach((e => {
			let a = i.filter((t => function (e, t) {
				let i = Jp[t];
				return !!i && !!i[e.slice(0, 4)]
			}(t, e)));
			a.length && (t[`${e}Codec`] = a.join(","), i = i.filter((e => -1 === a.indexOf(e))))
		})), t.unknownCodecs = i
	}

	function Eg(e, t, i) {
		let a = t[i];
		a && (e[i] = a)
	}

	function bg(e, t) {
		e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : null != t && t.programDateTime && (e.programDateTime = t.endProgramDateTime), Ef(e.programDateTime) || (e.programDateTime = null, e.rawProgramDateTime = null)
	}

	function yg(e, t, i, a) {
		e.relurl = t.URI, t.BYTERANGE && e.setByteRange(t.BYTERANGE), e.level = i, e.sn = "initSegment", a && (e.levelkeys = a), e.initSegment = null
	}

	function Tg(e, t, i) {
		e.levelkeys = t;
		let {encryptedFragments: a} = i;
		(!a.length || a[a.length - 1].levelkeys !== t) && Object.keys(t).some((e => t[e].isCommonEncryption)) && a.push(e)
	}

	var Ag = "manifest", _g = "level", kg = "audioTrack", Sg = "subtitleTrack", wg = "main", Lg = "audio",
		Rg = "subtitle";

	function Ig(e) {
		let {type: t} = e;
		switch (t) {
			case kg:
				return Lg;
			case Sg:
				return Rg;
			default:
				return wg
		}
	}

	function Dg(e, t) {
		let i = e.url;
		return (void 0 === i || 0 === i.indexOf("data:")) && (i = t.url), i
	}

	function Cg(e, t) {
		let i;
		try {
			i = new Event("addtrack")
		} catch {
			i = document.createEvent("Event"), i.initEvent("addtrack", !1, !1)
		}
		i.track = e, t.dispatchEvent(i)
	}

	function xg(e, t) {
		let i = e.mode;
		if ("disabled" === i && (e.mode = "hidden"), e.cues && !e.cues.getCueById(t.id)) try {
			if (e.addCue(t), !e.cues.getCueById(t.id)) throw new Error(`addCue is failed for: ${t}`)
		} catch (i) {
			Rf.debug(`[texttrack-utils]: ${i}`);
			try {
				let i = new self.TextTrackCue(t.startTime, t.endTime, t.text);
				i.id = t.id, e.addCue(i)
			} catch (e) {
				Rf.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${e}`)
			}
		}
		"disabled" === i && (e.mode = i)
	}

	function Mg(e) {
		let t = e.mode;
		if ("disabled" === t && (e.mode = "hidden"), e.cues) for (let t = e.cues.length; t--;) e.removeCue(e.cues[t]);
		"disabled" === t && (e.mode = t)
	}

	function Og(e, t, i, a) {
		let r = e.mode;
		if ("disabled" === r && (e.mode = "hidden"), e.cues && e.cues.length > 0) {
			let r = function (e, t, i) {
				let a = [], r = function (e, t) {
					if (t < e[0].startTime) return 0;
					let i = e.length - 1;
					if (t > e[i].endTime) return -1;
					let a = 0, r = i;
					for (; a <= r;) {
						let n = Math.floor((r + a) / 2);
						if (t < e[n].startTime) r = n - 1; else {
							if (!(t > e[n].startTime && a < i)) return n;
							a = n + 1
						}
					}
					return e[a].startTime - t < t - e[r].startTime ? a : r
				}(e, t);
				if (r > -1) for (let n = r, s = e.length; n < s; n++) {
					let r = e[n];
					if (r.startTime >= t && r.endTime <= i) a.push(r); else if (r.startTime > i) return a
				}
				return a
			}(e.cues, t, i);
			for (let t = 0; t < r.length; t++) (!a || a(r[t])) && e.removeCue(r[t])
		}
		"disabled" === r && (e.mode = r)
	}

	function Pg(e) {
		let t = [];
		for (let i = 0; i < e.length; i++) {
			let a = e[i];
			("subtitles" === a.kind || "captions" === a.kind) && a.label && t.push(e[i])
		}
		return t
	}

	var Ng = "org.id3", Ug = "com.apple.quicktime.HLS", Fg = "https://aomedia.org/emsg/ID3";

	function Bg() {
		if ("undefined" != typeof self) return self.VTTCue || self.TextTrackCue
	}

	function $g(e, t, i, a, r) {
		let n = new e(t, i, "");
		try {
			n.value = a, r && (n.type = r)
		} catch {
			n = new e(t, i, JSON.stringify(r ? ff({type: r}, a) : a))
		}
		return n
	}

	var Hg = (() => {
		let e = Bg();
		try {
			e && new e(0, Number.POSITIVE_INFINITY, "")
		} catch {
			return Number.MAX_VALUE
		}
		return Number.POSITIVE_INFINITY
	})();

	function Wg(e, t) {
		return e.getTime() / 1e3 - t
	}

	function Gg(e) {
		return Uint8Array.from(e.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer
	}

	var Vg = class {
		constructor(e) {
			this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = () => this.timeupdate(), this.hls = e, this.config = e.config, this.registerListeners()
		}

		get latency() {
			return this._latency || 0
		}

		get maxLatency() {
			let {config: e, levelDetails: t} = this;
			return void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : t ? e.liveMaxLatencyDurationCount * t.targetduration : 0
		}

		get targetLatency() {
			let {levelDetails: e} = this;
			if (null === e) return null;
			let {holdBack: t, partHoldBack: i, targetduration: a} = e, {
				liveSyncDuration: r,
				liveSyncDurationCount: n,
				lowLatencyMode: s
			} = this.config, o = this.hls.userConfig, l = s && i || t;
			(o.liveSyncDuration || o.liveSyncDurationCount || 0 === l) && (l = void 0 !== r ? r : n * a);
			let d = a;
			return l + Math.min(1 * this.stallCount, d)
		}

		get liveSyncPosition() {
			let e = this.estimateLiveEdge(), t = this.targetLatency, i = this.levelDetails;
			if (null === e || null === t || null === i) return null;
			let a = i.edge, r = e - t - this.edgeStalled, n = a - i.totalduration,
				s = a - (this.config.lowLatencyMode && i.partTarget || i.targetduration);
			return Math.min(Math.max(n, r), s)
		}

		get drift() {
			let {levelDetails: e} = this;
			return null === e ? 1 : e.drift
		}

		get edgeStalled() {
			let {levelDetails: e} = this;
			if (null === e) return 0;
			let t = 3 * (this.config.lowLatencyMode && e.partTarget || e.targetduration);
			return Math.max(e.age - t, 0)
		}

		get forwardBufferLength() {
			let {media: e, levelDetails: t} = this;
			if (!e || !t) return 0;
			let i = e.buffered.length;
			return (i ? e.buffered.end(i - 1) : t.edge) - this.currentTime
		}

		destroy() {
			this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null
		}

		registerListeners() {
			this.hls.on(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(Tf.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(Tf.ERROR, this.onError, this)
		}

		unregisterListeners() {
			this.hls.off(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(Tf.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.off(Tf.ERROR, this.onError, this)
		}

		onMediaAttached(e, t) {
			this.media = t.media, this.media.addEventListener("timeupdate", this.timeupdateHandler)
		}

		onMediaDetaching() {
			this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null)
		}

		onManifestLoading() {
			this.levelDetails = null, this._latency = null, this.stallCount = 0
		}

		onLevelUpdated(e, {details: t}) {
			this.levelDetails = t, t.advanced && this.timeupdate(), !t.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler)
		}

		onError(e, t) {
			var i;
			t.details === _f.BUFFER_STALLED_ERROR && (this.stallCount++, null != (i = this.levelDetails) && i.live && Rf.warn("[playback-rate-controller]: Stall detected, adjusting target latency"))
		}

		timeupdate() {
			let {media: e, levelDetails: t} = this;
			if (!e || !t) return;
			this.currentTime = e.currentTime;
			let i = this.computeLatency();
			if (null === i) return;
			this._latency = i;
			let {lowLatencyMode: a, maxLiveSyncPlaybackRate: r} = this.config;
			if (!a || 1 === r || !t.live) return;
			let n = this.targetLatency;
			if (null === n) return;
			let s = i - n;
			if (s < Math.min(this.maxLatency, n + t.targetduration) && s > .05 && this.forwardBufferLength > 1) {
				let t = Math.min(2, Math.max(1, r)),
					i = Math.round(2 / (1 + Math.exp(-.75 * s - this.edgeStalled)) * 20) / 20;
				e.playbackRate = Math.min(t, Math.max(1, i))
			} else 1 !== e.playbackRate && 0 !== e.playbackRate && (e.playbackRate = 1)
		}

		estimateLiveEdge() {
			let {levelDetails: e} = this;
			return null === e ? null : e.edge + e.age
		}

		computeLatency() {
			let e = this.estimateLiveEdge();
			return null === e ? null : e - this.currentTime
		}
	}, Kg = ["NONE", "TYPE-0", "TYPE-1", null];
	var qg = ["SDR", "PQ", "HLG"];
	var Yg = "", jg = "YES", zg = "v2";

	function Xg(e) {
		let {canSkipUntil: t, canSkipDateRanges: i, age: a} = e;
		return t && a < t / 2 ? i ? zg : jg : Yg
	}

	var Qg = class {
		constructor(e, t, i) {
			this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = i
		}

		addDirectives(e) {
			let t = new self.URL(e);
			return void 0 !== this.msn && t.searchParams.set("_HLS_msn", this.msn.toString()), void 0 !== this.part && t.searchParams.set("_HLS_part", this.part.toString()), this.skip && t.searchParams.set("_HLS_skip", this.skip), t.href
		}
	}, Zg = class {
		constructor(e) {
			this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.url = void 0, this.frameRate = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.supportedPromise = void 0, this.supportedResult = void 0, this._avgBitrate = 0, this._audioGroups = void 0, this._subtitleGroups = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.frameRate = e.attrs.optionalFloat("FRAME-RATE", 0), this._avgBitrate = e.attrs.decimalInteger("AVERAGE-BANDWIDTH"), this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.codecSet = [e.videoCodec, e.audioCodec].filter((e => !!e)).map((e => e.substring(0, 4))).join(","), this.addGroupId("audio", e.attrs.AUDIO), this.addGroupId("text", e.attrs.SUBTITLES)
		}

		get maxBitrate() {
			return Math.max(this.realBitrate, this.bitrate)
		}

		get averageBitrate() {
			return this._avgBitrate || this.realBitrate || this.bitrate
		}

		get attrs() {
			return this._attrs[0]
		}

		get codecs() {
			return this.attrs.CODECS || ""
		}

		get pathwayId() {
			return this.attrs["PATHWAY-ID"] || "."
		}

		get videoRange() {
			return this.attrs["VIDEO-RANGE"] || "SDR"
		}

		get score() {
			return this.attrs.optionalFloat("SCORE", 0)
		}

		get uri() {
			return this.url[0] || ""
		}

		get audioGroups() {
			return this._audioGroups
		}

		get subtitleGroups() {
			return this._subtitleGroups
		}

		get urlId() {
			return 0
		}

		set urlId(e) {
		}

		get audioGroupIds() {
			return this.audioGroups ? [this.audioGroupId] : void 0
		}

		get textGroupIds() {
			return this.subtitleGroups ? [this.textGroupId] : void 0
		}

		get audioGroupId() {
			var e;
			return null == (e = this.audioGroups) ? void 0 : e[0]
		}

		get textGroupId() {
			var e;
			return null == (e = this.subtitleGroups) ? void 0 : e[0]
		}

		hasAudioGroup(e) {
			return Jg(this._audioGroups, e)
		}

		hasSubtitleGroup(e) {
			return Jg(this._subtitleGroups, e)
		}

		addGroupId(e, t) {
			if (t) if ("audio" === e) {
				let e = this._audioGroups;
				e || (e = this._audioGroups = []), -1 === e.indexOf(t) && e.push(t)
			} else if ("text" === e) {
				let e = this._subtitleGroups;
				e || (e = this._subtitleGroups = []), -1 === e.indexOf(t) && e.push(t)
			}
		}

		addFallback() {
		}
	};

	function Jg(e, t) {
		return !(!t || !e) && -1 !== e.indexOf(t)
	}

	function ev(e, t) {
		let i = t.startPTS;
		if (Ef(i)) {
			let a, r = 0;
			t.sn > e.sn ? (r = i - e.start, a = e) : (r = e.start - i, a = t), a.duration !== r && (a.duration = r)
		} else t.sn > e.sn ? e.cc === t.cc && e.minEndPTS ? t.start = e.start + (e.minEndPTS - e.start) : t.start = e.start + e.duration : t.start = Math.max(e.start - t.duration, 0)
	}

	function tv(e, t, i, a, r, n) {
		a - i <= 0 && (Rf.warn("Fragment should have a positive duration", t), a = i + t.duration, n = r + t.duration);
		let s = i, o = a, l = t.startPTS, d = t.endPTS;
		if (Ef(l)) {
			let e = Math.abs(l - i);
			Ef(t.deltaPTS) ? t.deltaPTS = Math.max(e, t.deltaPTS) : t.deltaPTS = e, s = Math.max(i, l), i = Math.min(i, l), r = Math.min(r, t.startDTS), o = Math.min(a, d), a = Math.max(a, d), n = Math.max(n, t.endDTS)
		}
		let u = i - t.start;
		0 !== t.start && (t.start = i), t.duration = a - t.start, t.startPTS = i, t.maxStartPTS = s, t.startDTS = r, t.endPTS = a, t.minEndPTS = o, t.endDTS = n;
		let h = t.sn;
		if (!e || h < e.startSN || h > e.endSN) return 0;
		let c, m = h - e.startSN, f = e.fragments;
		for (f[m] = t, c = m; c > 0; c--) ev(f[c], f[c - 1]);
		for (c = m; c < f.length - 1; c++) ev(f[c], f[c + 1]);
		return e.fragmentHint && ev(f[f.length - 1], e.fragmentHint), e.PTSKnown = e.alignedSliding = !0, u
	}

	function iv(e, t) {
		let i = null, a = e.fragments;
		for (let e = a.length - 1; e >= 0; e--) {
			let t = a[e].initSegment;
			if (t) {
				i = t;
				break
			}
		}
		e.fragmentHint && delete e.fragmentHint.endPTS;
		let r, n = 0;
		if (function (e, t, i) {
			let a = t.skippedSegments, r = Math.max(e.startSN, t.startSN) - t.startSN,
				n = (e.fragmentHint ? 1 : 0) + (a ? t.endSN : Math.min(e.endSN, t.endSN)) - t.startSN,
				s = t.startSN - e.startSN, o = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments,
				l = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments;
			for (let e = r; e <= n; e++) {
				let r = l[s + e], n = o[e];
				a && !n && e < a && (n = t.fragments[e] = r), r && n && i(r, n)
			}
		}(e, t, ((e, a) => {
			e.relurl && (n = e.cc - a.cc), Ef(e.startPTS) && Ef(e.endPTS) && (a.start = a.startPTS = e.startPTS, a.startDTS = e.startDTS, a.maxStartPTS = e.maxStartPTS, a.endPTS = e.endPTS, a.endDTS = e.endDTS, a.minEndPTS = e.minEndPTS, a.duration = e.endPTS - e.startPTS, a.duration && (r = a), t.PTSKnown = t.alignedSliding = !0), a.elementaryStreams = e.elementaryStreams, a.loader = e.loader, a.stats = e.stats, e.initSegment && (a.initSegment = e.initSegment, i = e.initSegment)
		})), i && (t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments).forEach((e => {
			var t;
			e && (!e.initSegment || e.initSegment.relurl === (null == (t = i) ? void 0 : t.relurl)) && (e.initSegment = i)
		})), t.skippedSegments) if (t.deltaUpdateFailed = t.fragments.some((e => !e)), t.deltaUpdateFailed) {
			Rf.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
			for (let e = t.skippedSegments; e--;) t.fragments.shift();
			t.startSN = t.fragments[0].sn, t.startCC = t.fragments[0].cc
		} else t.canSkipDateRanges && (t.dateRanges = function (e, t, i) {
			let a = vf({}, e);
			return i && i.forEach((e => {
				delete a[e]
			})), Object.keys(t).forEach((e => {
				let i = new Of(t[e].attr, a[e]);
				i.isValid ? a[e] = i : Rf.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(t[e].attr)}"`)
			})), a
		}(e.dateRanges, t.dateRanges, t.recentlyRemovedDateranges));
		let s = t.fragments;
		if (n) {
			Rf.warn("discontinuity sliding from playlist, take drift into account");
			for (let e = 0; e < s.length; e++) s[e].cc += n
		}
		t.skippedSegments && (t.startCC = t.fragments[0].cc), function (e, t, i) {
			if (e && t) {
				let a = 0;
				for (let r = 0, n = e.length; r <= n; r++) {
					let n = e[r], s = t[r + a];
					n && s && n.index === s.index && n.fragment.sn === s.fragment.sn ? i(n, s) : a--
				}
			}
		}(e.partList, t.partList, ((e, t) => {
			t.elementaryStreams = e.elementaryStreams, t.stats = e.stats
		})), r ? tv(t, r, r.startPTS, r.endPTS, r.startDTS, r.endDTS) : av(e, t), s.length && (t.totalduration = t.edge - s[0].start), t.driftStartTime = e.driftStartTime, t.driftStart = e.driftStart;
		let o = t.advancedDateTime;
		if (t.advanced && o) {
			let e = t.edge;
			t.driftStart || (t.driftStartTime = o, t.driftStart = e), t.driftEndTime = o, t.driftEnd = e
		} else t.driftEndTime = e.driftEndTime, t.driftEnd = e.driftEnd, t.advancedDateTime = e.advancedDateTime
	}

	function av(e, t) {
		let i = t.startSN + t.skippedSegments - e.startSN, a = e.fragments;
		i < 0 || i >= a.length || rv(t, a[i].start)
	}

	function rv(e, t) {
		if (t) {
			let i = e.fragments;
			for (let a = e.skippedSegments; a < i.length; a++) i[a].start += t;
			e.fragmentHint && (e.fragmentHint.start += t)
		}
	}

	function nv(e, t, i) {
		var a;
		return null != e && e.details ? sv(null == (a = e.details) ? void 0 : a.partList, t, i) : null
	}

	function sv(e, t, i) {
		if (e) for (let a = e.length; a--;) {
			let r = e[a];
			if (r.index === i && r.fragment.sn === t) return r
		}
		return null
	}

	function ov(e) {
		e.forEach(((e, t) => {
			let {details: i} = e;
			null != i && i.fragments && i.fragments.forEach((e => {
				e.level = t
			}))
		}))
	}

	function lv(e) {
		switch (e.details) {
			case _f.FRAG_LOAD_TIMEOUT:
			case _f.KEY_LOAD_TIMEOUT:
			case _f.LEVEL_LOAD_TIMEOUT:
			case _f.MANIFEST_LOAD_TIMEOUT:
				return !0
		}
		return !1
	}

	function dv(e, t) {
		let i = lv(t);
		return e.default[(i ? "timeout" : "error") + "Retry"]
	}

	function uv(e, t) {
		let i = "linear" === e.backoff ? 1 : Math.pow(2, t);
		return Math.min(i * e.retryDelayMs, e.maxRetryDelayMs)
	}

	function hv(e) {
		return ff(ff({}, e), {errorRetry: null, timeoutRetry: null})
	}

	function cv(e, t, i, a) {
		if (!e) return !1;
		let r = null == a ? void 0 : a.code, n = t < e.maxNumRetry && (function (e) {
			return 0 === e && !1 === navigator.onLine || !!e && (e < 400 || e > 499)
		}(r) || !!i);
		return e.shouldRetry ? e.shouldRetry(e, t, i, a, n) : n
	}

	var mv = function (e, t) {
		let i = 0, a = e.length - 1, r = null, n = null;
		for (; i <= a;) {
			r = (i + a) / 2 | 0, n = e[r];
			let s = t(n);
			if (s > 0) i = r + 1; else {
				if (!(s < 0)) return n;
				a = r - 1
			}
		}
		return null
	};

	function fv(e, t, i = 0, a = 0) {
		let r = null;
		if (e) {
			r = t[e.sn - t[0].sn + 1] || null;
			let a = e.endDTS - i;
			a > 0 && a < 15e-7 && (i += 15e-7)
		} else 0 === i && 0 === t[0].start && (r = t[0]);
		if (r && (!e || e.level === r.level) && 0 === pv(i, a, r)) return r;
		let n = mv(t, pv.bind(null, i, a));
		return !n || n === e && r ? r : n
	}

	function pv(e = 0, t = 0, i) {
		if (i.start <= e && i.start + i.duration > e) return 0;
		let a = Math.min(t, i.duration + (i.deltaPTS ? i.deltaPTS : 0));
		return i.start + i.duration - a <= e ? 1 : i.start - a > e && i.start ? -1 : 0
	}

	function gv(e, t, i) {
		let a = 1e3 * Math.min(t, i.duration + (i.deltaPTS ? i.deltaPTS : 0));
		return (i.endProgramDateTime || 0) - a > e
	}

	var vv = 0, Ev = 2, bv = 3, yv = 5, Tv = 0, Av = 1, _v = 2, kv = class {
			constructor(e, t) {
				this.hls = void 0, this.timer = -1, this.requestScheduled = -1, this.canLoad = !1, this.log = void 0, this.warn = void 0, this.log = Rf.log.bind(Rf, `${t}:`), this.warn = Rf.warn.bind(Rf, `${t}:`), this.hls = e
			}

			destroy() {
				this.clearTimer(), this.hls = this.log = this.warn = null
			}

			clearTimer() {
				-1 !== this.timer && (self.clearTimeout(this.timer), this.timer = -1)
			}

			startLoad() {
				this.canLoad = !0, this.requestScheduled = -1, this.loadPlaylist()
			}

			stopLoad() {
				this.canLoad = !1, this.clearTimer()
			}

			switchParams(e, t, i) {
				let a = null == t ? void 0 : t.renditionReports;
				if (a) {
					let r = -1;
					for (let i = 0; i < a.length; i++) {
						let n, s = a[i];
						try {
							n = new self.URL(s.URI, t.url).href
						} catch (e) {
							Rf.warn(`Could not construct new URL for Rendition Report: ${e}`), n = s.URI || ""
						}
						if (n === e) {
							r = i;
							break
						}
						n === e.substring(0, n.length) && (r = i)
					}
					if (-1 !== r) {
						let e = a[r], n = parseInt(e["LAST-MSN"]) || (null == t ? void 0 : t.lastPartSn),
							s = parseInt(e["LAST-PART"]) || (null == t ? void 0 : t.lastPartIndex);
						if (this.hls.config.lowLatencyMode) {
							let e = Math.min(t.age - t.partTarget, t.targetduration);
							s >= 0 && e > t.partTarget && (s += 1)
						}
						let o = i && Xg(i);
						return new Qg(n, s >= 0 ? s : void 0, o)
					}
				}
			}

			loadPlaylist(e) {
				-1 === this.requestScheduled && (this.requestScheduled = self.performance.now())
			}

			shouldLoadPlaylist(e) {
				return this.canLoad && !!e && !!e.url && (!e.details || e.details.live)
			}

			shouldReloadPlaylist(e) {
				return -1 === this.timer && -1 === this.requestScheduled && this.shouldLoadPlaylist(e)
			}

			playlistLoaded(e, t, i) {
				let {details: a, stats: r} = t, n = self.performance.now(),
					s = r.loading.first ? Math.max(0, n - r.loading.first) : 0;
				if (a.advancedDateTime = Date.now() - s, a.live || null != i && i.live) {
					if (a.reloaded(i), i && this.log(`live playlist ${e} ${a.advanced ? "REFRESHED " + a.lastPartSn + "-" + a.lastPartIndex : a.updated ? "UPDATED" : "MISSED"}`), i && a.fragments.length > 0 && iv(i, a), !this.canLoad || !a.live) return;
					let s, o, l;
					if (a.canBlockReload && a.endSN && a.advanced) {
						let e = this.hls.config.lowLatencyMode, r = a.lastPartSn, n = a.endSN, d = a.lastPartIndex,
							u = r === n;
						-1 !== d ? (o = u ? n + 1 : r, l = u ? e ? 0 : d : d + 1) : o = n + 1;
						let h = a.age, c = h + a.ageHeader, m = Math.min(c - a.partTarget, 1.5 * a.targetduration);
						if (m > 0) {
							if (i && m > i.tuneInGoal) this.warn(`CDN Tune-in goal increased from: ${i.tuneInGoal} to: ${m} with playlist age: ${a.age}`), m = 0; else {
								let e = Math.floor(m / a.targetduration);
								if (o += e, void 0 !== l) {
									l += Math.round(m % a.targetduration / a.partTarget)
								}
								this.log(`CDN Tune-in age: ${a.ageHeader}s last advanced ${h.toFixed(2)}s goal: ${m} skip sn ${e} to part ${l}`)
							}
							a.tuneInGoal = m
						}
						if (s = this.getDeliveryDirectives(a, t.deliveryDirectives, o, l), e || !u) return void this.loadPlaylist(s)
					} else (a.canBlockReload || a.canSkipUntil) && (s = this.getDeliveryDirectives(a, t.deliveryDirectives, o, l));
					let d = this.hls.mainForwardBufferInfo, u = d ? d.end - d.len : 0, h = function (e, t = 1 / 0) {
						let i = 1e3 * e.targetduration;
						if (e.updated) {
							let a = e.fragments, r = 4;
							if (a.length && i * r > t) {
								let e = 1e3 * a[a.length - 1].duration;
								e < i && (i = e)
							}
						} else i /= 2;
						return Math.round(i)
					}(a, 1e3 * (a.edge - u));
					a.updated && n > this.requestScheduled + h && (this.requestScheduled = r.loading.start), void 0 !== o && a.canBlockReload ? this.requestScheduled = r.loading.first + h - (1e3 * a.partTarget || 1e3) : -1 === this.requestScheduled || this.requestScheduled + h < n ? this.requestScheduled = n : this.requestScheduled - n <= 0 && (this.requestScheduled += h);
					let c = this.requestScheduled - n;
					c = Math.max(0, c), this.log(`reload live playlist ${e} in ${Math.round(c)} ms`), this.timer = self.setTimeout((() => this.loadPlaylist(s)), c)
				} else this.clearTimer()
			}

			getDeliveryDirectives(e, t, i, a) {
				let r = Xg(e);
				return null != t && t.skip && e.deltaUpdateFailed && (i = t.msn, a = t.part, r = Yg), new Qg(i, a, r)
			}

			checkRetry(e) {
				let t = e.details, i = lv(e), a = e.errorAction, {action: r, retryCount: n = 0, retryConfig: s} = a || {},
					o = !!a && !!s && (r === yv || !a.resolved && r === Ev);
				if (o) {
					var l;
					if (this.requestScheduled = -1, n >= s.maxNumRetry) return !1;
					if (i && null != (l = e.context) && l.deliveryDirectives) this.warn(`Retrying playlist loading ${n + 1}/${s.maxNumRetry} after "${t}" without delivery-directives`), this.loadPlaylist(); else {
						let e = uv(s, n);
						this.timer = self.setTimeout((() => this.loadPlaylist()), e), this.warn(`Retrying playlist loading ${n + 1}/${s.maxNumRetry} after "${t}" in ${e}ms`)
					}
					e.levelRetry = !0, a.resolved = !0
				}
				return o
			}
		}, Sv = class {
			constructor(e, t = 0, i = 0) {
				this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = i
			}

			sample(e, t) {
				let i = Math.pow(this.alpha_, e);
				this.estimate_ = t * (1 - i) + i * this.estimate_, this.totalWeight_ += e
			}

			getTotalWeight() {
				return this.totalWeight_
			}

			getEstimate() {
				if (this.alpha_) {
					let e = 1 - Math.pow(this.alpha_, this.totalWeight_);
					if (e) return this.estimate_ / e
				}
				return this.estimate_
			}
		}, wv = {supported: !0, configurations: [], decodingInfoResults: [{supported: !0, powerEfficient: !0, smooth: !0}]},
		Lv = {};

	function Rv(e, t, i, a, r, n) {
		let s = e.audioCodec ? e.audioGroups : null, o = null == n ? void 0 : n.audioCodec,
			l = null == n ? void 0 : n.channels, d = l ? parseInt(l) : o ? 1 / 0 : 2, u = null;
		if (null != s && s.length) try {
			u = 1 === s.length && s[0] ? t.groups[s[0]].channels : s.reduce(((e, i) => {
				if (i) {
					let a = t.groups[i];
					if (!a) throw new Error(`Audio track group ${i} not found`);
					Object.keys(a.channels).forEach((t => {
						e[t] = (e[t] || 0) + a.channels[t]
					}))
				}
				return e
			}), {2: 0})
		} catch {
			return !0
		}
		return void 0 !== e.videoCodec && (e.width > 1920 && e.height > 1088 || e.height > 1920 && e.width > 1088 || e.frameRate > Math.max(a, 30) || "SDR" !== e.videoRange && e.videoRange !== i || e.bitrate > Math.max(r, 8e6)) || !!u && Ef(d) && Object.keys(u).some((e => parseInt(e) > d))
	}

	function Iv(e, t, i) {
		let a = e.videoCodec, r = e.audioCodec;
		if (!a || !r || !i) return Promise.resolve(wv);
		let n = {
			width: e.width,
			height: e.height,
			bitrate: Math.ceil(Math.max(.9 * e.bitrate, e.averageBitrate)),
			framerate: e.frameRate || 30
		}, s = e.videoRange;
		"SDR" !== s && (n.transferFunction = s.toLowerCase());
		let o = a.split(",").map((e => ({
			type: "media-source",
			video: ff(ff({}, n), {}, {contentType: ig(e, "video")})
		})));
		return r && e.audioGroups && e.audioGroups.forEach((e => {
			var i;
			e && (null == (i = t.groups[e]) || i.tracks.forEach((t => {
				if (t.groupId === e) {
					let e = t.channels || "", i = parseFloat(e);
					Ef(i) && i > 2 && o.push.apply(o, r.split(",").map((e => ({
						type: "media-source",
						audio: {contentType: ig(e, "audio"), channels: "" + i}
					}))))
				}
			})))
		})), Promise.all(o.map((e => {
			let t = function (e) {
				let {audio: t, video: i} = e, a = i || t;
				if (a) {
					let e = a.contentType.split('"')[1];
					if (i) return `r${i.height}x${i.width}f${Math.ceil(i.framerate)}${i.transferFunction || "sd"}_${e}_${Math.ceil(i.bitrate / 1e5)}`;
					if (t) return `c${t.channels}${t.spatialRendering ? "s" : "n"}_${e}`
				}
				return ""
			}(e);
			return Lv[t] || (Lv[t] = i.decodingInfo(e))
		}))).then((e => ({
			supported: !e.some((e => !e.supported)),
			configurations: o,
			decodingInfoResults: e
		}))).catch((e => ({supported: !1, configurations: o, decodingInfoResults: [], error: e})))
	}

	function Dv(e, t) {
		let i = !1, a = [];
		return e && (i = "SDR" !== e, a = [e]), t && (a = t.allowedVideoRanges || qg.slice(0), i = void 0 !== t.preferHDR ? t.preferHDR : function () {
			if ("function" == typeof matchMedia) {
				let e = matchMedia("(dynamic-range: high)"), t = matchMedia("bad query");
				if (e.media !== t.media) return !0 === e.matches
			}
			return !1
		}(), a = i ? a.filter((e => "SDR" !== e)) : ["SDR"]), {preferHDR: i, allowedVideoRanges: a}
	}

	function Cv(e, t) {
		Rf.log(`[abr] start candidates with "${e}" ignored because ${t}`)
	}

	function xv(e, t, i) {
		if ("attrs" in e) {
			let i = t.indexOf(e);
			if (-1 !== i) return i
		}
		for (let a = 0; a < t.length; a++) {
			if (Mv(e, t[a], i)) return a
		}
		return -1
	}

	function Mv(e, t, i) {
		let {groupId: a, name: r, lang: n, assocLang: s, characteristics: o, default: l} = e, d = e.forced;
		return (void 0 === a || t.groupId === a) && (void 0 === r || t.name === r) && (void 0 === n || t.lang === n) && (void 0 === n || t.assocLang === s) && (void 0 === l || t.default === l) && (void 0 === d || t.forced === d) && (void 0 === o || function (e, t = "") {
			let i = e.split(","), a = t.split(",");
			return i.length === a.length && !i.some((e => -1 === a.indexOf(e)))
		}(o, t.characteristics)) && (void 0 === i || i(e, t))
	}

	function Ov(e, t) {
		let {audioCodec: i, channels: a} = e;
		return !(void 0 !== i && (t.audioCodec || "").substring(0, 4) !== i.substring(0, 4) || void 0 !== a && a !== (t.channels || "2"))
	}

	function Pv(e, t, i) {
		for (let a = t; a; a--) if (i(e[a])) return a;
		for (let a = t + 1; a < e.length; a++) if (i(e[a])) return a;
		return -1
	}

	var Nv = class {
		constructor() {
			this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this)
		}

		destroy() {
			this.onHandlerDestroying(), this.onHandlerDestroyed()
		}

		onHandlerDestroying() {
			this.clearNextTick(), this.clearInterval()
		}

		onHandlerDestroyed() {
		}

		hasInterval() {
			return !!this._tickInterval
		}

		hasNextTick() {
			return !!this._tickTimer
		}

		setInterval(e) {
			return !this._tickInterval && (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0)
		}

		clearInterval() {
			return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, !0)
		}

		clearNextTick() {
			return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0)
		}

		tick() {
			this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0)
		}

		tickImmediate() {
			this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0)
		}

		doTick() {
		}
	}, Uv = "NOT_LOADED", Fv = "APPENDING", Bv = "PARTIAL", $v = "OK";

	function Hv(e) {
		var t, i, a;
		return e.buffered && (e.body.gap || (null == (t = e.range.video) ? void 0 : t.partial) || (null == (i = e.range.audio) ? void 0 : i.partial) || (null == (a = e.range.audiovideo) ? void 0 : a.partial))
	}

	function Wv(e) {
		return `${e.type}_${e.level}_${e.sn}`
	}

	var Gv = {length: 0, start: () => 0, end: () => 0}, Vv = class e {
		static isBuffered(t, i) {
			try {
				if (t) {
					let a = e.getBuffered(t);
					for (let e = 0; e < a.length; e++) if (i >= a.start(e) && i <= a.end(e)) return !0
				}
			} catch {
			}
			return !1
		}

		static bufferInfo(t, i, a) {
			try {
				if (t) {
					let r, n = e.getBuffered(t), s = [];
					for (r = 0; r < n.length; r++) s.push({start: n.start(r), end: n.end(r)});
					return this.bufferedInfo(s, i, a)
				}
			} catch {
			}
			return {len: 0, start: i, end: i, nextStart: void 0}
		}

		static bufferedInfo(e, t, i) {
			t = Math.max(0, t), e.sort((function (e, t) {
				return e.start - t.start || t.end - e.end
			}));
			let a = [];
			if (i) for (let t = 0; t < e.length; t++) {
				let r = a.length;
				if (r) {
					let n = a[r - 1].end;
					e[t].start - n < i ? e[t].end > n && (a[r - 1].end = e[t].end) : a.push(e[t])
				} else a.push(e[t])
			} else a = e;
			let r, n = 0, s = t, o = t;
			for (let e = 0; e < a.length; e++) {
				let l = a[e].start, d = a[e].end;
				if (t + i >= l && t < d) s = l, o = d, n = o - t; else if (t + i < l) {
					r = l;
					break
				}
			}
			return {len: n, start: s || 0, end: o || 0, nextStart: r}
		}

		static getBuffered(e) {
			try {
				return e.buffered
			} catch (e) {
				return Rf.log("failed to get media.buffered", e), Gv
			}
		}
	}, Kv = class {
		constructor(e, t, i, a = 0, r = -1, n = !1) {
			this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = {
				start: 0,
				executeStart: 0,
				executeEnd: 0,
				end: 0
			}, this.buffering = {
				audio: {start: 0, executeStart: 0, executeEnd: 0, end: 0},
				video: {start: 0, executeStart: 0, executeEnd: 0, end: 0},
				audiovideo: {start: 0, executeStart: 0, executeEnd: 0, end: 0}
			}, this.level = e, this.sn = t, this.id = i, this.size = a, this.part = r, this.partial = n
		}
	};

	function qv(e, t) {
		for (let a = 0, r = e.length; a < r; a++) {
			var i;
			if ((null == (i = e[a]) ? void 0 : i.cc) === t) return e[a]
		}
		return null
	}

	function Yv(e, t) {
		if (e) {
			let i = e.start + t;
			e.start = e.startPTS = i, e.endPTS = i + e.duration
		}
	}

	function jv(e, t) {
		let i = t.fragments;
		for (let t = 0, a = i.length; t < a; t++) Yv(i[t], e);
		t.fragmentHint && Yv(t.fragmentHint, e), t.alignedSliding = !0
	}

	function zv(e, t, i) {
		t && (function (e, t, i) {
			if (function (e, t, i) {
				return !(!t || !(i.endCC > i.startCC || e && e.cc < i.startCC))
			}(e, i, t)) {
				let e = function (e, t) {
					let i = e.fragments, a = t.fragments;
					if (!a.length || !i.length) return void Rf.log("No fragments to align");
					let r = qv(i, a[0].cc);
					if (r && (!r || r.startPTS)) return r;
					Rf.log("No frag in previous level to align on")
				}(i, t);
				e && Ef(e.start) && (Rf.log(`Adjusting PTS using last level due to CC increase within current level ${t.url}`), jv(e.start, t))
			}
		}(e, i, t), !i.alignedSliding && t && Xv(i, t), !i.alignedSliding && t && !i.skippedSegments && av(t, i))
	}

	function Xv(e, t) {
		if (!e.hasProgramDateTime || !t.hasProgramDateTime) return;
		let i = e.fragments, a = t.fragments;
		if (!i.length || !a.length) return;
		let r, n, s = Math.min(t.endCC, e.endCC);
		t.startCC < s && e.startCC < s && (r = qv(a, s), n = qv(i, s)), (!r || !n) && (r = a[Math.floor(a.length / 2)], n = qv(i, r.cc) || i[Math.floor(i.length / 2)]);
		let o = r.programDateTime, l = n.programDateTime;
		o && l && jv((l - o) / 1e3 - (n.start - r.start), e)
	}

	var Qv = Math.pow(2, 17);

	function Zv(e, t = null) {
		let i = t || e,
			a = {frag: e, part: t, responseType: "arraybuffer", url: i.url, headers: {}, rangeStart: 0, rangeEnd: 0},
			r = i.byteRangeStartOffset, n = i.byteRangeEndOffset;
		if (Ef(r) && Ef(n)) {
			var s;
			let t = r, i = n;
			if ("initSegment" === e.sn && "AES-128" === (null == (s = e.decryptdata) ? void 0 : s.method)) {
				let e = n - r;
				e % 16 && (i = n + (16 - e % 16)), 0 !== r && (a.resetIV = !0, t = r - 16)
			}
			a.rangeStart = t, a.rangeEnd = i
		}
		return a
	}

	function Jv(e, t) {
		let i = new Error(`GAP ${e.gap ? "tag" : "attribute"} found`),
			a = {type: Af.MEDIA_ERROR, details: _f.FRAG_GAP, fatal: !1, frag: e, error: i, networkDetails: null};
		return t && (a.part = t), (t || e).stats.aborted = !0, new eE(a)
	}

	var eE = class extends Error {
		constructor(e) {
			super(e.error.message), this.data = void 0, this.data = e
		}
	};
	var tE = class {
			constructor(e, {removePKCS7Padding: t = !0} = {}) {
				if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.useSoftware = e.enableSoftwareAES, this.removePKCS7Padding = t, t) try {
					let e = self.crypto;
					e && (this.subtle = e.subtle || e.webkitSubtle)
				} catch {
				}
				null === this.subtle && (this.useSoftware = !0)
			}

			destroy() {
				this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null
			}

			isSync() {
				return this.useSoftware
			}

			flush() {
				let {currentResult: e, remainderData: t} = this;
				if (!e || t) return this.reset(), null;
				let i = new Uint8Array(e);
				return this.reset(), this.removePKCS7Padding ? function (e) {
					let t = e.byteLength, i = t && new DataView(e.buffer).getUint8(t - 1);
					return i ? ip(e, 0, t - i) : e
				}(i) : i
			}

			reset() {
				this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null)
			}

			decrypt(e, t, i) {
				return this.useSoftware ? new Promise(((a, r) => {
					this.softwareDecrypt(new Uint8Array(e), t, i);
					let n = this.flush();
					n ? a(n.buffer) : r(new Error("[softwareDecrypt] Failed to decrypt data"))
				})) : this.webCryptoDecrypt(new Uint8Array(e), t, i)
			}

			softwareDecrypt(e, t, i) {
				let {currentIV: a, currentResult: r, remainderData: n} = this;
				this.logOnce("JS AES decrypt"), n && (e = Fp(n, e), this.remainderData = null);
				let s = this.getValidChunk(e);
				if (!s.length) return null;
				a && (i = a);
				let o = this.softwareDecrypter;
				o || (o = this.softwareDecrypter = new class {
					constructor() {
						this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable()
					}

					uint8ArrayToUint32Array_(e) {
						let t = new DataView(e), i = new Uint32Array(4);
						for (let e = 0; e < 4; e++) i[e] = t.getUint32(4 * e);
						return i
					}

					initTable() {
						let e = this.sBox, t = this.invSBox, i = this.subMix, a = i[0], r = i[1], n = i[2], s = i[3],
							o = this.invSubMix, l = o[0], d = o[1], u = o[2], h = o[3], c = new Uint32Array(256), m = 0,
							f = 0, p = 0;
						for (p = 0; p < 256; p++) c[p] = p < 128 ? p << 1 : p << 1 ^ 283;
						for (p = 0; p < 256; p++) {
							let i = f ^ f << 1 ^ f << 2 ^ f << 3 ^ f << 4;
							i = i >>> 8 ^ 255 & i ^ 99, e[m] = i, t[i] = m;
							let o = c[m], p = c[o], g = c[p], v = 257 * c[i] ^ 16843008 * i;
							a[m] = v << 24 | v >>> 8, r[m] = v << 16 | v >>> 16, n[m] = v << 8 | v >>> 24, s[m] = v, v = 16843009 * g ^ 65537 * p ^ 257 * o ^ 16843008 * m, l[i] = v << 24 | v >>> 8, d[i] = v << 16 | v >>> 16, u[i] = v << 8 | v >>> 24, h[i] = v, m ? (m = o ^ c[c[c[g ^ o]]], f ^= c[c[f]]) : m = f = 1
						}
					}

					expandKey(e) {
						let t = this.uint8ArrayToUint32Array_(e), i = !0, a = 0;
						for (; a < t.length && i;) i = t[a] === this.key[a], a++;
						if (i) return;
						this.key = t;
						let r = this.keySize = t.length;
						if (4 !== r && 6 !== r && 8 !== r) throw new Error("Invalid aes key size=" + r);
						let n, s, o, l, d = this.ksRows = 4 * (r + 6 + 1), u = this.keySchedule = new Uint32Array(d),
							h = this.invKeySchedule = new Uint32Array(d), c = this.sBox, m = this.rcon, f = this.invSubMix,
							p = f[0], g = f[1], v = f[2], E = f[3];
						for (n = 0; n < d; n++) n < r ? o = u[n] = t[n] : (l = o, n % r == 0 ? (l = l << 8 | l >>> 24, l = c[l >>> 24] << 24 | c[l >>> 16 & 255] << 16 | c[l >>> 8 & 255] << 8 | c[255 & l], l ^= m[n / r | 0] << 24) : r > 6 && n % r == 4 && (l = c[l >>> 24] << 24 | c[l >>> 16 & 255] << 16 | c[l >>> 8 & 255] << 8 | c[255 & l]), u[n] = o = (u[n - r] ^ l) >>> 0);
						for (s = 0; s < d; s++) n = d - s, l = 3 & s ? u[n] : u[n - 4], h[s] = s < 4 || n <= 4 ? l : p[c[l >>> 24]] ^ g[c[l >>> 16 & 255]] ^ v[c[l >>> 8 & 255]] ^ E[c[255 & l]], h[s] = h[s] >>> 0
					}

					networkToHostOrderSwap(e) {
						return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24
					}

					decrypt(e, t, i) {
						let a, r, n, s, o, l, d, u, h, c, m, f, p, g, v = this.keySize + 6, E = this.invKeySchedule,
							b = this.invSBox, y = this.invSubMix, T = y[0], A = y[1], _ = y[2], k = y[3],
							S = this.uint8ArrayToUint32Array_(i), w = S[0], L = S[1], R = S[2], I = S[3],
							D = new Int32Array(e), C = new Int32Array(D.length), x = this.networkToHostOrderSwap;
						for (; t < D.length;) {
							for (h = x(D[t]), c = x(D[t + 1]), m = x(D[t + 2]), f = x(D[t + 3]), o = h ^ E[0], l = f ^ E[1], d = m ^ E[2], u = c ^ E[3], p = 4, g = 1; g < v; g++) a = T[o >>> 24] ^ A[l >> 16 & 255] ^ _[d >> 8 & 255] ^ k[255 & u] ^ E[p], r = T[l >>> 24] ^ A[d >> 16 & 255] ^ _[u >> 8 & 255] ^ k[255 & o] ^ E[p + 1], n = T[d >>> 24] ^ A[u >> 16 & 255] ^ _[o >> 8 & 255] ^ k[255 & l] ^ E[p + 2], s = T[u >>> 24] ^ A[o >> 16 & 255] ^ _[l >> 8 & 255] ^ k[255 & d] ^ E[p + 3], o = a, l = r, d = n, u = s, p += 4;
							a = b[o >>> 24] << 24 ^ b[l >> 16 & 255] << 16 ^ b[d >> 8 & 255] << 8 ^ b[255 & u] ^ E[p], r = b[l >>> 24] << 24 ^ b[d >> 16 & 255] << 16 ^ b[u >> 8 & 255] << 8 ^ b[255 & o] ^ E[p + 1], n = b[d >>> 24] << 24 ^ b[u >> 16 & 255] << 16 ^ b[o >> 8 & 255] << 8 ^ b[255 & l] ^ E[p + 2], s = b[u >>> 24] << 24 ^ b[o >> 16 & 255] << 16 ^ b[l >> 8 & 255] << 8 ^ b[255 & d] ^ E[p + 3], C[t] = x(a ^ w), C[t + 1] = x(s ^ L), C[t + 2] = x(n ^ R), C[t + 3] = x(r ^ I), w = h, L = c, R = m, I = f, t += 4
						}
						return C.buffer
					}
				}), o.expandKey(t);
				let l = r;
				return this.currentResult = o.decrypt(s.buffer, 0, i), this.currentIV = ip(s, -16).buffer, l || null
			}

			webCryptoDecrypt(e, t, i) {
				let a = this.subtle;
				return (this.key !== t || !this.fastAesKey) && (this.key = t, this.fastAesKey = new class {
					constructor(e, t) {
						this.subtle = void 0, this.key = void 0, this.subtle = e, this.key = t
					}

					expandKey() {
						return this.subtle.importKey("raw", this.key, {name: "AES-CBC"}, !1, ["encrypt", "decrypt"])
					}
				}(a, t)), this.fastAesKey.expandKey().then((t => a ? (this.logOnce("WebCrypto AES decrypt"), new class {
					constructor(e, t) {
						this.subtle = void 0, this.aesIV = void 0, this.subtle = e, this.aesIV = t
					}

					decrypt(e, t) {
						return this.subtle.decrypt({name: "AES-CBC", iv: this.aesIV}, t, e)
					}
				}(a, new Uint8Array(i)).decrypt(e.buffer, t)) : Promise.reject(new Error("web crypto not initialized")))).catch((a => (Rf.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${a.name}: ${a.message}`), this.onWebCryptoError(e, t, i))))
			}

			onWebCryptoError(e, t, i) {
				this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, i);
				let a = this.flush();
				if (a) return a.buffer;
				throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data")
			}

			getValidChunk(e) {
				let t = e, i = e.length - e.length % 16;
				return i !== e.length && (t = ip(e, 0, i), this.remainderData = ip(e, i)), t
			}

			logOnce(e) {
				this.logEnabled && (Rf.log(`[decrypter]: ${e}`), this.logEnabled = !1)
			}
		}, iE = function (e) {
			let t = "", i = e.length;
			for (let a = 0; a < i; a++) t += `[${e.start(a).toFixed(3)}-${e.end(a).toFixed(3)}]`;
			return t
		}, aE = "STOPPED", rE = "IDLE", nE = "KEY_LOADING", sE = "FRAG_LOADING", oE = "FRAG_LOADING_WAITING_RETRY",
		lE = "WAITING_TRACK", dE = "PARSING", uE = "PARSED", hE = "ENDED", cE = "ERROR", mE = "WAITING_INIT_PTS",
		fE = "WAITING_LEVEL", pE = class extends Nv {
			constructor(e, t, i, a, r) {
				super(), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = aE, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.loadedmetadata = !1, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.onvseeking = null, this.onvended = null, this.logPrefix = "", this.log = void 0, this.warn = void 0, this.playlistType = r, this.logPrefix = a, this.log = Rf.log.bind(Rf, `${a}:`), this.warn = Rf.warn.bind(Rf, `${a}:`), this.hls = e, this.fragmentLoader = new class {
					constructor(e) {
						this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e
					}

					destroy() {
						this.loader && (this.loader.destroy(), this.loader = null)
					}

					abort() {
						this.loader && this.loader.abort()
					}

					load(e, t) {
						let i = e.url;
						if (!i) return Promise.reject(new eE({
							type: Af.NETWORK_ERROR,
							details: _f.FRAG_LOAD_ERROR,
							fatal: !1,
							frag: e,
							error: new Error("Fragment does not have a " + (i ? "part list" : "url")),
							networkDetails: null
						}));
						this.abort();
						let a = this.config, r = a.fLoader, n = a.loader;
						return new Promise(((s, o) => {
							if (this.loader && this.loader.destroy(), e.gap) {
								if (e.tagList.some((e => "GAP" === e[0]))) return void o(Jv(e));
								e.gap = !1
							}
							let l = this.loader = e.loader = r ? new r(a) : new n(a), d = Zv(e),
								u = hv(a.fragLoadPolicy.default), h = {
									loadPolicy: u,
									timeout: u.maxLoadTimeMs,
									maxRetry: 0,
									retryDelay: 0,
									maxRetryDelay: 0,
									highWaterMark: "initSegment" === e.sn ? 1 / 0 : Qv
								};
							e.stats = l.stats, l.load(d, h, {
								onSuccess: (t, i, a, r) => {
									this.resetLoader(e, l);
									let n = t.data;
									a.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(n.slice(0, 16)), n = n.slice(16)), s({
										frag: e,
										part: null,
										payload: n,
										networkDetails: r
									})
								}, onError: (t, a, r, n) => {
									this.resetLoader(e, l), o(new eE({
										type: Af.NETWORK_ERROR,
										details: _f.FRAG_LOAD_ERROR,
										fatal: !1,
										frag: e,
										response: ff({url: i, data: void 0}, t),
										error: new Error(`HTTP Error ${t.code} ${t.text}`),
										networkDetails: r,
										stats: n
									}))
								}, onAbort: (t, i, a) => {
									this.resetLoader(e, l), o(new eE({
										type: Af.NETWORK_ERROR,
										details: _f.INTERNAL_ABORTED,
										fatal: !1,
										frag: e,
										error: new Error("Aborted"),
										networkDetails: a,
										stats: t
									}))
								}, onTimeout: (t, i, a) => {
									this.resetLoader(e, l), o(new eE({
										type: Af.NETWORK_ERROR,
										details: _f.FRAG_LOAD_TIMEOUT,
										fatal: !1,
										frag: e,
										error: new Error(`Timeout after ${h.timeout}ms`),
										networkDetails: a,
										stats: t
									}))
								}, onProgress: (i, a, r, n) => {
									t && t({frag: e, part: null, payload: r, networkDetails: n})
								}
							})
						}))
					}

					loadPart(e, t, i) {
						this.abort();
						let a = this.config, r = a.fLoader, n = a.loader;
						return new Promise(((s, o) => {
							if (this.loader && this.loader.destroy(), e.gap || t.gap) return void o(Jv(e, t));
							let l = this.loader = e.loader = r ? new r(a) : new n(a), d = Zv(e, t),
								u = hv(a.fragLoadPolicy.default), h = {
									loadPolicy: u,
									timeout: u.maxLoadTimeMs,
									maxRetry: 0,
									retryDelay: 0,
									maxRetryDelay: 0,
									highWaterMark: Qv
								};
							t.stats = l.stats, l.load(d, h, {
								onSuccess: (a, r, n, o) => {
									this.resetLoader(e, l), this.updateStatsFromPart(e, t);
									let d = {frag: e, part: t, payload: a.data, networkDetails: o};
									i(d), s(d)
								}, onError: (i, a, r, n) => {
									this.resetLoader(e, l), o(new eE({
										type: Af.NETWORK_ERROR,
										details: _f.FRAG_LOAD_ERROR,
										fatal: !1,
										frag: e,
										part: t,
										response: ff({url: d.url, data: void 0}, i),
										error: new Error(`HTTP Error ${i.code} ${i.text}`),
										networkDetails: r,
										stats: n
									}))
								}, onAbort: (i, a, r) => {
									e.stats.aborted = t.stats.aborted, this.resetLoader(e, l), o(new eE({
										type: Af.NETWORK_ERROR,
										details: _f.INTERNAL_ABORTED,
										fatal: !1,
										frag: e,
										part: t,
										error: new Error("Aborted"),
										networkDetails: r,
										stats: i
									}))
								}, onTimeout: (i, a, r) => {
									this.resetLoader(e, l), o(new eE({
										type: Af.NETWORK_ERROR,
										details: _f.FRAG_LOAD_TIMEOUT,
										fatal: !1,
										frag: e,
										part: t,
										error: new Error(`Timeout after ${h.timeout}ms`),
										networkDetails: r,
										stats: i
									}))
								}
							})
						}))
					}

					updateStatsFromPart(e, t) {
						let i = e.stats, a = t.stats, r = a.total;
						if (i.loaded += a.loaded, r) {
							let a = Math.round(e.duration / t.duration), n = Math.min(Math.round(i.loaded / r), a),
								s = (a - n) * Math.round(i.loaded / n);
							i.total = i.loaded + s
						} else i.total = Math.max(i.loaded, i.total);
						let n = i.loading, s = a.loading;
						n.start ? n.first += s.first - s.start : (n.start = s.start, n.first = s.first), n.end = s.end
					}

					resetLoader(e, t) {
						e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy()
					}
				}(e.config), this.keyLoader = i, this.fragmentTracker = t, this.config = e.config, this.decrypter = new tE(e.config), e.on(Tf.MANIFEST_LOADED, this.onManifestLoaded, this)
			}

			get state() {
				return this._state
			}

			set state(e) {
				let t = this._state;
				t !== e && (this._state = e, this.log(`${t}->${e}`))
			}

			doTick() {
				this.onTickEnd()
			}

			onTickEnd() {
			}

			startLoad(e) {
			}

			stopLoad() {
				this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);
				let e = this.fragCurrent;
				null != e && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = aE
			}

			_streamEnded(e, t) {
				if (t.live || e.nextStart || !e.end || !this.media) return !1;
				let i = t.partList;
				if (null != i && i.length) {
					let e = i[i.length - 1];
					return Vv.isBuffered(this.media, e.start + e.duration / 2)
				}
				let a = t.fragments[t.fragments.length - 1].type;
				return this.fragmentTracker.isEndListAppended(a)
			}

			getLevelDetails() {
				var e;
				if (this.levels && null !== this.levelLastLoaded) return null == (e = this.levelLastLoaded) ? void 0 : e.details
			}

			onMediaAttached(e, t) {
				let i = this.media = this.mediaBuffer = t.media;
				this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), i.addEventListener("seeking", this.onvseeking), i.addEventListener("ended", this.onvended);
				let a = this.config;
				this.levels && a.autoStartLoad && this.state === aE && this.startLoad(a.startPosition)
			}

			onMediaDetaching() {
				let e = this.media;
				null != e && e.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), e && this.onvseeking && this.onvended && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvended = null), this.keyLoader && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad()
			}

			onMediaSeeking() {
				let {config: e, fragCurrent: t, media: i, mediaBuffer: a, state: r} = this, n = i ? i.currentTime : 0,
					s = Vv.bufferInfo(a || i, n, e.maxBufferHole);
				if (this.log(`media seeking to ${Ef(n) ? n.toFixed(3) : n}, state: ${r}`), this.state === hE) this.resetLoadingState(); else if (t) {
					let i = e.maxFragLookUpTolerance, a = t.start - i, r = t.start + t.duration + i;
					if (!s.len || r < s.start || a > s.end) {
						let e = n > r;
						(n < a || e) && (e && t.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), t.abortRequests(), this.resetLoadingState()), this.fragPrevious = null)
					}
				}
				i && (this.fragmentTracker.removeFragmentsInRange(n, 1 / 0, this.playlistType, !0), this.lastCurrentTime = n), !this.loadedmetadata && !s.len && (this.nextLoadPosition = this.startPosition = n), this.tickImmediate()
			}

			onMediaEnded() {
				this.startPosition = this.lastCurrentTime = 0
			}

			onManifestLoaded(e, t) {
				this.startTimeOffset = t.startTimeOffset, this.initPTS = []
			}

			onHandlerDestroying() {
				this.hls.off(Tf.MANIFEST_LOADED, this.onManifestLoaded, this), this.stopLoad(), super.onHandlerDestroying(), this.hls = null
			}

			onHandlerDestroyed() {
				this.state = aE, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed()
			}

			loadFragment(e, t, i) {
				this._loadFragForPlayback(e, t, i)
			}

			_loadFragForPlayback(e, t, i) {
				this._doFragLoad(e, t, i, (t => {
					if (this.fragContextChanged(e)) return this.warn(`Fragment ${e.sn}${t.part ? " p: " + t.part.index : ""} of level ${e.level} was dropped during download.`), void this.fragmentTracker.removeFragment(e);
					e.stats.chunkCount++, this._handleFragmentLoadProgress(t)
				})).then((t => {
					if (!t) return;
					let i = this.state;
					this.fragContextChanged(e) ? (i === sE || !this.fragCurrent && i === dE) && (this.fragmentTracker.removeFragment(e), this.state = rE) : ("payload" in t && (this.log(`Loaded fragment ${e.sn} of level ${e.level}`), this.hls.trigger(Tf.FRAG_LOADED, t)), this._handleFragmentLoadComplete(t))
				})).catch((t => {
					this.state === aE || this.state === cE || (this.warn(t), this.resetFragmentLoading(e))
				}))
			}

			clearTrackerIfNeeded(e) {
				var t;
				let {fragmentTracker: i} = this;
				if (i.getState(e) === Fv) {
					let t = e.type, a = this.getFwdBufferInfo(this.mediaBuffer, t),
						r = Math.max(e.duration, a ? a.len : this.config.maxBufferLength);
					this.reduceMaxBufferLength(r) && i.removeFragment(e)
				} else 0 === (null == (t = this.mediaBuffer) ? void 0 : t.buffered.length) ? i.removeAllFragments() : i.hasParts(e.type) && (i.detectPartialFragments({
					frag: e,
					part: null,
					stats: e.stats,
					id: e.type
				}), i.getState(e) === Bv && i.removeFragment(e))
			}

			checkLiveUpdate(e) {
				if (e.updated && !e.live) {
					let t = e.fragments[e.fragments.length - 1];
					this.fragmentTracker.detectPartialFragments({frag: t, part: null, stats: t.stats, id: t.type})
				}
				e.fragments[0] || (e.deltaUpdateFailed = !0)
			}

			flushMainBuffer(e, t, i = null) {
				if (!(e - t)) return;
				let a = {startOffset: e, endOffset: t, type: i};
				this.hls.trigger(Tf.BUFFER_FLUSHING, a)
			}

			_loadInitSegment(e, t) {
				this._doFragLoad(e, t).then((t => {
					if (!t || this.fragContextChanged(e) || !this.levels) throw new Error("init load aborted");
					return t
				})).then((t => {
					let {hls: i} = this, {payload: a} = t, r = e.decryptdata;
					if (a && a.byteLength > 0 && null != r && r.key && r.iv && "AES-128" === r.method) {
						let n = self.performance.now();
						return this.decrypter.decrypt(new Uint8Array(a), r.key.buffer, r.iv.buffer).catch((t => {
							throw i.trigger(Tf.ERROR, {
								type: Af.MEDIA_ERROR,
								details: _f.FRAG_DECRYPT_ERROR,
								fatal: !1,
								error: t,
								reason: t.message,
								frag: e
							}), t
						})).then((a => {
							let r = self.performance.now();
							return i.trigger(Tf.FRAG_DECRYPTED, {
								frag: e,
								payload: a,
								stats: {tstart: n, tdecrypt: r}
							}), t.payload = a, this.completeInitSegmentLoad(t)
						}))
					}
					return this.completeInitSegmentLoad(t)
				})).catch((t => {
					this.state === aE || this.state === cE || (this.warn(t), this.resetFragmentLoading(e))
				}))
			}

			completeInitSegmentLoad(e) {
				let {levels: t} = this;
				if (!t) throw new Error("init load aborted, missing levels");
				let i = e.frag.stats;
				this.state = rE, e.frag.data = new Uint8Array(e.payload), i.parsing.start = i.buffering.start = self.performance.now(), i.parsing.end = i.buffering.end = self.performance.now(), this.tick()
			}

			fragContextChanged(e) {
				let {fragCurrent: t} = this;
				return !e || !t || e.sn !== t.sn || e.level !== t.level
			}

			fragBufferedComplete(e, t) {
				var i, a, r, n;
				let s = this.mediaBuffer ? this.mediaBuffer : this.media;
				if (this.log(`Buffered ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.playlistType === wg ? "level" : "track"} ${e.level} (frag:[${(null != (i = e.startPTS) ? i : NaN).toFixed(3)}-${(null != (a = e.endPTS) ? a : NaN).toFixed(3)}] > buffer:${s ? iE(Vv.getBuffered(s)) : "(detached)"})`), "initSegment" !== e.sn) {
					var o;
					if (e.type !== Rg) {
						let t = e.elementaryStreams;
						if (!Object.keys(t).some((e => !!t[e]))) return void (this.state = rE)
					}
					let t = null == (o = this.levels) ? void 0 : o[e.level];
					null != t && t.fragmentError && (this.log(`Resetting level fragment error count of ${t.fragmentError} on frag buffered`), t.fragmentError = 0)
				}
				this.state = rE, s && (!this.loadedmetadata && e.type == wg && s.buffered.length && (null == (r = this.fragCurrent) ? void 0 : r.sn) === (null == (n = this.fragPrevious) ? void 0 : n.sn) && (this.loadedmetadata = !0, this.seekToStartPos()), this.tick())
			}

			seekToStartPos() {
			}

			_handleFragmentLoadComplete(e) {
				let {transmuxer: t} = this;
				if (!t) return;
				let {frag: i, part: a, partsLoaded: r} = e, n = !r || 0 === r.length || r.some((e => !e)),
					s = new Kv(i.level, i.sn, i.stats.chunkCount + 1, 0, a ? a.index : -1, !n);
				t.flush(s)
			}

			_handleFragmentLoadProgress(e) {
			}

			_doFragLoad(e, t, i = null, a) {
				var r;
				let n = null == t ? void 0 : t.details;
				if (!this.levels || !n) throw new Error(`frag load aborted, missing level${n ? "" : " detail"}s`);
				let s = null;
				if (!e.encrypted || null != (r = e.decryptdata) && r.key ? !e.encrypted && n.encryptedFragments.length && this.keyLoader.loadClear(e, n.encryptedFragments) : (this.log(`Loading key for ${e.sn} of [${n.startSN}-${n.endSN}], ${"[stream-controller]" === this.logPrefix ? "level" : "track"} ${e.level}`), this.state = nE, this.fragCurrent = e, s = this.keyLoader.load(e).then((e => {
					if (!this.fragContextChanged(e.frag)) return this.hls.trigger(Tf.KEY_LOADED, e), this.state === nE && (this.state = rE), e
				})), this.hls.trigger(Tf.KEY_LOADING, {frag: e}), null === this.fragCurrent && (s = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING")))), i = Math.max(e.start, i || 0), this.config.lowLatencyMode && "initSegment" !== e.sn) {
					let r = n.partList;
					if (r && a) {
						i > e.end && n.fragmentHint && (e = n.fragmentHint);
						let o = this.getNextPart(r, e, i);
						if (o > -1) {
							let l, d = r[o];
							return this.log(`Loading part sn: ${e.sn} p: ${d.index} cc: ${e.cc} of playlist [${n.startSN}-${n.endSN}] parts [0-${o}-${r.length - 1}] ${"[stream-controller]" === this.logPrefix ? "level" : "track"}: ${e.level}, target: ${parseFloat(i.toFixed(3))}`), this.nextLoadPosition = d.start + d.duration, this.state = sE, l = s ? s.then((i => !i || this.fragContextChanged(i.frag) ? null : this.doFragPartsLoad(e, d, t, a))).catch((e => this.handleFragLoadError(e))) : this.doFragPartsLoad(e, d, t, a).catch((e => this.handleFragLoadError(e))), this.hls.trigger(Tf.FRAG_LOADING, {
								frag: e,
								part: d,
								targetBufferTime: i
							}), null === this.fragCurrent ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : l
						}
						if (!e.url || this.loadedEndOfParts(r, i)) return Promise.resolve(null)
					}
				}
				this.log(`Loading fragment ${e.sn} cc: ${e.cc} ${n ? "of [" + n.startSN + "-" + n.endSN + "] " : ""}${"[stream-controller]" === this.logPrefix ? "level" : "track"}: ${e.level}, target: ${parseFloat(i.toFixed(3))}`), Ef(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = sE;
				let o, l = this.config.progressive;
				return o = l && s ? s.then((t => !t || this.fragContextChanged(null == t ? void 0 : t.frag) ? null : this.fragmentLoader.load(e, a))).catch((e => this.handleFragLoadError(e))) : Promise.all([this.fragmentLoader.load(e, l ? a : void 0), s]).then((([e]) => (!l && e && a && a(e), e))).catch((e => this.handleFragLoadError(e))), this.hls.trigger(Tf.FRAG_LOADING, {
					frag: e,
					targetBufferTime: i
				}), null === this.fragCurrent ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : o
			}

			doFragPartsLoad(e, t, i, a) {
				return new Promise(((r, n) => {
					var s;
					let o = [], l = null == (s = i.details) ? void 0 : s.partList, d = t => {
						this.fragmentLoader.loadPart(e, t, a).then((a => {
							o[t.index] = a;
							let n = a.part;
							this.hls.trigger(Tf.FRAG_LOADED, a);
							let s = nv(i, e.sn, t.index + 1) || sv(l, e.sn, t.index + 1);
							if (!s) return r({frag: e, part: n, partsLoaded: o});
							d(s)
						})).catch(n)
					};
					d(t)
				}))
			}

			handleFragLoadError(e) {
				if ("data" in e) {
					let t = e.data;
					e.data && t.details === _f.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(Tf.ERROR, t)
				} else this.hls.trigger(Tf.ERROR, {
					type: Af.OTHER_ERROR,
					details: _f.INTERNAL_EXCEPTION,
					err: e,
					error: e,
					fatal: !0
				});
				return null
			}

			_handleTransmuxerFlush(e) {
				let t = this.getCurrentContext(e);
				if (!t || this.state !== dE) return void (!this.fragCurrent && this.state !== aE && this.state !== cE && (this.state = rE));
				let {frag: i, part: a, level: r} = t, n = self.performance.now();
				i.stats.parsing.end = n, a && (a.stats.parsing.end = n), this.updateLevelTiming(i, a, r, e.partial)
			}

			getCurrentContext(e) {
				let {levels: t, fragCurrent: i} = this, {level: a, sn: r, part: n} = e;
				if (null == t || !t[a]) return this.warn(`Levels object was unset while buffering fragment ${r} of level ${a}. The current chunk will not be buffered.`), null;
				let s = t[a], o = n > -1 ? nv(s, r, n) : null, l = o ? o.fragment : function (e, t, i) {
					if (null == e || !e.details) return null;
					let a = e.details, r = a.fragments[t - a.startSN];
					return r || (r = a.fragmentHint, r && r.sn === t) ? r : t < a.startSN && i && i.sn === t ? i : null
				}(s, r, i);
				return l ? (i && i !== l && (l.stats = i.stats), {frag: l, part: o, level: s}) : null
			}

			bufferFragmentData(e, t, i, a, r) {
				var n;
				if (!e || this.state !== dE) return;
				let {data1: s, data2: o} = e, l = s;
				if (s && o && (l = Fp(s, o)), null == (n = l) || !n.length) return;
				let d = {type: e.type, frag: t, part: i, chunkMeta: a, parent: t.type, data: l};
				if (this.hls.trigger(Tf.BUFFER_APPENDING, d), e.dropped && e.independent && !i) {
					if (r) return;
					this.flushBufferGap(t)
				}
			}

			flushBufferGap(e) {
				let t = this.media;
				if (!t) return;
				if (!Vv.isBuffered(t, t.currentTime)) return void this.flushMainBuffer(0, e.start);
				let i = t.currentTime, a = Vv.bufferInfo(t, i, 0), r = e.duration,
					n = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * r),
					s = Math.max(Math.min(e.start - n, a.end - n), i + n);
				e.start - s > n && this.flushMainBuffer(s, e.start)
			}

			getFwdBufferInfo(e, t) {
				let i = this.getLoadPosition();
				return Ef(i) ? this.getFwdBufferInfoAtPos(e, i, t) : null
			}

			getFwdBufferInfoAtPos(e, t, i) {
				let {config: {maxBufferHole: a}} = this, r = Vv.bufferInfo(e, t, a);
				if (0 === r.len && void 0 !== r.nextStart) {
					let n = this.fragmentTracker.getBufferedFrag(t, i);
					if (n && r.nextStart < n.end) return Vv.bufferInfo(e, t, Math.max(r.nextStart, a))
				}
				return r
			}

			getMaxBufferLength(e) {
				let t, {config: i} = this;
				return t = e ? Math.max(8 * i.maxBufferSize / e, i.maxBufferLength) : i.maxBufferLength, Math.min(t, i.maxMaxBufferLength)
			}

			reduceMaxBufferLength(e) {
				let t = this.config, i = e || t.maxBufferLength;
				return t.maxMaxBufferLength >= i && (t.maxMaxBufferLength /= 2, this.warn(`Reduce max buffer length to ${t.maxMaxBufferLength}s`), !0)
			}

			getAppendedFrag(e, t = wg) {
				let i = this.fragmentTracker.getAppendedFrag(e, wg);
				return i && "fragment" in i ? i.fragment : i
			}

			getNextFragment(e, t) {
				let i = t.fragments, a = i.length;
				if (!a) return null;
				let r, {config: n} = this, s = i[0].start;
				if (t.live) {
					let o = n.initialLiveManifestSize;
					if (a < o) return this.warn(`Not enough fragments to start playback (have: ${a}, need: ${o})`), null;
					(!t.PTSKnown && !this.startFragRequested && -1 === this.startPosition || e < s) && (r = this.getInitialLiveFragment(t, i), this.startPosition = this.nextLoadPosition = r ? this.hls.liveSyncPosition || r.start : e)
				} else e <= s && (r = i[0]);
				if (!r) {
					let i = n.lowLatencyMode ? t.partEnd : t.fragmentEnd;
					r = this.getFragmentAtPosition(e, i, t)
				}
				return this.mapToInitFragWhenRequired(r)
			}

			isLoopLoading(e, t) {
				let i = this.fragmentTracker.getState(e);
				return (i === $v || i === Bv && !!e.gap) && this.nextLoadPosition > t
			}

			getNextFragmentLoopLoading(e, t, i, a, r) {
				let n = e.gap, s = this.getNextFragment(this.nextLoadPosition, t);
				if (null === s) return s;
				if (e = s, n && e && !e.gap && i.nextStart) {
					let t = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, i.nextStart, a);
					if (null !== t && i.len + t.len >= r) return this.log(`buffer full after gaps in "${a}" playlist starting at sn: ${e.sn}`), null
				}
				return e
			}

			mapToInitFragWhenRequired(e) {
				return null == e || !e.initSegment || null != e && e.initSegment.data || this.bitrateTest ? e : e.initSegment
			}

			getNextPart(e, t, i) {
				let a = -1, r = !1, n = !0;
				for (let s = 0, o = e.length; s < o; s++) {
					let o = e[s];
					if (n = n && !o.independent, a > -1 && i < o.start) break;
					let l = o.loaded;
					l ? a = -1 : (r || o.independent || n) && o.fragment === t && (a = s), r = l
				}
				return a
			}

			loadedEndOfParts(e, t) {
				let i = e[e.length - 1];
				return i && t > i.start && i.loaded
			}

			getInitialLiveFragment(e, t) {
				let i = this.fragPrevious, a = null;
				if (i) {
					if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${i.programDateTime}`), a = function (e, t, i) {
						if (null === t || !Array.isArray(e) || !e.length || !Ef(t)) return null;
						if (t < (e[0].programDateTime || 0)) return null;
						if (t >= (e[e.length - 1].endProgramDateTime || 0)) return null;
						i = i || 0;
						for (let a = 0; a < e.length; ++a) {
							let r = e[a];
							if (gv(t, i, r)) return r
						}
						return null
					}(t, i.endProgramDateTime, this.config.maxFragLookUpTolerance)), !a) {
						let r = i.sn + 1;
						if (r >= e.startSN && r <= e.endSN) {
							let n = t[r - e.startSN];
							i.cc === n.cc && (a = n, this.log(`Live playlist, switching playlist, load frag with next SN: ${a.sn}`))
						}
						a || (a = function (e, t) {
							return mv(e, (e => e.cc < t ? 1 : e.cc > t ? -1 : 0))
						}(t, i.cc), a && this.log(`Live playlist, switching playlist, load frag with same CC: ${a.sn}`))
					}
				} else {
					let t = this.hls.liveSyncPosition;
					null !== t && (a = this.getFragmentAtPosition(t, this.bitrateTest ? e.fragmentEnd : e.edge, e))
				}
				return a
			}

			getFragmentAtPosition(e, t, i) {
				let a, {config: r} = this, {fragPrevious: n} = this, {fragments: s, endSN: o} = i, {fragmentHint: l} = i,
					d = r.maxFragLookUpTolerance, u = i.partList, h = !!(r.lowLatencyMode && null != u && u.length && l);
				if (h && l && !this.bitrateTest && (s = s.concat(l), o = l.sn), e < t) {
					a = fv(n, s, e, e > t - d ? 0 : d)
				} else a = s[s.length - 1];
				if (a) {
					let e = a.sn - i.startSN, t = this.fragmentTracker.getState(a);
					if ((t === $v || t === Bv && a.gap) && (n = a), n && a.sn === n.sn && (!h || u[0].fragment.sn > a.sn) && n && a.level === n.level) {
						let t = s[e + 1];
						a = a.sn < o && this.fragmentTracker.getState(t) !== $v ? t : null
					}
				}
				return a
			}

			synchronizeToLiveEdge(e) {
				let {config: t, media: i} = this;
				if (!i) return;
				let a = this.hls.liveSyncPosition, r = i.currentTime, n = e.fragments[0].start, s = e.edge,
					o = r >= n - t.maxFragLookUpTolerance && r <= s;
				if (null !== a && i.duration > a && (r < a || !o)) {
					let n = void 0 !== t.liveMaxLatencyDuration ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration;
					(!o && i.readyState < 4 || r < s - n) && (this.loadedmetadata || (this.nextLoadPosition = a), i.readyState && (this.warn(`Playback: ${r.toFixed(3)} is located too far from the end of live sliding playlist: ${s}, reset currentTime to : ${a.toFixed(3)}`), i.currentTime = a))
				}
			}

			alignPlaylists(e, t, i) {
				let a = e.fragments.length;
				if (!a) return this.warn("No fragments in live playlist"), 0;
				let r = e.fragments[0].start, n = !t, s = e.alignedSliding && Ef(r);
				if (n || !s && !r) {
					let {fragPrevious: r} = this;
					zv(r, i, e);
					let n = e.fragments[0].start;
					return this.log(`Live playlist sliding: ${n.toFixed(2)} start-sn: ${t ? t.startSN : "na"}->${e.startSN} prev-sn: ${r ? r.sn : "na"} fragments: ${a}`), n
				}
				return r
			}

			waitForCdnTuneIn(e) {
				return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, 3 * e.partTarget)
			}

			setStartPosition(e, t) {
				let i = this.startPosition;
				if (i < t && (i = -1), -1 === i || -1 === this.lastCurrentTime) {
					let a = null !== this.startTimeOffset, r = a ? this.startTimeOffset : e.startTimeOffset;
					null !== r && Ef(r) ? (i = t + r, r < 0 && (i += e.totalduration), i = Math.min(Math.max(t, i), t + e.totalduration), this.log(`Start time offset ${r} found in ${a ? "multivariant" : "media"} playlist, adjust startPosition to ${i}`), this.startPosition = i) : e.live ? i = this.hls.liveSyncPosition || t : this.startPosition = i = 0, this.lastCurrentTime = i
				}
				this.nextLoadPosition = i
			}

			getLoadPosition() {
				let {media: e} = this, t = 0;
				return this.loadedmetadata && e ? t = e.currentTime : this.nextLoadPosition && (t = this.nextLoadPosition), t
			}

			handleFragLoadAborted(e, t) {
				this.transmuxer && "initSegment" !== e.sn && e.stats.aborted && (this.warn(`Fragment ${e.sn}${t ? " part " + t.index : ""} of level ${e.level} was aborted`), this.resetFragmentLoading(e))
			}

			resetFragmentLoading(e) {
				(!this.fragCurrent || !this.fragContextChanged(e) && this.state !== oE) && (this.state = rE)
			}

			onFragmentOrKeyLoadError(e, t) {
				if (t.chunkMeta && !t.frag) {
					let e = this.getCurrentContext(t.chunkMeta);
					e && (t.frag = e.frag)
				}
				let i = t.frag;
				if (!i || i.type !== e || !this.levels) return;
				var a;
				if (this.fragContextChanged(i)) return void this.warn(`Frag load error must match current frag to retry ${i.url} > ${null == (a = this.fragCurrent) ? void 0 : a.url}`);
				let r = t.details === _f.FRAG_GAP;
				r && this.fragmentTracker.fragBuffered(i, !0);
				let n = t.errorAction, {action: s, retryCount: o = 0, retryConfig: l} = n || {};
				if (n && s === yv && l) {
					this.resetStartWhenNotLoaded(this.levelLastLoaded);
					let a = uv(l, o);
					this.warn(`Fragment ${i.sn} of ${e} ${i.level} errored with ${t.details}, retrying loading ${o + 1}/${l.maxNumRetry} in ${a}ms`), n.resolved = !0, this.retryDate = self.performance.now() + a, this.state = oE
				} else if (l && n) {
					if (this.resetFragmentErrors(e), !(o < l.maxNumRetry)) return void Rf.warn(`${t.details} reached or exceeded max retry (${o})`);
					!r && s !== bv && (n.resolved = !0)
				} else (null == n ? void 0 : n.action) === Ev ? this.state = fE : this.state = cE;
				this.tickImmediate()
			}

			reduceLengthAndFlushBuffer(e) {
				if (this.state === dE || this.state === uE) {
					let t = e.parent, i = this.getFwdBufferInfo(this.mediaBuffer, t), a = i && i.len > .5;
					a && this.reduceMaxBufferLength(i.len);
					let r = !a;
					return r && this.warn(`Buffer full error while media.currentTime is not buffered, flush ${t} buffer`), e.frag && (this.fragmentTracker.removeFragment(e.frag), this.nextLoadPosition = e.frag.start), this.resetLoadingState(), r
				}
				return !1
			}

			resetFragmentErrors(e) {
				e === Lg && (this.fragCurrent = null), this.loadedmetadata || (this.startFragRequested = !1), this.state !== aE && (this.state = rE)
			}

			afterBufferFlushed(e, t, i) {
				if (!e) return;
				let a = Vv.getBuffered(e);
				this.fragmentTracker.detectEvictedFragments(t, a, i), this.state === hE && this.resetLoadingState()
			}

			resetLoadingState() {
				this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state = rE
			}

			resetStartWhenNotLoaded(e) {
				if (!this.loadedmetadata) {
					this.startFragRequested = !1;
					let t = e ? e.details : null;
					null != t && t.live ? (this.startPosition = -1, this.setStartPosition(t, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition
				}
			}

			resetWhenMissingContext(e) {
				this.warn(`The loading context changed while buffering fragment ${e.sn} of level ${e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState()
			}

			removeUnbufferedFrags(e = 0) {
				this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0)
			}

			updateLevelTiming(e, t, i, a) {
				var r;
				let n = i.details;
				if (n) {
					if (!Object.keys(e.elementaryStreams).reduce(((t, r) => {
						let s = e.elementaryStreams[r];
						if (s) {
							let o = s.endPTS - s.startPTS;
							if (o <= 0) return this.warn(`Could not parse fragment ${e.sn} ${r} duration reliably (${o})`), t || !1;
							let l = a ? 0 : tv(n, e, s.startPTS, s.endPTS, s.startDTS, s.endDTS);
							return this.hls.trigger(Tf.LEVEL_PTS_UPDATED, {
								details: n,
								level: i,
								drift: l,
								type: r,
								frag: e,
								start: s.startPTS,
								end: s.endPTS
							}), !0
						}
						return t
					}), !1) && null === (null == (r = this.transmuxer) ? void 0 : r.error)) {
						let t = new Error(`Found no media in fragment ${e.sn} of level ${e.level} resetting transmuxer to fallback to playlist timing`);
						if (0 === i.fragmentError && (i.fragmentError++, e.gap = !0, this.fragmentTracker.removeFragment(e), this.fragmentTracker.fragBuffered(e, !0)), this.warn(t.message), this.hls.trigger(Tf.ERROR, {
							type: Af.MEDIA_ERROR,
							details: _f.FRAG_PARSING_ERROR,
							fatal: !1,
							error: t,
							frag: e,
							reason: `Found no media in msn ${e.sn} of level "${i.url}"`
						}), !this.hls) return;
						this.resetTransmuxer()
					}
					this.state = uE, this.hls.trigger(Tf.FRAG_PARSED, {frag: e, part: t})
				} else this.warn("level.details undefined")
			}

			resetTransmuxer() {
				this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null)
			}

			recoverWorkerError(e) {
				"demuxerWorker" === e.event && (this.fragmentTracker.removeAllFragments(), this.resetTransmuxer(), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState())
			}
		}, gE = class {
			constructor() {
				this.chunks = [], this.dataLength = 0
			}

			push(e) {
				this.chunks.push(e), this.dataLength += e.length
			}

			flush() {
				let e, {chunks: t, dataLength: i} = this;
				return t.length ? (e = 1 === t.length ? t[0] : function (e, t) {
					let i = new Uint8Array(t), a = 0;
					for (let t = 0; t < e.length; t++) {
						let r = e[t];
						i.set(r, a), a += r.length
					}
					return i
				}(t, i), this.reset(), e) : new Uint8Array(0)
			}

			reset() {
				this.chunks.length = 0, this.dataLength = 0
			}
		};

	function vE(e = "", t = 9e4) {
		return {type: e, id: -1, pid: -1, inputTimeScale: t, sequenceNumber: -1, samples: [], dropped: 0}
	}

	var EE = class {
		constructor() {
			this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null
		}

		resetInitSegment(e, t, i, a) {
			this._id3Track = {
				type: "id3",
				id: 3,
				pid: -1,
				inputTimeScale: 9e4,
				sequenceNumber: 0,
				samples: [],
				dropped: 0
			}
		}

		resetTimeStamp(e) {
			this.initPTS = e, this.resetContiguity()
		}

		resetContiguity() {
			this.basePTS = null, this.lastPTS = null, this.frameIndex = 0
		}

		canParse(e, t) {
			return !1
		}

		appendFrame(e, t, i) {
		}

		demux(e, t) {
			this.cachedData && (e = Fp(this.cachedData, e), this.cachedData = null);
			let i, a = sp(e, 0), r = a ? a.length : 0, n = this._audioTrack, s = this._id3Track, o = a ? dp(a) : void 0,
				l = e.length;
			for ((null === this.basePTS || 0 === this.frameIndex && Ef(o)) && (this.basePTS = bE(o, t, this.initPTS), this.lastPTS = this.basePTS), null === this.lastPTS && (this.lastPTS = this.basePTS), a && a.length > 0 && s.samples.push({
				pts: this.lastPTS,
				dts: this.lastPTS,
				data: a,
				type: Ng,
				duration: Number.POSITIVE_INFINITY
			}); r < l;) {
				if (this.canParse(e, r)) {
					let t = this.appendFrame(n, e, r);
					t ? (this.frameIndex++, this.lastPTS = t.sample.pts, r += t.length, i = r) : r = l
				} else lp(e, r) ? (a = sp(e, r), s.samples.push({
					pts: this.lastPTS,
					dts: this.lastPTS,
					data: a,
					type: Ng,
					duration: Number.POSITIVE_INFINITY
				}), r += a.length, i = r) : r++;
				if (r === l && i !== l) {
					let t = ip(e, i);
					this.cachedData ? this.cachedData = Fp(this.cachedData, t) : this.cachedData = t
				}
			}
			return {audioTrack: n, videoTrack: vE(), id3Track: s, textTrack: vE()}
		}

		demuxSampleAes(e, t, i) {
			return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`))
		}

		flush(e) {
			let t = this.cachedData;
			return t && (this.cachedData = null, this.demux(t, 0)), {
				audioTrack: this._audioTrack,
				videoTrack: vE(),
				id3Track: this._id3Track,
				textTrack: vE()
			}
		}

		destroy() {
		}
	}, bE = (e, t, i) => {
		if (Ef(e)) return 90 * e;
		return 9e4 * t + (i ? 9e4 * i.baseTime / i.timescale : 0)
	};

	function yE(e, t) {
		return 255 === e[t] && 240 == (246 & e[t + 1])
	}

	function TE(e, t) {
		return 1 & e[t + 1] ? 7 : 9
	}

	function AE(e, t) {
		return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5
	}

	function _E(e, t) {
		return t + 1 < e.length && yE(e, t)
	}

	function kE(e, t) {
		if (_E(e, t)) {
			let i = TE(e, t);
			if (t + i >= e.length) return !1;
			let a = AE(e, t);
			if (a <= i) return !1;
			let r = t + a;
			return r === e.length || _E(e, r)
		}
		return !1
	}

	function SE(e, t, i, a, r) {
		if (!e.samplerate) {
			let n = function (e, t, i, a) {
				let r, n, s, o, l = navigator.userAgent.toLowerCase(), d = a,
					u = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
				r = 1 + ((192 & t[i + 2]) >>> 6);
				let h = (60 & t[i + 2]) >>> 2;
				if (!(h > u.length - 1)) return s = (1 & t[i + 2]) << 2, s |= (192 & t[i + 3]) >>> 6, Rf.log(`manifest codec:${a}, ADTS type:${r}, samplingIndex:${h}`), /firefox/i.test(l) ? h >= 6 ? (r = 5, o = new Array(4), n = h - 3) : (r = 2, o = new Array(2), n = h) : -1 !== l.indexOf("android") ? (r = 2, o = new Array(2), n = h) : (r = 5, o = new Array(4), a && (-1 !== a.indexOf("mp4a.40.29") || -1 !== a.indexOf("mp4a.40.5")) || !a && h >= 6 ? n = h - 3 : ((a && -1 !== a.indexOf("mp4a.40.2") && (h >= 6 && 1 === s || /vivaldi/i.test(l)) || !a && 1 === s) && (r = 2, o = new Array(2)), n = h)), o[0] = r << 3, o[0] |= (14 & h) >> 1, o[1] |= (1 & h) << 7, o[1] |= s << 3, 5 === r && (o[1] |= (14 & n) >> 1, o[2] = (1 & n) << 7, o[2] |= 8, o[3] = 0), {
					config: o,
					samplerate: u[h],
					channelCount: s,
					codec: "mp4a.40." + r,
					manifestCodec: d
				};
				{
					let t = new Error(`invalid ADTS sampling index:${h}`);
					e.emit(Tf.ERROR, Tf.ERROR, {
						type: Af.MEDIA_ERROR,
						details: _f.FRAG_PARSING_ERROR,
						fatal: !0,
						error: t,
						reason: t.message
					})
				}
			}(t, i, a, r);
			if (!n) return;
			e.config = n.config, e.samplerate = n.samplerate, e.channelCount = n.channelCount, e.codec = n.codec, e.manifestCodec = n.manifestCodec, Rf.log(`parsed codec:${e.codec}, rate:${n.samplerate}, channels:${n.channelCount}`)
		}
	}

	function wE(e) {
		return 9216e4 / e
	}

	function LE(e, t, i, a, r) {
		let n, s = a + r * wE(e.samplerate), o = function (e, t) {
			let i = TE(e, t);
			if (t + i <= e.length) {
				let a = AE(e, t) - i;
				if (a > 0) return {headerLength: i, frameLength: a}
			}
		}(t, i);
		if (o) {
			let {frameLength: a, headerLength: r} = o, l = r + a, d = Math.max(0, i + l - t.length);
			d ? (n = new Uint8Array(l - r), n.set(t.subarray(i + r, t.length), 0)) : n = t.subarray(i + r, i + l);
			let u = {unit: n, pts: s};
			return d || e.samples.push(u), {sample: u, length: l, missing: d}
		}
		let l = t.length - i;
		return n = new Uint8Array(l), n.set(t.subarray(i, t.length), 0), {
			sample: {unit: n, pts: s},
			length: l,
			missing: -1
		}
	}

	var RE = null,
		IE = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
		DE = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
		CE = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]], xE = [0, 1, 1, 4];

	function ME(e, t, i, a, r) {
		if (i + 24 > t.length) return;
		let n = OE(t, i);
		if (n && i + n.frameLength <= t.length) {
			let s = a + r * (9e4 * n.samplesPerFrame / n.sampleRate),
				o = {unit: t.subarray(i, i + n.frameLength), pts: s, dts: s};
			return e.config = [], e.channelCount = n.channelCount, e.samplerate = n.sampleRate, e.samples.push(o), {
				sample: o,
				length: n.frameLength,
				missing: 0
			}
		}
	}

	function OE(e, t) {
		let i = e[t + 1] >> 3 & 3, a = e[t + 1] >> 1 & 3, r = e[t + 2] >> 4 & 15, n = e[t + 2] >> 2 & 3;
		if (1 !== i && 0 !== r && 15 !== r && 3 !== n) {
			let s = e[t + 2] >> 1 & 1, o = e[t + 3] >> 6,
				l = 1e3 * IE[14 * (3 === i ? 3 - a : 3 === a ? 3 : 4) + r - 1],
				d = DE[3 * (3 === i ? 0 : 2 === i ? 1 : 2) + n], u = 3 === o ? 1 : 2, h = CE[i][a], c = xE[a],
				m = 8 * h * c, f = Math.floor(h * l / d + s) * c;
			if (null === RE) {
				let e = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
				RE = e ? parseInt(e[1]) : 0
			}
			return !!RE && RE <= 87 && 2 === a && l >= 224e3 && 0 === o && (e[t + 3] = 128 | e[t + 3]), {
				sampleRate: d,
				channelCount: u,
				frameLength: f,
				samplesPerFrame: m
			}
		}
	}

	function PE(e, t) {
		return 255 === e[t] && 224 == (224 & e[t + 1]) && 0 != (6 & e[t + 1])
	}

	function NE(e, t) {
		return t + 1 < e.length && PE(e, t)
	}

	function UE(e, t) {
		if (t + 1 < e.length && PE(e, t)) {
			let i = OE(e, t), a = 4;
			null != i && i.frameLength && (a = i.frameLength);
			let r = t + a;
			return r === e.length || NE(e, r)
		}
		return !1
	}

	var FE = /\/emsg[-/]ID3/i, BE = (e, t) => {
		let i = 0, a = 5;
		t += a;
		let r = new Uint32Array(1), n = new Uint32Array(1), s = new Uint8Array(1);
		for (; a > 0;) {
			s[0] = e[t];
			let o = Math.min(a, 8), l = 8 - o;
			n[0] = 4278190080 >>> 24 + l << l, r[0] = (s[0] & n[0]) >> l, i = i ? i << o | r[0] : r[0], t += 1, a -= o
		}
		return i
	};

	function $E(e, t, i, a, r) {
		if (i + 8 > t.length || 11 !== t[i] || 119 !== t[i + 1]) return -1;
		let n = t[i + 4] >> 6;
		if (n >= 3) return -1;
		let s = [48e3, 44100, 32e3][n], o = 63 & t[i + 4],
			l = 2 * [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920][3 * o + n];
		if (i + l > t.length) return -1;
		let d = t[i + 6] >> 5, u = 0;
		2 === d ? u += 2 : (1 & d && 1 !== d && (u += 2), 4 & d && (u += 2));
		let h = (t[i + 6] << 8 | t[i + 7]) >> 12 - u & 1, c = [2, 1, 2, 3, 3, 4, 4, 5][d] + h, m = t[i + 5] >> 3,
			f = 7 & t[i + 5],
			p = new Uint8Array([n << 6 | m << 1 | f >> 2, (3 & f) << 6 | d << 3 | h << 2 | o >> 4, o << 4 & 224]),
			g = a + r * (1536 / s * 9e4), v = t.subarray(i, i + l);
		return e.config = p, e.channelCount = c, e.samplerate = s, e.samples.push({unit: v, pts: g}), l
	}

	var HE = class {
		constructor() {
			this.VideoSample = null
		}

		createVideoSample(e, t, i, a) {
			return {key: e, frame: !1, pts: t, dts: i, units: [], debug: a, length: 0}
		}

		getLastNalUnit(e) {
			var t;
			let i, a = this.VideoSample;
			if ((!a || 0 === a.units.length) && (a = e[e.length - 1]), null != (t = a) && t.units) {
				let e = a.units;
				i = e[e.length - 1]
			}
			return i
		}

		pushAccessUnit(e, t) {
			if (e.units.length && e.frame) {
				if (void 0 === e.pts) {
					let i = t.samples, a = i.length;
					if (!a) return void t.dropped++;
					{
						let t = i[a - 1];
						e.pts = t.pts, e.dts = t.dts
					}
				}
				t.samples.push(e)
			}
			e.debug.length && Rf.log(e.pts + "/" + e.dts + ":" + e.debug)
		}
	}, WE = class {
		constructor(e) {
			this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0
		}

		loadWord() {
			let e = this.data, t = this.bytesAvailable, i = e.byteLength - t, a = new Uint8Array(4), r = Math.min(4, t);
			if (0 === r) throw new Error("no bytes available");
			a.set(e.subarray(i, i + r)), this.word = new DataView(a.buffer).getUint32(0), this.bitsAvailable = 8 * r, this.bytesAvailable -= r
		}

		skipBits(e) {
			let t;
			e = Math.min(e, 8 * this.bytesAvailable + this.bitsAvailable), this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (t = (e -= this.bitsAvailable) >> 3, e -= t << 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e)
		}

		readBits(e) {
			let t = Math.min(this.bitsAvailable, e), i = this.word >>> 32 - t;
			if (e > 32 && Rf.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, this.bitsAvailable > 0) this.word <<= t; else {
				if (!(this.bytesAvailable > 0)) throw new Error("no bits available");
				this.loadWord()
			}
			return t = e - t, t > 0 && this.bitsAvailable ? i << t | this.readBits(t) : i
		}

		skipLZ() {
			let e;
			for (e = 0; e < this.bitsAvailable; ++e) if (this.word & 2147483648 >>> e) return this.word <<= e, this.bitsAvailable -= e, e;
			return this.loadWord(), e + this.skipLZ()
		}

		skipUEG() {
			this.skipBits(1 + this.skipLZ())
		}

		skipEG() {
			this.skipBits(1 + this.skipLZ())
		}

		readUEG() {
			let e = this.skipLZ();
			return this.readBits(e + 1) - 1
		}

		readEG() {
			let e = this.readUEG();
			return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
		}

		readBoolean() {
			return 1 === this.readBits(1)
		}

		readUByte() {
			return this.readBits(8)
		}

		readUShort() {
			return this.readBits(16)
		}

		readUInt() {
			return this.readBits(32)
		}

		skipScalingList(e) {
			let t, i = 8, a = 8;
			for (let r = 0; r < e; r++) 0 !== a && (t = this.readEG(), a = (i + t + 256) % 256), i = 0 === a ? i : a
		}

		readSPS() {
			let e, t, i, a = 0, r = 0, n = 0, s = 0, o = this.readUByte.bind(this), l = this.readBits.bind(this),
				d = this.readUEG.bind(this), u = this.readBoolean.bind(this), h = this.skipBits.bind(this),
				c = this.skipEG.bind(this), m = this.skipUEG.bind(this), f = this.skipScalingList.bind(this);
			o();
			let p = o();
			if (l(5), h(3), o(), m(), 100 === p || 110 === p || 122 === p || 244 === p || 44 === p || 83 === p || 86 === p || 118 === p || 128 === p) {
				let e = d();
				if (3 === e && h(1), m(), m(), h(1), u()) for (t = 3 !== e ? 8 : 12, i = 0; i < t; i++) u() && f(i < 6 ? 16 : 64)
			}
			m();
			let g = d();
			if (0 === g) d(); else if (1 === g) for (h(1), c(), c(), e = d(), i = 0; i < e; i++) c();
			m(), h(1);
			let v = d(), E = d(), b = l(1);
			0 === b && h(1), h(1), u() && (a = d(), r = d(), n = d(), s = d());
			let y = [1, 1];
			if (u() && u()) switch (o()) {
				case 1:
					y = [1, 1];
					break;
				case 2:
					y = [12, 11];
					break;
				case 3:
					y = [10, 11];
					break;
				case 4:
					y = [16, 11];
					break;
				case 5:
					y = [40, 33];
					break;
				case 6:
					y = [24, 11];
					break;
				case 7:
					y = [20, 11];
					break;
				case 8:
					y = [32, 11];
					break;
				case 9:
					y = [80, 33];
					break;
				case 10:
					y = [18, 11];
					break;
				case 11:
					y = [15, 11];
					break;
				case 12:
					y = [64, 33];
					break;
				case 13:
					y = [160, 99];
					break;
				case 14:
					y = [4, 3];
					break;
				case 15:
					y = [3, 2];
					break;
				case 16:
					y = [2, 1];
					break;
				case 255:
					y = [o() << 8 | o(), o() << 8 | o()]
			}
			return {
				width: Math.ceil(16 * (v + 1) - 2 * a - 2 * r),
				height: (2 - b) * (E + 1) * 16 - (b ? 2 : 4) * (n + s),
				pixelRatio: y
			}
		}

		readSliceType() {
			return this.readUByte(), this.readUEG(), this.readUEG()
		}
	}, GE = class extends HE {
		parseAVCPES(e, t, i, a, r) {
			let n, s = this.parseAVCNALu(e, i.data), o = this.VideoSample, l = !1;
			i.data = null, o && s.length && !e.audFound && (this.pushAccessUnit(o, e), o = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts, "")), s.forEach((a => {
				var s;
				switch (a.type) {
					case 1: {
						let t = !1;
						n = !0;
						let r = a.data;
						if (l && r.length > 4) {
							let e = new WE(r).readSliceType();
							(2 === e || 4 === e || 7 === e || 9 === e) && (t = !0)
						}
						var d;
						if (t) null != (d = o) && d.frame && !o.key && (this.pushAccessUnit(o, e), o = this.VideoSample = null);
						o || (o = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts, "")), o.frame = !0, o.key = t;
						break
					}
					case 5:
						n = !0, null != (s = o) && s.frame && !o.key && (this.pushAccessUnit(o, e), o = this.VideoSample = null), o || (o = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts, "")), o.key = !0, o.frame = !0;
						break;
					case 6:
						n = !0, Hp(a.data, 1, i.pts, t.samples);
						break;
					case 7: {
						var u, h;
						n = !0, l = !0;
						let t = a.data, i = new WE(t).readSPS();
						if (!e.sps || e.width !== i.width || e.height !== i.height || (null == (u = e.pixelRatio) ? void 0 : u[0]) !== i.pixelRatio[0] || (null == (h = e.pixelRatio) ? void 0 : h[1]) !== i.pixelRatio[1]) {
							e.width = i.width, e.height = i.height, e.pixelRatio = i.pixelRatio, e.sps = [t], e.duration = r;
							let a = t.subarray(1, 4), n = "avc1.";
							for (let e = 0; e < 3; e++) {
								let t = a[e].toString(16);
								t.length < 2 && (t = "0" + t), n += t
							}
							e.codec = n
						}
						break
					}
					case 8:
						n = !0, e.pps = [a.data];
						break;
					case 9:
						n = !0, e.audFound = !0, o && this.pushAccessUnit(o, e), o = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts, "");
						break;
					case 12:
						n = !0;
						break;
					default:
						n = !1, o && (o.debug += "unknown NAL " + a.type + " ")
				}
				o && n && o.units.push(a)
			})), a && o && (this.pushAccessUnit(o, e), this.VideoSample = null)
		}

		parseAVCNALu(e, t) {
			let i, a, r, n = t.byteLength, s = e.naluState || 0, o = s, l = [], d = 0, u = -1, h = 0;
			for (-1 === s && (u = 0, h = 31 & t[0], s = 0, d = 1); d < n;) if (i = t[d++], s) if (1 !== s) if (i) if (1 === i) {
				if (a = d - s - 1, u >= 0) {
					let e = {data: t.subarray(u, a), type: h};
					l.push(e)
				} else {
					let i = this.getLastNalUnit(e.samples);
					i && (o && d <= 4 - o && i.state && (i.data = i.data.subarray(0, i.data.byteLength - o)), a > 0 && (i.data = Fp(i.data, t.subarray(0, a)), i.state = 0))
				}
				d < n ? (r = 31 & t[d], u = d, h = r, s = 0) : s = -1
			} else s = 0; else s = 3; else s = i ? 0 : 2; else s = i ? 0 : 1;
			if (u >= 0 && s >= 0) {
				let e = {data: t.subarray(u, n), type: h, state: s};
				l.push(e)
			}
			if (0 === l.length) {
				let i = this.getLastNalUnit(e.samples);
				i && (i.data = Fp(i.data, t))
			}
			return e.naluState = s, l
		}
	}, VE = 188;

	function KE(e, t) {
		return ((31 & e[t + 1]) << 8) + e[t + 2]
	}

	function qE(e, t) {
		return (31 & e[t + 10]) << 8 | e[t + 11]
	}

	function YE(e, t, i, a) {
		let r = {audioPid: -1, videoPid: -1, id3Pid: -1, segmentVideoCodec: "avc", segmentAudioCodec: "aac"},
			n = t + 3 + ((15 & e[t + 1]) << 8 | e[t + 2]) - 4;
		for (t += 12 + ((15 & e[t + 10]) << 8 | e[t + 11]); t < n;) {
			let n = KE(e, t), s = (15 & e[t + 3]) << 8 | e[t + 4];
			switch (e[t]) {
				case 207:
					if (!a) {
						jE("ADTS AAC");
						break
					}
				case 15:
					-1 === r.audioPid && (r.audioPid = n);
					break;
				case 21:
					-1 === r.id3Pid && (r.id3Pid = n);
					break;
				case 219:
					if (!a) {
						jE("H.264");
						break
					}
				case 27:
					-1 === r.videoPid && (r.videoPid = n, r.segmentVideoCodec = "avc");
					break;
				case 3:
				case 4:
					i.mpeg || i.mp3 ? -1 === r.audioPid && (r.audioPid = n, r.segmentAudioCodec = "mp3") : Rf.log("MPEG audio found, not supported in this browser");
					break;
				case 193:
					if (!a) {
						jE("AC-3");
						break
					}
				case 129:
					i.ac3 ? -1 === r.audioPid && (r.audioPid = n, r.segmentAudioCodec = "ac3") : Rf.log("AC-3 audio found, not supported in this browser");
					break;
				case 6:
					if (-1 === r.audioPid && s > 0) {
						let a = t + 5, o = s;
						for (; o > 2;) {
							if (106 === e[a]) !0 !== i.ac3 ? Rf.log("AC-3 audio found, not supported in this browser for now") : (r.audioPid = n, r.segmentAudioCodec = "ac3");
							let t = e[a + 1] + 2;
							a += t, o -= t
						}
					}
					break;
				case 194:
				case 135:
					Rf.warn("Unsupported EC-3 in M2TS found");
					break;
				case 36:
					Rf.warn("Unsupported HEVC in M2TS found")
			}
			t += s + 5
		}
		return r
	}

	function jE(e) {
		Rf.log(`${e} with AES-128-CBC encryption found in unencrypted stream`)
	}

	function zE(e) {
		let t, i, a, r, n, s = 0, o = e.data;
		if (!e || 0 === e.size) return null;
		for (; o[0].length < 19 && o.length > 1;) o[0] = Fp(o[0], o[1]), o.splice(1, 1);
		if (t = o[0], (t[0] << 16) + (t[1] << 8) + t[2] === 1) {
			if (i = (t[4] << 8) + t[5], i && i > e.size - 6) return null;
			let l = t[7];
			192 & l && (r = 536870912 * (14 & t[9]) + 4194304 * (255 & t[10]) + 16384 * (254 & t[11]) + 128 * (255 & t[12]) + (254 & t[13]) / 2, 64 & l ? (n = 536870912 * (14 & t[14]) + 4194304 * (255 & t[15]) + 16384 * (254 & t[16]) + 128 * (255 & t[17]) + (254 & t[18]) / 2, r - n > 54e5 && (Rf.warn(`${Math.round((r - n) / 9e4)}s delta between PTS and DTS, align them`), r = n)) : n = r), a = t[8];
			let d = a + 9;
			if (e.size <= d) return null;
			e.size -= d;
			let u = new Uint8Array(e.size);
			for (let e = 0, i = o.length; e < i; e++) {
				t = o[e];
				let i = t.byteLength;
				if (d) {
					if (d > i) {
						d -= i;
						continue
					}
					t = t.subarray(d), i -= d, d = 0
				}
				u.set(t, s), s += i
			}
			return i && (i -= a + 3), {data: u, pts: r, dts: n, len: i}
		}
		return null
	}

	var XE = class {
		static getSilentFrame(e, t) {
			if ("mp4a.40.2" === e) {
				if (1 === t) return new Uint8Array([0, 200, 0, 128, 35, 128]);
				if (2 === t) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
				if (3 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
				if (4 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
				if (5 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
				if (6 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224])
			} else {
				if (1 === t) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
				if (2 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
				if (3 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94])
			}
		}
	}, QE = Math.pow(2, 32) - 1, ZE = class e {
		static init() {
			let t;
			for (t in e.types = {
				avc1: [],
				avcC: [],
				btrt: [],
				dinf: [],
				dref: [],
				esds: [],
				ftyp: [],
				hdlr: [],
				mdat: [],
				mdhd: [],
				mdia: [],
				mfhd: [],
				minf: [],
				moof: [],
				moov: [],
				mp4a: [],
				".mp3": [],
				dac3: [],
				"ac-3": [],
				mvex: [],
				mvhd: [],
				pasp: [],
				sdtp: [],
				stbl: [],
				stco: [],
				stsc: [],
				stsd: [],
				stsz: [],
				stts: [],
				tfdt: [],
				tfhd: [],
				traf: [],
				trak: [],
				trun: [],
				trex: [],
				tkhd: [],
				vmhd: [],
				smhd: []
			}, e.types) e.types.hasOwnProperty(t) && (e.types[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);
			let i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
				a = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
			e.HDLR_TYPES = {video: i, audio: a};
			let r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
				n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
			e.STTS = e.STSC = e.STCO = n, e.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), e.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), e.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
			let s = new Uint8Array([105, 115, 111, 109]), o = new Uint8Array([97, 118, 99, 49]),
				l = new Uint8Array([0, 0, 0, 1]);
			e.FTYP = e.box(e.types.ftyp, s, l, s, o), e.DINF = e.box(e.types.dinf, e.box(e.types.dref, r))
		}

		static box(e, ...t) {
			let i = 8, a = t.length, r = a;
			for (; a--;) i += t[a].byteLength;
			let n = new Uint8Array(i);
			for (n[0] = i >> 24 & 255, n[1] = i >> 16 & 255, n[2] = i >> 8 & 255, n[3] = 255 & i, n.set(e, 4), a = 0, i = 8; a < r; a++) n.set(t[a], i), i += t[a].byteLength;
			return n
		}

		static hdlr(t) {
			return e.box(e.types.hdlr, e.HDLR_TYPES[t])
		}

		static mdat(t) {
			return e.box(e.types.mdat, t)
		}

		static mdhd(t, i) {
			i *= t;
			let a = Math.floor(i / (QE + 1)), r = Math.floor(i % (QE + 1));
			return e.box(e.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 85, 196, 0, 0]))
		}

		static mdia(t) {
			return e.box(e.types.mdia, e.mdhd(t.timescale, t.duration), e.hdlr(t.type), e.minf(t))
		}

		static mfhd(t) {
			return e.box(e.types.mfhd, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t]))
		}

		static minf(t) {
			return "audio" === t.type ? e.box(e.types.minf, e.box(e.types.smhd, e.SMHD), e.DINF, e.stbl(t)) : e.box(e.types.minf, e.box(e.types.vmhd, e.VMHD), e.DINF, e.stbl(t))
		}

		static moof(t, i, a) {
			return e.box(e.types.moof, e.mfhd(t), e.traf(a, i))
		}

		static moov(t) {
			let i = t.length, a = [];
			for (; i--;) a[i] = e.trak(t[i]);
			return e.box.apply(null, [e.types.moov, e.mvhd(t[0].timescale, t[0].duration)].concat(a).concat(e.mvex(t)))
		}

		static mvex(t) {
			let i = t.length, a = [];
			for (; i--;) a[i] = e.trex(t[i]);
			return e.box.apply(null, [e.types.mvex, ...a])
		}

		static mvhd(t, i) {
			i *= t;
			let a = Math.floor(i / (QE + 1)), r = Math.floor(i % (QE + 1)),
				n = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
			return e.box(e.types.mvhd, n)
		}

		static sdtp(t) {
			let i, a, r = t.samples || [], n = new Uint8Array(4 + r.length);
			for (i = 0; i < r.length; i++) a = r[i].flags, n[i + 4] = a.dependsOn << 4 | a.isDependedOn << 2 | a.hasRedundancy;
			return e.box(e.types.sdtp, n)
		}

		static stbl(t) {
			return e.box(e.types.stbl, e.stsd(t), e.box(e.types.stts, e.STTS), e.box(e.types.stsc, e.STSC), e.box(e.types.stsz, e.STSZ), e.box(e.types.stco, e.STCO))
		}

		static avc1(t) {
			let i, a, r, n = [], s = [];
			for (i = 0; i < t.sps.length; i++) a = t.sps[i], r = a.byteLength, n.push(r >>> 8 & 255), n.push(255 & r), n = n.concat(Array.prototype.slice.call(a));
			for (i = 0; i < t.pps.length; i++) a = t.pps[i], r = a.byteLength, s.push(r >>> 8 & 255), s.push(255 & r), s = s.concat(Array.prototype.slice.call(a));
			let o = e.box(e.types.avcC, new Uint8Array([1, n[3], n[4], n[5], 255, 224 | t.sps.length].concat(n).concat([t.pps.length]).concat(s))),
				l = t.width, d = t.height, u = t.pixelRatio[0], h = t.pixelRatio[1];
			return e.box(e.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, d >> 8 & 255, 255 & d, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, e.box(e.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), e.box(e.types.pasp, new Uint8Array([u >> 24, u >> 16 & 255, u >> 8 & 255, 255 & u, h >> 24, h >> 16 & 255, h >> 8 & 255, 255 & h])))
		}

		static esds(e) {
			let t = e.config.length;
			return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2]))
		}

		static audioStsd(e) {
			let t = e.samplerate;
			return new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0])
		}

		static mp4a(t) {
			return e.box(e.types.mp4a, e.audioStsd(t), e.box(e.types.esds, e.esds(t)))
		}

		static mp3(t) {
			return e.box(e.types[".mp3"], e.audioStsd(t))
		}

		static ac3(t) {
			return e.box(e.types["ac-3"], e.audioStsd(t), e.box(e.types.dac3, t.config))
		}

		static stsd(t) {
			return "audio" === t.type ? "mp3" === t.segmentCodec && "mp3" === t.codec ? e.box(e.types.stsd, e.STSD, e.mp3(t)) : "ac3" === t.segmentCodec ? e.box(e.types.stsd, e.STSD, e.ac3(t)) : e.box(e.types.stsd, e.STSD, e.mp4a(t)) : e.box(e.types.stsd, e.STSD, e.avc1(t))
		}

		static tkhd(t) {
			let i = t.id, a = t.duration * t.timescale, r = t.width, n = t.height, s = Math.floor(a / (QE + 1)),
				o = Math.floor(a % (QE + 1));
			return e.box(e.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, 255 & i, 0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, o >> 24, o >> 16 & 255, o >> 8 & 255, 255 & o, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0, n >> 8 & 255, 255 & n, 0, 0]))
		}

		static traf(t, i) {
			let a = e.sdtp(t), r = t.id, n = Math.floor(i / (QE + 1)), s = Math.floor(i % (QE + 1));
			return e.box(e.types.traf, e.box(e.types.tfhd, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r])), e.box(e.types.tfdt, new Uint8Array([1, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s])), e.trun(t, a.length + 16 + 20 + 8 + 16 + 8 + 8), a)
		}

		static trak(t) {
			return t.duration = t.duration || 4294967295, e.box(e.types.trak, e.tkhd(t), e.mdia(t))
		}

		static trex(t) {
			let i = t.id;
			return e.box(e.types.trex, new Uint8Array([0, 0, 0, 0, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
		}

		static trun(t, i) {
			let a, r, n, s, o, l, d = t.samples || [], u = d.length, h = 12 + 16 * u, c = new Uint8Array(h);
			for (i += 8 + h, c.set(["video" === t.type ? 1 : 0, 0, 15, 1, u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, 255 & u, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i], 0), a = 0; a < u; a++) r = d[a], n = r.duration, s = r.size, o = r.flags, l = r.cts, c.set([n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, o.isLeading << 2 | o.dependsOn, o.isDependedOn << 6 | o.hasRedundancy << 4 | o.paddingValue << 1 | o.isNonSync, 61440 & o.degradPrio, 15 & o.degradPrio, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l], 12 + 16 * a);
			return e.box(e.types.trun, c)
		}

		static initSegment(t) {
			e.types || e.init();
			let i = e.moov(t);
			return Fp(e.FTYP, i)
		}
	};
	ZE.types = void 0, ZE.HDLR_TYPES = void 0, ZE.STTS = void 0, ZE.STSC = void 0, ZE.STCO = void 0, ZE.STSZ = void 0, ZE.VMHD = void 0, ZE.SMHD = void 0, ZE.STSD = void 0, ZE.FTYP = void 0, ZE.DINF = void 0;
	var JE = 9e4;

	function eb(e, t, i = 1, a = !1) {
		let r = e * t * i;
		return a ? Math.round(r) : r
	}

	function tb(e, t = !1) {
		return eb(e, 1e3, 1 / JE, t)
	}

	var ib = null, ab = null, rb = class {
		constructor(e, t, i, a = "") {
			if (this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.videoTrackConfig = void 0, this.observer = e, this.config = t, this.typeSupported = i, this.ISGenerated = !1, null === ib) {
				let e = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
				ib = e ? parseInt(e[1]) : 0
			}
			if (null === ab) {
				let e = navigator.userAgent.match(/Safari\/(\d+)/i);
				ab = e ? parseInt(e[1]) : 0
			}
		}

		destroy() {
			this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null
		}

		resetTimeStamp(e) {
			Rf.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = e
		}

		resetNextTimestamp() {
			Rf.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1
		}

		resetInitSegment() {
			Rf.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1, this.videoTrackConfig = void 0
		}

		getVideoStartPts(e) {
			let t = !1, i = e.reduce(((e, i) => {
				let a = i.pts - e;
				return a < -4294967296 ? (t = !0, nb(e, i.pts)) : a > 0 ? e : i.pts
			}), e[0].pts);
			return t && Rf.debug("PTS rollover detected"), i
		}

		remux(e, t, i, a, r, n, s, o) {
			let l, d, u, h, c, m, f = r, p = r, g = e.pid > -1, v = t.pid > -1, E = t.samples.length,
				b = e.samples.length > 0, y = s && E > 0 || E > 1;
			if ((!g || b) && (!v || y) || this.ISGenerated || s) {
				if (this.ISGenerated) {
					var T, A, _, k;
					let e = this.videoTrackConfig;
					e && (t.width !== e.width || t.height !== e.height || (null == (T = t.pixelRatio) ? void 0 : T[0]) !== (null == (A = e.pixelRatio) ? void 0 : A[0]) || (null == (_ = t.pixelRatio) ? void 0 : _[1]) !== (null == (k = e.pixelRatio) ? void 0 : k[1])) && this.resetInitSegment()
				} else u = this.generateIS(e, t, r, n);
				let i, a = this.isVideoContiguous, s = -1;
				if (y && (s = function (e) {
					for (let t = 0; t < e.length; t++) if (e[t].key) return t;
					return -1
				}(t.samples), !a && this.config.forceKeyFrameOnDiscontinuity)) if (m = !0, s > 0) {
					Rf.warn(`[mp4-remuxer]: Dropped ${s} out of ${E} video samples due to a missing keyframe`);
					let e = this.getVideoStartPts(t.samples);
					t.samples = t.samples.slice(s), t.dropped += s, p += (t.samples[0].pts - e) / t.inputTimeScale, i = p
				} else -1 === s && (Rf.warn(`[mp4-remuxer]: No keyframe found out of ${E} video samples`), m = !1);
				if (this.ISGenerated) {
					if (b && y) {
						let i = this.getVideoStartPts(t.samples), a = (nb(e.samples[0].pts, i) - i) / t.inputTimeScale;
						f += Math.max(0, a), p += Math.max(0, -a)
					}
					if (b) {
						if (e.samplerate || (Rf.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), u = this.generateIS(e, t, r, n)), d = this.remuxAudio(e, f, this.isAudioContiguous, n, v || y || o === Lg ? p : void 0), y) {
							let i = d ? d.endPTS - d.startPTS : 0;
							t.inputTimeScale || (Rf.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), u = this.generateIS(e, t, r, n)), l = this.remuxVideo(t, p, a, i)
						}
					} else y && (l = this.remuxVideo(t, p, a, 0));
					l && (l.firstKeyFrame = s, l.independent = -1 !== s, l.firstKeyFramePTS = i)
				}
			}
			return this.ISGenerated && this._initPTS && this._initDTS && (i.samples.length && (c = sb(i, r, this._initPTS, this._initDTS)), a.samples.length && (h = ob(a, r, this._initPTS))), {
				audio: d,
				video: l,
				initSegment: u,
				independent: m,
				text: h,
				id3: c
			}
		}

		generateIS(e, t, i, a) {
			let r, n, s, o = e.samples, l = t.samples, d = this.typeSupported, u = {}, h = this._initPTS, c = !h || a,
				m = "audio/mp4";
			if (c && (r = n = 1 / 0), e.config && o.length) {
				switch (e.timescale = e.samplerate, e.segmentCodec) {
					case"mp3":
						d.mpeg ? (m = "audio/mpeg", e.codec = "") : d.mp3 && (e.codec = "mp3");
						break;
					case"ac3":
						e.codec = "ac-3"
				}
				u.audio = {
					id: "audio",
					container: m,
					codec: e.codec,
					initSegment: "mp3" === e.segmentCodec && d.mpeg ? new Uint8Array(0) : ZE.initSegment([e]),
					metadata: {channelCount: e.channelCount}
				}, c && (s = e.inputTimeScale, h && s === h.timescale ? c = !1 : r = n = o[0].pts - Math.round(s * i))
			}
			if (t.sps && t.pps && l.length) {
				if (t.timescale = t.inputTimeScale, u.video = {
					id: "main",
					container: "video/mp4",
					codec: t.codec,
					initSegment: ZE.initSegment([t]),
					metadata: {width: t.width, height: t.height}
				}, c) if (s = t.inputTimeScale, h && s === h.timescale) c = !1; else {
					let e = this.getVideoStartPts(l), t = Math.round(s * i);
					n = Math.min(n, nb(l[0].dts, e) - t), r = Math.min(r, e - t)
				}
				this.videoTrackConfig = {width: t.width, height: t.height, pixelRatio: t.pixelRatio}
			}
			if (Object.keys(u).length) return this.ISGenerated = !0, c ? (this._initPTS = {
				baseTime: r,
				timescale: s
			}, this._initDTS = {baseTime: n, timescale: s}) : r = s = void 0, {tracks: u, initPTS: r, timescale: s}
		}

		remuxVideo(e, t, i, a) {
			let r, n, s = e.inputTimeScale, o = e.samples, l = [], d = o.length, u = this._initPTS, h = this.nextAvcDts,
				c = 8, m = this.videoSampleDuration, f = Number.POSITIVE_INFINITY, p = Number.NEGATIVE_INFINITY, g = !1;
			if (!i || null === h) {
				let e = t * s, a = o[0].pts - nb(o[0].dts, o[0].pts);
				ib && null !== h && Math.abs(e - a - h) < 15e3 ? i = !0 : h = e - a
			}
			let v = u.baseTime * s / u.timescale;
			for (let e = 0; e < d; e++) {
				let t = o[e];
				t.pts = nb(t.pts - v, h), t.dts = nb(t.dts - v, h), t.dts < o[e > 0 ? e - 1 : e].dts && (g = !0)
			}
			g && o.sort((function (e, t) {
				let i = e.dts - t.dts, a = e.pts - t.pts;
				return i || a
			})), r = o[0].dts, n = o[o.length - 1].dts;
			let E = n - r, b = E ? Math.round(E / (d - 1)) : m || e.inputTimeScale / 30;
			if (i) {
				let e = r - h, i = e > b, a = e < -1;
				if ((i || a) && (i ? Rf.warn(`AVC: ${tb(e, !0)} ms (${e}dts) hole between fragments detected at ${t.toFixed(3)}`) : Rf.warn(`AVC: ${tb(-e, !0)} ms (${e}dts) overlapping between fragments detected at ${t.toFixed(3)}`), !a || h >= o[0].pts || ib)) {
					r = h;
					let t = o[0].pts - e;
					if (i) o[0].dts = r, o[0].pts = t; else for (let i = 0; i < o.length && !(o[i].dts > t); i++) o[i].dts -= e, o[i].pts -= e;
					Rf.log(`Video: Initial PTS/DTS adjusted: ${tb(t, !0)}/${tb(r, !0)}, delta: ${tb(e, !0)} ms`)
				}
			}
			r = Math.max(0, r);
			let y = 0, T = 0, A = r;
			for (let e = 0; e < d; e++) {
				let t = o[e], i = t.units, a = i.length, r = 0;
				for (let e = 0; e < a; e++) r += i[e].data.length;
				T += r, y += a, t.length = r, t.dts < A ? (t.dts = A, A += b / 4 | 0 || 1) : A = t.dts, f = Math.min(t.pts, f), p = Math.max(t.pts, p)
			}
			n = o[d - 1].dts;
			let _, k = T + 4 * y + 8;
			try {
				_ = new Uint8Array(k)
			} catch (e) {
				return void this.observer.emit(Tf.ERROR, Tf.ERROR, {
					type: Af.MUX_ERROR,
					details: _f.REMUX_ALLOC_ERROR,
					fatal: !1,
					error: e,
					bytes: k,
					reason: `fail allocating video mdat ${k}`
				})
			}
			let S = new DataView(_.buffer);
			S.setUint32(0, k), _.set(ZE.types.mdat, 4);
			let w = !1, L = Number.POSITIVE_INFINITY, R = Number.POSITIVE_INFINITY, I = Number.NEGATIVE_INFINITY,
				D = Number.NEGATIVE_INFINITY;
			for (let e = 0; e < d; e++) {
				let t, i = o[e], r = i.units, n = 0;
				for (let e = 0, t = r.length; e < t; e++) {
					let t = r[e], i = t.data, a = t.data.byteLength;
					S.setUint32(c, a), c += 4, _.set(i, c), c += a, n += 4 + a
				}
				if (e < d - 1) m = o[e + 1].dts - i.dts, t = o[e + 1].pts - i.pts; else {
					let r = this.config, n = e > 0 ? i.dts - o[e - 1].dts : b;
					if (t = e > 0 ? i.pts - o[e - 1].pts : b, r.stretchShortVideoTrack && null !== this.nextAudioPts) {
						let e = Math.floor(r.maxBufferHole * s), t = (a ? f + a * s : this.nextAudioPts) - i.pts;
						t > e ? (m = t - n, m < 0 ? m = n : w = !0, Rf.log(`[mp4-remuxer]: It is approximately ${t / 90} ms to the next segment; using duration ${m / 90} ms for the last video frame.`)) : m = n
					} else m = n
				}
				let u = Math.round(i.pts - i.dts);
				L = Math.min(L, m), I = Math.max(I, m), R = Math.min(R, t), D = Math.max(D, t), l.push(new db(i.key, m, n, u))
			}
			if (l.length) if (ib) {
				if (ib < 70) {
					let e = l[0].flags;
					e.dependsOn = 2, e.isNonSync = 0
				}
			} else if (ab && D - R < I - L && b / I < .025 && 0 === l[0].cts) {
				Rf.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
				let e = r;
				for (let t = 0, i = l.length; t < i; t++) {
					let a = e + l[t].duration, r = e + l[t].cts;
					if (t < i - 1) {
						let e = a + l[t + 1].cts;
						l[t].duration = e - r
					} else l[t].duration = t ? l[t - 1].duration : b;
					l[t].cts = 0, e = a
				}
			}
			m = w || !m ? b : m, this.nextAvcDts = h = n + m, this.videoSampleDuration = m, this.isVideoContiguous = !0;
			let C = {
				data1: ZE.moof(e.sequenceNumber++, r, vf({}, e, {samples: l})),
				data2: _,
				startPTS: f / s,
				endPTS: (p + m) / s,
				startDTS: r / s,
				endDTS: h / s,
				type: "video",
				hasAudio: !1,
				hasVideo: !0,
				nb: l.length,
				dropped: e.dropped
			};
			return e.samples = [], e.dropped = 0, C
		}

		getSamplesPerFrame(e) {
			switch (e.segmentCodec) {
				case"mp3":
					return 1152;
				case"ac3":
					return 1536;
				default:
					return 1024
			}
		}

		remuxAudio(e, t, i, a, r) {
			let n = e.inputTimeScale, s = n / (e.samplerate ? e.samplerate : n), o = this.getSamplesPerFrame(e),
				l = o * s, d = this._initPTS, u = "mp3" === e.segmentCodec && this.typeSupported.mpeg, h = [],
				c = void 0 !== r, m = e.samples, f = u ? 0 : 8, p = this.nextAudioPts || -1, g = t * n,
				v = d.baseTime * n / d.timescale;
			if (this.isAudioContiguous = i = i || m.length && p > 0 && (a && Math.abs(g - p) < 9e3 || Math.abs(nb(m[0].pts - v, g) - p) < 20 * l), m.forEach((function (e) {
				e.pts = nb(e.pts - v, g)
			})), !i || p < 0) {
				if (m = m.filter((e => e.pts >= 0)), !m.length) return;
				p = 0 === r ? 0 : a && !c ? Math.max(0, g) : m[0].pts
			}
			if ("aac" === e.segmentCodec) {
				let t = this.config.maxAudioFramesDrift;
				for (let i = 0, a = p; i < m.length; i++) {
					let r = m[i], s = r.pts, o = s - a, d = Math.abs(1e3 * o / n);
					if (o <= -t * l && c) 0 === i && (Rf.warn(`Audio frame @ ${(s / n).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3 * o / n)} ms.`), this.nextAudioPts = p = a = s); else if (o >= t * l && d < 1e4 && c) {
						let t = Math.round(o / l);
						a = s - t * l, a < 0 && (t--, a += l), 0 === i && (this.nextAudioPts = p = a), Rf.warn(`[mp4-remuxer]: Injecting ${t} audio frame @ ${(a / n).toFixed(3)}s due to ${Math.round(1e3 * o / n)} ms gap.`);
						for (let n = 0; n < t; n++) {
							let t = Math.max(a, 0), n = XE.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
							n || (Rf.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), n = r.unit.subarray()), m.splice(i, 0, {
								unit: n,
								pts: t
							}), a += l, i++
						}
					}
					r.pts = a, a += l
				}
			}
			let E, b = null, y = null, T = 0, A = m.length;
			for (; A--;) T += m[A].unit.byteLength;
			for (let t = 0, a = m.length; t < a; t++) {
				let a = m[t], r = a.unit, n = a.pts;
				if (null !== y) {
					h[t - 1].duration = Math.round((n - y) / s)
				} else {
					if (i && "aac" === e.segmentCodec && (n = p), b = n, !(T > 0)) return;
					T += f;
					try {
						E = new Uint8Array(T)
					} catch (e) {
						return void this.observer.emit(Tf.ERROR, Tf.ERROR, {
							type: Af.MUX_ERROR,
							details: _f.REMUX_ALLOC_ERROR,
							fatal: !1,
							error: e,
							bytes: T,
							reason: `fail allocating audio mdat ${T}`
						})
					}
					u || (new DataView(E.buffer).setUint32(0, T), E.set(ZE.types.mdat, 4))
				}
				E.set(r, f);
				let l = r.byteLength;
				f += l, h.push(new db(!0, o, l, 0)), y = n
			}
			let _ = h.length;
			if (!_) return;
			let k = h[h.length - 1];
			this.nextAudioPts = p = y + s * k.duration;
			let S = u ? new Uint8Array(0) : ZE.moof(e.sequenceNumber++, b / s, vf({}, e, {samples: h}));
			e.samples = [];
			let w = b / n, L = p / n, R = {
				data1: S,
				data2: E,
				startPTS: w,
				endPTS: L,
				startDTS: w,
				endDTS: L,
				type: "audio",
				hasAudio: !0,
				hasVideo: !1,
				nb: _
			};
			return this.isAudioContiguous = !0, R
		}

		remuxEmptyAudio(e, t, i, a) {
			let r = e.inputTimeScale, n = r / (e.samplerate ? e.samplerate : r), s = this.nextAudioPts,
				o = this._initDTS, l = 9e4 * o.baseTime / o.timescale, d = (null !== s ? s : a.startDTS * r) + l,
				u = a.endDTS * r + l, h = 1024 * n, c = Math.ceil((u - d) / h),
				m = XE.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
			if (Rf.warn("[mp4-remuxer]: remux empty Audio"), !m) return void Rf.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
			let f = [];
			for (let e = 0; e < c; e++) {
				let t = d + e * h;
				f.push({unit: m, pts: t, dts: t})
			}
			return e.samples = f, this.remuxAudio(e, t, i, !1)
		}
	};

	function nb(e, t) {
		let i;
		if (null === t) return e;
		for (i = t < e ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296;) e += i;
		return e
	}

	function sb(e, t, i, a) {
		let r = e.samples.length;
		if (!r) return;
		let n = e.inputTimeScale;
		for (let s = 0; s < r; s++) {
			let r = e.samples[s];
			r.pts = nb(r.pts - i.baseTime * n / i.timescale, t * n) / n, r.dts = nb(r.dts - a.baseTime * n / a.timescale, t * n) / n
		}
		let s = e.samples;
		return e.samples = [], {samples: s}
	}

	function ob(e, t, i) {
		let a = e.samples.length;
		if (!a) return;
		let r = e.inputTimeScale;
		for (let n = 0; n < a; n++) {
			let a = e.samples[n];
			a.pts = nb(a.pts - i.baseTime * r / i.timescale, t * r) / r
		}
		e.samples.sort(((e, t) => e.pts - t.pts));
		let n = e.samples;
		return e.samples = [], {samples: n}
	}

	var lb, db = class {
		constructor(e, t, i, a) {
			this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = t, this.size = i, this.cts = a, this.flags = {
				isLeading: 0,
				isDependedOn: 0,
				hasRedundancy: 0,
				degradPrio: 0,
				dependsOn: e ? 2 : 1,
				isNonSync: e ? 0 : 1
			}
		}
	};

	function ub(e, t) {
		let i = null == e ? void 0 : e.codec;
		if (i && i.length > 4) return i;
		if (t === Nf) {
			if ("ec-3" === i || "ac-3" === i || "alac" === i) return i;
			if ("fLaC" === i || "Opus" === i) return og(i, !1);
			let e = "mp4a.40.5";
			return Rf.info(`Parsed audio codec "${i}" or audio object type not handled. Using "${e}"`), e
		}
		return Rf.warn(`Unhandled video codec "${i}"`), "hvc1" === i || "hev1" === i ? "hvc1.1.6.L120.90" : "av01" === i ? "av01.0.04M.08" : "avc1.42e01e"
	}

	try {
		lb = self.performance.now.bind(self.performance)
	} catch {
		Rf.debug("Unable to use Performance API on this environment"), lb = null == Kf ? void 0 : Kf.Date.now
	}
	var hb = [{
		demux: class {
			constructor(e, t) {
				this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t
			}

			static probe(e) {
				return function (e) {
					let t = e.byteLength;
					for (let i = 0; i < t;) {
						let a = Sp(e, i);
						if (a > 8 && 109 === e[i + 4] && 111 === e[i + 5] && 111 === e[i + 6] && 102 === e[i + 7]) return !0;
						i = a > 1 ? i + a : t
					}
					return !1
				}(e)
			}

			resetTimeStamp() {
			}

			resetInitSegment(e, t, i, a) {
				let r = this.videoTrack = vE("video", 1), n = this.audioTrack = vE("audio", 1),
					s = this.txtTrack = vE("text", 1);
				if (this.id3Track = vE("id3", 1), this.timeOffset = 0, null == e || !e.byteLength) return;
				let o = Cp(e);
				if (o.video) {
					let {id: e, timescale: t, codec: i} = o.video;
					r.id = e, r.timescale = s.timescale = t, r.codec = i
				}
				if (o.audio) {
					let {id: e, timescale: t, codec: i} = o.audio;
					n.id = e, n.timescale = t, n.codec = i
				}
				s.id = Ap.text, r.sampleDuration = 0, r.duration = n.duration = a
			}

			resetContiguity() {
				this.remainderData = null
			}

			demux(e, t) {
				this.timeOffset = t;
				let i = e, a = this.videoTrack, r = this.txtTrack;
				if (this.config.progressive) {
					this.remainderData && (i = Fp(this.remainderData, e));
					let t = function (e) {
						let t = {valid: null, remainder: null}, i = Ip(e, ["moof"]);
						if (i.length < 2) return t.remainder = e, t;
						let a = i[i.length - 1];
						return t.valid = ip(e, 0, a.byteOffset - 8), t.remainder = ip(e, a.byteOffset - 8), t
					}(i);
					this.remainderData = t.remainder, a.samples = t.valid || new Uint8Array
				} else a.samples = i;
				let n = this.extractID3Track(a, t);
				return r.samples = Bp(t, a), {
					videoTrack: a,
					audioTrack: this.audioTrack,
					id3Track: n,
					textTrack: this.txtTrack
				}
			}

			flush() {
				let e = this.timeOffset, t = this.videoTrack, i = this.txtTrack;
				t.samples = this.remainderData || new Uint8Array, this.remainderData = null;
				let a = this.extractID3Track(t, this.timeOffset);
				return i.samples = Bp(e, t), {videoTrack: t, audioTrack: vE(), id3Track: a, textTrack: vE()}
			}

			extractID3Track(e, t) {
				let i = this.id3Track;
				if (e.samples.length) {
					let a = Ip(e.samples, ["emsg"]);
					a && a.forEach((e => {
						let a = function (e) {
							let t = e[0], i = "", a = "", r = 0, n = 0, s = 0, o = 0, l = 0, d = 0;
							if (0 === t) {
								for (; "\0" !== _p(e.subarray(d, d + 1));) i += _p(e.subarray(d, d + 1)), d += 1;
								for (i += _p(e.subarray(d, d + 1)), d += 1; "\0" !== _p(e.subarray(d, d + 1));) a += _p(e.subarray(d, d + 1)), d += 1;
								a += _p(e.subarray(d, d + 1)), d += 1, r = Sp(e, 12), n = Sp(e, 16), o = Sp(e, 20), l = Sp(e, 24), d = 28
							} else if (1 === t) {
								d += 4, r = Sp(e, d), d += 4;
								let t = Sp(e, d);
								d += 4;
								let n = Sp(e, d);
								for (d += 4, s = 2 ** 32 * t + n, bf(s) || (s = Number.MAX_SAFE_INTEGER, Rf.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o = Sp(e, d), d += 4, l = Sp(e, d), d += 4; "\0" !== _p(e.subarray(d, d + 1));) i += _p(e.subarray(d, d + 1)), d += 1;
								for (i += _p(e.subarray(d, d + 1)), d += 1; "\0" !== _p(e.subarray(d, d + 1));) a += _p(e.subarray(d, d + 1)), d += 1;
								a += _p(e.subarray(d, d + 1)), d += 1
							}
							return {
								schemeIdUri: i,
								value: a,
								timeScale: r,
								presentationTime: s,
								presentationTimeDelta: n,
								eventDuration: o,
								id: l,
								payload: e.subarray(d, e.byteLength)
							}
						}(e);
						if (FE.test(a.schemeIdUri)) {
							let e = Ef(a.presentationTime) ? a.presentationTime / a.timeScale : t + a.presentationTimeDelta / a.timeScale,
								r = 4294967295 === a.eventDuration ? Number.POSITIVE_INFINITY : a.eventDuration / a.timeScale;
							r <= .001 && (r = Number.POSITIVE_INFINITY);
							let n = a.payload;
							i.samples.push({data: n, len: n.byteLength, dts: e, pts: e, type: Fg, duration: r})
						}
					}))
				}
				return i
			}

			demuxSampleAes(e, t, i) {
				return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
			}

			destroy() {
			}
		}, remux: class {
			constructor() {
				this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null
			}

			destroy() {
			}

			resetTimeStamp(e) {
				this.initPTS = e, this.lastEndTime = null
			}

			resetNextTimestamp() {
				this.lastEndTime = null
			}

			resetInitSegment(e, t, i, a) {
				this.audioCodec = t, this.videoCodec = i, this.generateInitSegment(function (e, t) {
					if (!e || !t) return e;
					let i = t.keyId;
					return i && t.isCommonEncryption && Ip(e, ["moov", "trak"]).forEach((e => {
						let t = Ip(e, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8), a = Ip(t, ["enca"]),
							r = a.length > 0;
						r || (a = Ip(t, ["encv"])), a.forEach((e => {
							Ip(r ? e.subarray(28) : e.subarray(78), ["sinf"]).forEach((e => {
								let t = Np(e);
								if (t) {
									let e = t.subarray(8, 24);
									e.some((e => 0 !== e)) || (Rf.log(`[eme] Patching keyId in 'enc${r ? "a" : "v"}>sinf>>tenc' box: ${bp(e)} -> ${bp(i)}`), t.set(i, 8))
								}
							}))
						}))
					})), e
				}(e, a)), this.emitInitSegment = !0
			}

			generateInitSegment(e) {
				let {audioCodec: t, videoCodec: i} = this;
				if (null == e || !e.byteLength) return this.initTracks = void 0, void (this.initData = void 0);
				let a = this.initData = Cp(e);
				a.audio && (t = ub(a.audio, Nf)), a.video && (i = ub(a.video, Uf));
				let r = {};
				a.audio && a.video ? r.audiovideo = {
					container: "video/mp4",
					codec: t + "," + i,
					initSegment: e,
					id: "main"
				} : a.audio ? r.audio = {
					container: "audio/mp4",
					codec: t,
					initSegment: e,
					id: "audio"
				} : a.video ? r.video = {
					container: "video/mp4",
					codec: i,
					initSegment: e,
					id: "main"
				} : Rf.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = r
			}

			remux(e, t, i, a, r, n) {
				var s, o;
				let {initPTS: l, lastEndTime: d} = this,
					u = {audio: void 0, video: void 0, text: a, id3: i, initSegment: void 0};
				Ef(d) || (d = this.lastEndTime = r || 0);
				let h = t.samples;
				if (null == h || !h.length) return u;
				let c = {initPTS: void 0, timescale: 1}, m = this.initData;
				if (null != (s = m) && s.length || (this.generateInitSegment(h), m = this.initData), null == (o = m) || !o.length) return Rf.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), u;
				this.emitInitSegment && (c.tracks = this.initTracks, this.emitInitSegment = !1);
				let f = function (e, t) {
					let i = 0, a = 0, r = 0, n = Ip(e, ["moof", "traf"]);
					for (let e = 0; e < n.length; e++) {
						let s = n[e], o = Ip(s, ["tfhd"])[0], l = t[Sp(o, 4)];
						if (!l) continue;
						let d = l.default, u = Sp(o, 0) | (null == d ? void 0 : d.flags),
							h = null == d ? void 0 : d.duration;
						8 & u && (h = Sp(o, 2 & u ? 12 : 8));
						let c = l.timescale || 9e4, m = Ip(s, ["trun"]);
						for (let e = 0; e < m.length; e++) i = Up(m[e]), !i && h && (i = h * Sp(m[e], 4)), l.type === Uf ? a += i / c : l.type === Nf && (r += i / c)
					}
					if (0 === a && 0 === r) {
						let t = 1 / 0, i = 0, a = 0, r = Ip(e, ["sidx"]);
						for (let e = 0; e < r.length; e++) {
							let n = Dp(r[e]);
							if (null != n && n.references) {
								t = Math.min(t, n.earliestPresentationTime / n.timescale);
								let e = n.references.reduce(((e, t) => e + t.info.duration || 0), 0);
								i = Math.max(i, e + n.earliestPresentationTime / n.timescale), a = i - t
							}
						}
						if (a && Ef(a)) return a
					}
					return a || r
				}(h, m), p = function (e, t) {
					return Ip(t, ["moof", "traf"]).reduce(((t, i) => {
						let a = Ip(i, ["tfdt"])[0], r = a[0], n = Ip(i, ["tfhd"]).reduce(((t, i) => {
							let n = Sp(i, 4), s = e[n];
							if (s) {
								let e = Sp(a, 4);
								if (1 === r) {
									if (e === yp) return Rf.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time"), t;
									e *= yp + 1, e += Sp(a, 8)
								}
								let i = e / (s.timescale || 9e4);
								if (Ef(i) && (null === t || i < t)) return i
							}
							return t
						}), null);
						return null !== n && Ef(n) && (null === t || n < t) ? n : t
					}), null)
				}(m, h), g = null === p ? r : p;
				(function (e, t, i, a) {
					if (null === e) return !0;
					let r = Math.max(a, 1), n = t - e.baseTime / e.timescale;
					return Math.abs(n - i) > r
				}(l, g, r, f) || c.timescale !== l.timescale && n) && (c.initPTS = g - r, l && 1 === l.timescale && Rf.warn("Adjusting initPTS by " + (c.initPTS - l.baseTime)), this.initPTS = l = {
					baseTime: c.initPTS,
					timescale: 1
				});
				let v = e ? g - l.baseTime / l.timescale : d, E = v + f;
				(function (e, t, i) {
					Ip(t, ["moof", "traf"]).forEach((t => {
						Ip(t, ["tfhd"]).forEach((a => {
							let r = Sp(a, 4), n = e[r];
							if (!n) return;
							let s = n.timescale || 9e4;
							Ip(t, ["tfdt"]).forEach((e => {
								let t = e[0], a = i * s;
								if (a) {
									let i = Sp(e, 4);
									if (0 === t) i -= a, i = Math.max(i, 0), Rp(e, 4, i); else {
										i *= Math.pow(2, 32), i += Sp(e, 8), i -= a, i = Math.max(i, 0);
										let t = Math.floor(i / (yp + 1)), r = Math.floor(i % (yp + 1));
										Rp(e, 4, t), Rp(e, 8, r)
									}
								}
							}))
						}))
					}))
				})(m, h, l.baseTime / l.timescale), f > 0 ? this.lastEndTime = E : (Rf.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
				let b = !!m.audio, y = !!m.video, T = "";
				b && (T += "audio"), y && (T += "video");
				let A = {
					data1: h,
					startPTS: v,
					startDTS: v,
					endPTS: E,
					endDTS: E,
					type: T,
					hasAudio: b,
					hasVideo: y,
					nb: 1,
					dropped: 0
				};
				return u.audio = "audio" === A.type ? A : void 0, u.video = "audio" !== A.type ? A : void 0, u.initSegment = c, u.id3 = sb(i, r, l, l), a.samples.length && (u.text = ob(a, r, l)), u
			}
		}
	}, {
		demux: class e {
			constructor(e, t, i) {
				this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._videoTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.remainderData = null, this.videoParser = void 0, this.observer = e, this.config = t, this.typeSupported = i, this.videoParser = new GE
			}

			static probe(t) {
				let i = e.syncOffset(t);
				return i > 0 && Rf.warn(`MPEG2-TS detected but first sync word found @ offset ${i}`), -1 !== i
			}

			static syncOffset(e) {
				let t = e.length, i = Math.min(940, t - VE) + 1, a = 0;
				for (; a < i;) {
					let r = !1, n = -1, s = 0;
					for (let o = a; o < t; o += VE) {
						if (71 !== e[o] || t - o !== VE && 71 !== e[o + VE]) {
							if (s) return -1;
							break
						}
						if (s++, -1 === n && (n = o, 0 !== n && (i = Math.min(n + 18612, e.length - VE) + 1)), r || (r = 0 === KE(e, o)), r && s > 1 && (0 === n && s > 2 || o + VE > i)) return n
					}
					a++
				}
				return -1
			}

			static createTrack(e, t) {
				return {
					container: "video" === e || "audio" === e ? "video/mp2t" : void 0,
					type: e,
					id: Ap[e],
					pid: -1,
					inputTimeScale: 9e4,
					sequenceNumber: 0,
					samples: [],
					dropped: 0,
					duration: "audio" === e ? t : void 0
				}
			}

			resetInitSegment(t, i, a, r) {
				this.pmtParsed = !1, this._pmtId = -1, this._videoTrack = e.createTrack("video"), this._audioTrack = e.createTrack("audio", r), this._id3Track = e.createTrack("id3"), this._txtTrack = e.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.remainderData = null, this.audioCodec = i, this.videoCodec = a, this._duration = r
			}

			resetTimeStamp() {
			}

			resetContiguity() {
				let {_audioTrack: e, _videoTrack: t, _id3Track: i} = this;
				e && (e.pesData = null), t && (t.pesData = null), i && (i.pesData = null), this.aacOverFlow = null, this.remainderData = null
			}

			demux(t, i, a = !1, r = !1) {
				a || (this.sampleAes = null);
				let n, s = this._videoTrack, o = this._audioTrack, l = this._id3Track, d = this._txtTrack, u = s.pid,
					h = s.pesData, c = o.pid, m = l.pid, f = o.pesData, p = l.pesData, g = null, v = this.pmtParsed,
					E = this._pmtId, b = t.length;
				if (this.remainderData && (b = (t = Fp(this.remainderData, t)).length, this.remainderData = null), b < VE && !r) return this.remainderData = t, {
					audioTrack: o,
					videoTrack: s,
					id3Track: l,
					textTrack: d
				};
				let y = Math.max(0, e.syncOffset(t));
				b -= (b - y) % VE, b < t.byteLength && !r && (this.remainderData = new Uint8Array(t.buffer, b, t.buffer.byteLength - b));
				let T = 0;
				for (let e = y; e < b; e += VE) if (71 === t[e]) {
					let i, r = !!(64 & t[e + 1]), b = KE(t, e);
					if ((48 & t[e + 3]) >> 4 > 1) {
						if (i = e + 5 + t[e + 4], i === e + VE) continue
					} else i = e + 4;
					switch (b) {
						case u:
							r && (h && (n = zE(h)) && this.videoParser.parseAVCPES(s, d, n, !1, this._duration), h = {
								data: [],
								size: 0
							}), h && (h.data.push(t.subarray(i, e + VE)), h.size += e + VE - i);
							break;
						case c:
							if (r) {
								if (f && (n = zE(f))) switch (o.segmentCodec) {
									case"aac":
										this.parseAACPES(o, n);
										break;
									case"mp3":
										this.parseMPEGPES(o, n);
										break;
									case"ac3":
										this.parseAC3PES(o, n)
								}
								f = {data: [], size: 0}
							}
							f && (f.data.push(t.subarray(i, e + VE)), f.size += e + VE - i);
							break;
						case m:
							r && (p && (n = zE(p)) && this.parseID3PES(l, n), p = {
								data: [],
								size: 0
							}), p && (p.data.push(t.subarray(i, e + VE)), p.size += e + VE - i);
							break;
						case 0:
							r && (i += t[i] + 1), E = this._pmtId = qE(t, i);
							break;
						case E: {
							r && (i += t[i] + 1);
							let n = YE(t, i, this.typeSupported, a);
							u = n.videoPid, u > 0 && (s.pid = u, s.segmentCodec = n.segmentVideoCodec), c = n.audioPid, c > 0 && (o.pid = c, o.segmentCodec = n.segmentAudioCodec), m = n.id3Pid, m > 0 && (l.pid = m), null !== g && !v && (Rf.warn(`MPEG-TS PMT found at ${e} after unknown PID '${g}'. Backtracking to sync byte @${y} to parse all TS packets.`), g = null, e = y - 188), v = this.pmtParsed = !0;
							break
						}
						case 17:
						case 8191:
							break;
						default:
							g = b
					}
				} else T++;
				if (T > 0) {
					let e = new Error(`Found ${T} TS packet/s that do not start with 0x47`);
					this.observer.emit(Tf.ERROR, Tf.ERROR, {
						type: Af.MEDIA_ERROR,
						details: _f.FRAG_PARSING_ERROR,
						fatal: !1,
						error: e,
						reason: e.message
					})
				}
				s.pesData = h, o.pesData = f, l.pesData = p;
				let A = {audioTrack: o, videoTrack: s, id3Track: l, textTrack: d};
				return r && this.extractRemainingSamples(A), A
			}

			flush() {
				let e, {remainderData: t} = this;
				return this.remainderData = null, e = t ? this.demux(t, -1, !1, !0) : {
					videoTrack: this._videoTrack,
					audioTrack: this._audioTrack,
					id3Track: this._id3Track,
					textTrack: this._txtTrack
				}, this.extractRemainingSamples(e), this.sampleAes ? this.decrypt(e, this.sampleAes) : e
			}

			extractRemainingSamples(e) {
				let t, {audioTrack: i, videoTrack: a, id3Track: r, textTrack: n} = e, s = a.pesData, o = i.pesData,
					l = r.pesData;
				if (s && (t = zE(s)) ? (this.videoParser.parseAVCPES(a, n, t, !0, this._duration), a.pesData = null) : a.pesData = s, o && (t = zE(o))) {
					switch (i.segmentCodec) {
						case"aac":
							this.parseAACPES(i, t);
							break;
						case"mp3":
							this.parseMPEGPES(i, t);
							break;
						case"ac3":
							this.parseAC3PES(i, t)
					}
					i.pesData = null
				} else null != o && o.size && Rf.log("last AAC PES packet truncated,might overlap between fragments"), i.pesData = o;
				l && (t = zE(l)) ? (this.parseID3PES(r, t), r.pesData = null) : r.pesData = l
			}

			demuxSampleAes(e, t, i) {
				let a = this.demux(e, i, !0, !this.config.progressive), r = this.sampleAes = new class {
					constructor(e, t, i) {
						this.keyData = void 0, this.decrypter = void 0, this.keyData = i, this.decrypter = new tE(t, {removePKCS7Padding: !1})
					}

					decryptBuffer(e) {
						return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer)
					}

					decryptAacSample(e, t, i) {
						let a = e[t].unit;
						if (a.length <= 16) return;
						let r = a.subarray(16, a.length - a.length % 16),
							n = r.buffer.slice(r.byteOffset, r.byteOffset + r.length);
						this.decryptBuffer(n).then((r => {
							let n = new Uint8Array(r);
							a.set(n, 16), this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, i)
						}))
					}

					decryptAacSamples(e, t, i) {
						for (; ; t++) {
							if (t >= e.length) return void i();
							if (!(e[t].unit.length < 32 || (this.decryptAacSample(e, t, i), this.decrypter.isSync()))) return
						}
					}

					getAvcEncryptedData(e) {
						let t = 16 * Math.floor((e.length - 48) / 160) + 16, i = new Int8Array(t), a = 0;
						for (let t = 32; t < e.length - 16; t += 160, a += 16) i.set(e.subarray(t, t + 16), a);
						return i
					}

					getAvcDecryptedUnit(e, t) {
						let i = new Uint8Array(t), a = 0;
						for (let t = 32; t < e.length - 16; t += 160, a += 16) e.set(i.subarray(a, a + 16), t);
						return e
					}

					decryptAvcSample(e, t, i, a, r) {
						let n = Wp(r.data), s = this.getAvcEncryptedData(n);
						this.decryptBuffer(s.buffer).then((s => {
							r.data = this.getAvcDecryptedUnit(n, s), this.decrypter.isSync() || this.decryptAvcSamples(e, t, i + 1, a)
						}))
					}

					decryptAvcSamples(e, t, i, a) {
						if (e instanceof Uint8Array) throw new Error("Cannot decrypt samples of type Uint8Array");
						for (; ; t++, i = 0) {
							if (t >= e.length) return void a();
							let r = e[t].units;
							for (; !(i >= r.length); i++) {
								let n = r[i];
								if (!(n.data.length <= 48 || 1 !== n.type && 5 !== n.type || (this.decryptAvcSample(e, t, i, a, n), this.decrypter.isSync()))) return
							}
						}
					}
				}(this.observer, this.config, t);
				return this.decrypt(a, r)
			}

			decrypt(e, t) {
				return new Promise((i => {
					let {audioTrack: a, videoTrack: r} = e;
					a.samples && "aac" === a.segmentCodec ? t.decryptAacSamples(a.samples, 0, (() => {
						r.samples ? t.decryptAvcSamples(r.samples, 0, 0, (() => {
							i(e)
						})) : i(e)
					})) : r.samples && t.decryptAvcSamples(r.samples, 0, 0, (() => {
						i(e)
					}))
				}))
			}

			destroy() {
				this._duration = 0
			}

			parseAACPES(e, t) {
				let i, a, r, n = 0, s = this.aacOverFlow, o = t.data;
				if (s) {
					this.aacOverFlow = null;
					let t = s.missing, i = s.sample.unit.byteLength;
					if (-1 === t) o = Fp(s.sample.unit, o); else {
						let a = i - t;
						s.sample.unit.set(o.subarray(0, t), a), e.samples.push(s.sample), n = s.missing
					}
				}
				for (i = n, a = o.length; i < a - 1 && !_E(o, i); i++) ;
				if (i !== n) {
					let e, t = i < a - 1;
					e = t ? `AAC PES did not start with ADTS header,offset:${i}` : "No ADTS header found in AAC PES";
					let r = new Error(e);
					if (Rf.warn(`parsing error: ${e}`), this.observer.emit(Tf.ERROR, Tf.ERROR, {
						type: Af.MEDIA_ERROR,
						details: _f.FRAG_PARSING_ERROR,
						fatal: !1,
						levelRetry: t,
						error: r,
						reason: e
					}), !t) return
				}
				if (SE(e, this.observer, o, i, this.audioCodec), void 0 !== t.pts) r = t.pts; else {
					if (!s) return void Rf.warn("[tsdemuxer]: AAC PES unknown PTS");
					{
						let t = wE(e.samplerate);
						r = s.sample.pts + t
					}
				}
				let l, d = 0;
				for (; i < a;) {
					if (l = LE(e, o, i, r, d), i += l.length, l.missing) {
						this.aacOverFlow = l;
						break
					}
					for (d++; i < a - 1 && !_E(o, i); i++) ;
				}
			}

			parseMPEGPES(e, t) {
				let i = t.data, a = i.length, r = 0, n = 0, s = t.pts;
				if (void 0 !== s) for (; n < a;) if (NE(i, n)) {
					let t = ME(e, i, n, s, r);
					if (!t) break;
					n += t.length, r++
				} else n++; else Rf.warn("[tsdemuxer]: MPEG PES unknown PTS")
			}

			parseAC3PES(e, t) {
				{
					let i = t.data, a = t.pts;
					if (void 0 === a) return void Rf.warn("[tsdemuxer]: AC3 PES unknown PTS");
					let r, n = i.length, s = 0, o = 0;
					for (; o < n && (r = $E(e, i, o, a, s++)) > 0;) o += r
				}
			}

			parseID3PES(e, t) {
				if (void 0 === t.pts) return void Rf.warn("[tsdemuxer]: ID3 PES unknown PTS");
				let i = vf({}, t, {type: this._videoTrack ? Fg : Ng, duration: Number.POSITIVE_INFINITY});
				e.samples.push(i)
			}
		}, remux: rb
	}, {
		demux: class extends EE {
			constructor(e, t) {
				super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = t
			}

			static probe(e) {
				if (!e) return !1;
				let t = sp(e, 0), i = (null == t ? void 0 : t.length) || 0;
				if (UE(e, i)) return !1;
				for (let t = e.length; i < t; i++) if (kE(e, i)) return Rf.log("ADTS sync word found !"), !0;
				return !1
			}

			resetInitSegment(e, t, i, a) {
				super.resetInitSegment(e, t, i, a), this._audioTrack = {
					container: "audio/adts",
					type: "audio",
					id: 2,
					pid: -1,
					sequenceNumber: 0,
					segmentCodec: "aac",
					samples: [],
					manifestCodec: t,
					duration: a,
					inputTimeScale: 9e4,
					dropped: 0
				}
			}

			canParse(e, t) {
				return function (e, t) {
					return function (e, t) {
						return t + 5 < e.length
					}(e, t) && yE(e, t) && AE(e, t) <= e.length - t
				}(e, t)
			}

			appendFrame(e, t, i) {
				SE(e, this.observer, t, i, e.manifestCodec);
				let a = LE(e, t, i, this.basePTS, this.frameIndex);
				if (a && 0 === a.missing) return a
			}
		}, remux: rb
	}, {
		demux: class extends EE {
			static probe(e) {
				if (!e) return !1;
				let t = sp(e, 0), i = (null == t ? void 0 : t.length) || 0;
				if (t && 11 === e[i] && 119 === e[i + 1] && void 0 !== dp(t) && BE(e, i) <= 16) return !1;
				for (let t = e.length; i < t; i++) if (UE(e, i)) return Rf.log("MPEG Audio sync word found !"), !0;
				return !1
			}

			resetInitSegment(e, t, i, a) {
				super.resetInitSegment(e, t, i, a), this._audioTrack = {
					container: "audio/mpeg",
					type: "audio",
					id: 2,
					pid: -1,
					sequenceNumber: 0,
					segmentCodec: "mp3",
					samples: [],
					manifestCodec: t,
					duration: a,
					inputTimeScale: 9e4,
					dropped: 0
				}
			}

			canParse(e, t) {
				return function (e, t) {
					return PE(e, t) && 4 <= e.length - t
				}(e, t)
			}

			appendFrame(e, t, i) {
				if (null !== this.basePTS) return ME(e, t, i, this.basePTS, this.frameIndex)
			}
		}, remux: rb
	}];
	hb.splice(2, 0, {
		demux: class extends EE {
			constructor(e) {
				super(), this.observer = void 0, this.observer = e
			}

			static probe(e) {
				if (!e) return !1;
				let t = sp(e, 0);
				if (!t) return !1;
				let i = t.length;
				return 11 === e[i] && 119 === e[i + 1] && void 0 !== dp(t) && BE(e, i) < 16
			}

			resetInitSegment(e, t, i, a) {
				super.resetInitSegment(e, t, i, a), this._audioTrack = {
					container: "audio/ac-3",
					type: "audio",
					id: 2,
					pid: -1,
					sequenceNumber: 0,
					segmentCodec: "ac3",
					samples: [],
					manifestCodec: t,
					duration: a,
					inputTimeScale: 9e4,
					dropped: 0
				}
			}

			canParse(e, t) {
				return t + 64 < e.length
			}

			appendFrame(e, t, i) {
				let a = $E(e, t, i, this.basePTS, this.frameIndex);
				if (-1 !== a) return {sample: e.samples[e.samples.length - 1], length: a, missing: 0}
			}
		}, remux: rb
	});
	var cb = class {
		constructor(e, t, i, a, r) {
			this.async = !1, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = i, this.vendor = a, this.id = r
		}

		configure(e) {
			this.transmuxConfig = e, this.decrypter && this.decrypter.reset()
		}

		push(e, t, i, a) {
			let r = i.transmuxing;
			r.executeStart = lb();
			let n = new Uint8Array(e), {currentTransmuxState: s, transmuxConfig: o} = this;
			a && (this.currentTransmuxState = a);
			let {
					contiguous: l,
					discontinuity: d,
					trackSwitch: u,
					accurateTimeOffset: h,
					timeOffset: c,
					initSegmentChange: m
				} = a || s, {audioCodec: f, videoCodec: p, defaultInitPts: g, duration: v, initSegmentData: E} = o,
				b = function (e, t) {
					let i = null;
					return e.byteLength > 0 && null != (null == t ? void 0 : t.key) && null !== t.iv && null != t.method && (i = t), i
				}(n, t);
			if (b && "AES-128" === b.method) {
				let e = this.getDecrypter();
				if (!e.isSync()) return this.decryptionPromise = e.webCryptoDecrypt(n, b.key.buffer, b.iv.buffer).then((e => {
					let t = this.push(e, null, i);
					return this.decryptionPromise = null, t
				})), this.decryptionPromise;
				{
					let t = e.softwareDecrypt(n, b.key.buffer, b.iv.buffer);
					if (i.part > -1 && (t = e.flush()), !t) return r.executeEnd = lb(), mb(i);
					n = new Uint8Array(t)
				}
			}
			let y = this.needsProbing(d, u);
			if (y) {
				let e = this.configureTransmuxer(n);
				if (e) return Rf.warn(`[transmuxer] ${e.message}`), this.observer.emit(Tf.ERROR, Tf.ERROR, {
					type: Af.MEDIA_ERROR,
					details: _f.FRAG_PARSING_ERROR,
					fatal: !1,
					error: e,
					reason: e.message
				}), r.executeEnd = lb(), mb(i)
			}
			(d || u || m || y) && this.resetInitSegment(E, f, p, v, t), (d || m || y) && this.resetInitialTimestamp(g), l || this.resetContiguity();
			let T = this.transmux(n, b, c, h, i), A = this.currentTransmuxState;
			return A.contiguous = !0, A.discontinuity = !1, A.trackSwitch = !1, r.executeEnd = lb(), T
		}

		flush(e) {
			let t = e.transmuxing;
			t.executeStart = lb();
			let {decrypter: i, currentTransmuxState: a, decryptionPromise: r} = this;
			if (r) return r.then((() => this.flush(e)));
			let n = [], {timeOffset: s} = a;
			if (i) {
				let t = i.flush();
				t && n.push(this.push(t, null, e))
			}
			let {demuxer: o, remuxer: l} = this;
			if (!o || !l) return t.executeEnd = lb(), [mb(e)];
			let d = o.flush(s);
			return fb(d) ? d.then((t => (this.flushRemux(n, t, e), n))) : (this.flushRemux(n, d, e), n)
		}

		flushRemux(e, t, i) {
			let {audioTrack: a, videoTrack: r, id3Track: n, textTrack: s} = t, {
				accurateTimeOffset: o,
				timeOffset: l
			} = this.currentTransmuxState;
			Rf.log(`[transmuxer.ts]: Flushed fragment ${i.sn}${i.part > -1 ? " p: " + i.part : ""} of level ${i.level}`);
			let d = this.remuxer.remux(a, r, n, s, l, o, !0, this.id);
			e.push({remuxResult: d, chunkMeta: i}), i.transmuxing.executeEnd = lb()
		}

		resetInitialTimestamp(e) {
			let {demuxer: t, remuxer: i} = this;
			!t || !i || (t.resetTimeStamp(e), i.resetTimeStamp(e))
		}

		resetContiguity() {
			let {demuxer: e, remuxer: t} = this;
			!e || !t || (e.resetContiguity(), t.resetNextTimestamp())
		}

		resetInitSegment(e, t, i, a, r) {
			let {demuxer: n, remuxer: s} = this;
			!n || !s || (n.resetInitSegment(e, t, i, a), s.resetInitSegment(e, t, i, r))
		}

		destroy() {
			this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0)
		}

		transmux(e, t, i, a, r) {
			let n;
			return n = t && "SAMPLE-AES" === t.method ? this.transmuxSampleAes(e, t, i, a, r) : this.transmuxUnencrypted(e, i, a, r), n
		}

		transmuxUnencrypted(e, t, i, a) {
			let {
				audioTrack: r,
				videoTrack: n,
				id3Track: s,
				textTrack: o
			} = this.demuxer.demux(e, t, !1, !this.config.progressive);
			return {remuxResult: this.remuxer.remux(r, n, s, o, t, i, !1, this.id), chunkMeta: a}
		}

		transmuxSampleAes(e, t, i, a, r) {
			return this.demuxer.demuxSampleAes(e, t, i).then((e => ({
				remuxResult: this.remuxer.remux(e.audioTrack, e.videoTrack, e.id3Track, e.textTrack, i, a, !1, this.id),
				chunkMeta: r
			})))
		}

		configureTransmuxer(e) {
			let t, {config: i, observer: a, typeSupported: r, vendor: n} = this;
			for (let i = 0, a = hb.length; i < a; i++) {
				var s;
				if (null != (s = hb[i].demux) && s.probe(e)) {
					t = hb[i];
					break
				}
			}
			if (!t) return new Error("Failed to find demuxer by probing fragment data");
			let o = this.demuxer, l = this.remuxer, d = t.remux, u = t.demux;
			(!l || !(l instanceof d)) && (this.remuxer = new d(a, i, r, n)), (!o || !(o instanceof u)) && (this.demuxer = new u(a, i, r), this.probe = u.probe)
		}

		needsProbing(e, t) {
			return !this.demuxer || !this.remuxer || e || t
		}

		getDecrypter() {
			let e = this.decrypter;
			return e || (e = this.decrypter = new tE(this.config)), e
		}
	};
	var mb = e => ({remuxResult: {}, chunkMeta: e});

	function fb(e) {
		return "then" in e && e.then instanceof Function
	}

	var pb = {exports: {}};
	!function (e) {
		var t = Object.prototype.hasOwnProperty, i = "~";

		function a() {
		}

		function r(e, t, i) {
			this.fn = e, this.context = t, this.once = i || !1
		}

		function n(e, t, a, n, s) {
			if ("function" != typeof a) throw new TypeError("The listener must be a function");
			var o = new r(a, n || e, s), l = i ? i + t : t;
			return e._events[l] ? e._events[l].fn ? e._events[l] = [e._events[l], o] : e._events[l].push(o) : (e._events[l] = o, e._eventsCount++), e
		}

		function s(e, t) {
			0 == --e._eventsCount ? e._events = new a : delete e._events[t]
		}

		function o() {
			this._events = new a, this._eventsCount = 0
		}

		Object.create && (a.prototype = Object.create(null), (new a).__proto__ || (i = !1)), o.prototype.eventNames = function () {
			var e, a, r = [];
			if (0 === this._eventsCount) return r;
			for (a in e = this._events) t.call(e, a) && r.push(i ? a.slice(1) : a);
			return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(e)) : r
		}, o.prototype.listeners = function (e) {
			var t = i ? i + e : e, a = this._events[t];
			if (!a) return [];
			if (a.fn) return [a.fn];
			for (var r = 0, n = a.length, s = new Array(n); r < n; r++) s[r] = a[r].fn;
			return s
		}, o.prototype.listenerCount = function (e) {
			var t = i ? i + e : e, a = this._events[t];
			return a ? a.fn ? 1 : a.length : 0
		}, o.prototype.emit = function (e, t, a, r, n, s) {
			var o = i ? i + e : e;
			if (!this._events[o]) return !1;
			var l, d, u = this._events[o], h = arguments.length;
			if (u.fn) {
				switch (u.once && this.removeListener(e, u.fn, void 0, !0), h) {
					case 1:
						return u.fn.call(u.context), !0;
					case 2:
						return u.fn.call(u.context, t), !0;
					case 3:
						return u.fn.call(u.context, t, a), !0;
					case 4:
						return u.fn.call(u.context, t, a, r), !0;
					case 5:
						return u.fn.call(u.context, t, a, r, n), !0;
					case 6:
						return u.fn.call(u.context, t, a, r, n, s), !0
				}
				for (d = 1, l = new Array(h - 1); d < h; d++) l[d - 1] = arguments[d];
				u.fn.apply(u.context, l)
			} else {
				var c, m = u.length;
				for (d = 0; d < m; d++) switch (u[d].once && this.removeListener(e, u[d].fn, void 0, !0), h) {
					case 1:
						u[d].fn.call(u[d].context);
						break;
					case 2:
						u[d].fn.call(u[d].context, t);
						break;
					case 3:
						u[d].fn.call(u[d].context, t, a);
						break;
					case 4:
						u[d].fn.call(u[d].context, t, a, r);
						break;
					default:
						if (!l) for (c = 1, l = new Array(h - 1); c < h; c++) l[c - 1] = arguments[c];
						u[d].fn.apply(u[d].context, l)
				}
			}
			return !0
		}, o.prototype.on = function (e, t, i) {
			return n(this, e, t, i, !1)
		}, o.prototype.once = function (e, t, i) {
			return n(this, e, t, i, !0)
		}, o.prototype.removeListener = function (e, t, a, r) {
			var n = i ? i + e : e;
			if (!this._events[n]) return this;
			if (!t) return s(this, n), this;
			var o = this._events[n];
			if (o.fn) o.fn === t && (!r || o.once) && (!a || o.context === a) && s(this, n); else {
				for (var l = 0, d = [], u = o.length; l < u; l++) (o[l].fn !== t || r && !o[l].once || a && o[l].context !== a) && d.push(o[l]);
				d.length ? this._events[n] = 1 === d.length ? d[0] : d : s(this, n)
			}
			return this
		}, o.prototype.removeAllListeners = function (e) {
			var t;
			return e ? (t = i ? i + e : e, this._events[t] && s(this, t)) : (this._events = new a, this._eventsCount = 0), this
		}, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = i, o.EventEmitter = o, e.exports = o
	}(pb);
	var gb = function (e) {
		return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
	}(pb.exports), vb = class {
		constructor(e, t, i, a) {
			this.error = null, this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0;
			let r = e.config;
			this.hls = e, this.id = t, this.useWorker = !!r.enableWorker, this.onTransmuxComplete = i, this.onFlush = a;
			let n = (e, t) => {
				(t = t || {}).frag = this.frag, t.id = this.id, e === Tf.ERROR && (this.error = t.error), this.hls.trigger(e, t)
			};
			this.observer = new gb, this.observer.on(Tf.FRAG_DECRYPTED, n), this.observer.on(Tf.ERROR, n);
			let s = Zp(r.preferManagedMediaSource) || {isTypeSupported: () => !1}, o = {
				mpeg: s.isTypeSupported("audio/mpeg"),
				mp3: s.isTypeSupported('audio/mp4; codecs="mp3"'),
				ac3: s.isTypeSupported('audio/mp4; codecs="ac-3"')
			}, l = navigator.vendor;
			if (!this.useWorker || "undefined" == typeof Worker || !r.workerPath && "function" != typeof __HLS_WORKER_BUNDLE__) this.transmuxer = new cb(this.observer, o, r, l, t); else try {
				r.workerPath ? (Rf.log(`loading Web Worker ${r.workerPath} for "${t}"`), this.workerContext = function (e) {
					let t = new self.URL(e, self.location.href).href;
					return {worker: new self.Worker(t), scriptURL: t}
				}(r.workerPath)) : (Rf.log(`injecting Web Worker for "${t}"`), this.workerContext = function () {
					let e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {type: "text/javascript"}),
						t = self.URL.createObjectURL(e);
					return {worker: new self.Worker(t), objectURL: t}
				}()), this.onwmsg = e => this.onWorkerMessage(e);
				let {worker: e} = this.workerContext;
				e.addEventListener("message", this.onwmsg), e.onerror = e => {
					let i = new Error(`${e.message}  (${e.filename}:${e.lineno})`);
					r.enableWorker = !1, Rf.warn(`Error in "${t}" Web Worker, fallback to inline`), this.hls.trigger(Tf.ERROR, {
						type: Af.OTHER_ERROR,
						details: _f.INTERNAL_EXCEPTION,
						fatal: !1,
						event: "demuxerWorker",
						error: i
					})
				}, e.postMessage({cmd: "init", typeSupported: o, vendor: l, id: t, config: JSON.stringify(r)})
			} catch (e) {
				Rf.warn(`Error setting up "${t}" Web Worker, fallback to inline`, e), this.resetWorker(), this.error = null, this.transmuxer = new cb(this.observer, o, r, l, t)
			}
		}

		resetWorker() {
			if (this.workerContext) {
				let {worker: e, objectURL: t} = this.workerContext;
				t && self.URL.revokeObjectURL(t), e.removeEventListener("message", this.onwmsg), e.onerror = null, e.terminate(), this.workerContext = null
			}
		}

		destroy() {
			if (this.workerContext) this.resetWorker(), this.onwmsg = void 0; else {
				let e = this.transmuxer;
				e && (e.destroy(), this.transmuxer = null)
			}
			let e = this.observer;
			e && e.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null
		}

		push(e, t, i, a, r, n, s, o, l, d) {
			var u, h;
			l.transmuxing.start = self.performance.now();
			let {transmuxer: c} = this, m = n ? n.start : r.start, f = r.decryptdata, p = this.frag,
				g = !(p && r.cc === p.cc), v = !(p && l.level === p.level), E = p ? l.sn - p.sn : -1,
				b = this.part ? l.part - this.part.index : -1,
				y = 0 === E && l.id > 1 && l.id === (null == p ? void 0 : p.stats.chunkCount),
				T = !v && (1 === E || 0 === E && (1 === b || y && b <= 0)), A = self.performance.now();
			(v || E || 0 === r.stats.parsing.start) && (r.stats.parsing.start = A), n && (b || !T) && (n.stats.parsing.start = A);
			let _ = !(p && (null == (u = r.initSegment) ? void 0 : u.url) === (null == (h = p.initSegment) ? void 0 : h.url)),
				k = new class {
					constructor(e, t, i, a, r, n) {
						this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = i, this.trackSwitch = a, this.timeOffset = r, this.initSegmentChange = n
					}
				}(g, T, o, v, m, _);
			if (!T || g || _) {
				Rf.log(`[transmuxer-interface, ${r.type}]: Starting new transmux session for sn: ${l.sn} p: ${l.part} level: ${l.level} id: ${l.id}\n        discontinuity: ${g}\n        trackSwitch: ${v}\n        contiguous: ${T}\n        accurateTimeOffset: ${o}\n        timeOffset: ${m}\n        initSegmentChange: ${_}`);
				let e = new class {
					constructor(e, t, i, a, r) {
						this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = i, this.duration = a, this.defaultInitPts = r || null
					}
				}(i, a, t, s, d);
				this.configureTransmuxer(e)
			}
			if (this.frag = r, this.part = n, this.workerContext) this.workerContext.worker.postMessage({
				cmd: "demux",
				data: e,
				decryptdata: f,
				chunkMeta: l,
				state: k
			}, e instanceof ArrayBuffer ? [e] : []); else if (c) {
				let t = c.push(e, f, l, k);
				fb(t) ? (c.async = !0, t.then((e => {
					this.handleTransmuxComplete(e)
				})).catch((e => {
					this.transmuxerError(e, l, "transmuxer-interface push error")
				}))) : (c.async = !1, this.handleTransmuxComplete(t))
			}
		}

		flush(e) {
			e.transmuxing.start = self.performance.now();
			let {transmuxer: t} = this;
			if (this.workerContext) this.workerContext.worker.postMessage({cmd: "flush", chunkMeta: e}); else if (t) {
				let i = t.flush(e);
				fb(i) || t.async ? (fb(i) || (i = Promise.resolve(i)), i.then((t => {
					this.handleFlushResult(t, e)
				})).catch((t => {
					this.transmuxerError(t, e, "transmuxer-interface flush error")
				}))) : this.handleFlushResult(i, e)
			}
		}

		transmuxerError(e, t, i) {
			this.hls && (this.error = e, this.hls.trigger(Tf.ERROR, {
				type: Af.MEDIA_ERROR,
				details: _f.FRAG_PARSING_ERROR,
				chunkMeta: t,
				fatal: !1,
				error: e,
				err: e,
				reason: i
			}))
		}

		handleFlushResult(e, t) {
			e.forEach((e => {
				this.handleTransmuxComplete(e)
			})), this.onFlush(t)
		}

		onWorkerMessage(e) {
			let t = e.data, i = this.hls;
			switch (t.event) {
				case"init": {
					var a;
					let e = null == (a = this.workerContext) ? void 0 : a.objectURL;
					e && self.URL.revokeObjectURL(e);
					break
				}
				case"transmuxComplete":
					this.handleTransmuxComplete(t.data);
					break;
				case"flush":
					this.onFlush(t.data);
					break;
				case"workerLog":
					Rf[t.data.logType] && Rf[t.data.logType](t.data.message);
					break;
				default:
					t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, i.trigger(t.event, t.data)
			}
		}

		configureTransmuxer(e) {
			let {transmuxer: t} = this;
			this.workerContext ? this.workerContext.worker.postMessage({
				cmd: "configure",
				config: e
			}) : t && t.configure(e)
		}

		handleTransmuxComplete(e) {
			e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e)
		}
	};

	function Eb(e, t) {
		if (e.length !== t.length) return !1;
		for (let i = 0; i < e.length; i++) if (!bb(e[i].attrs, t[i].attrs)) return !1;
		return !0
	}

	function bb(e, t, i) {
		let a = e["STABLE-RENDITION-ID"];
		return a && !i ? a === t["STABLE-RENDITION-ID"] : !(i || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some((i => e[i] !== t[i]))
	}

	function yb(e, t) {
		return t.label.toLowerCase() === e.name.toLowerCase() && (!t.language || t.language.toLowerCase() === (e.lang || "").toLowerCase())
	}

	var Tb = class {
		constructor(e) {
			this.buffered = void 0;
			let t = (t, i, a) => {
				if ((i >>>= 0) > a - 1) throw new DOMException(`Failed to execute '${t}' on 'TimeRanges': The index provided (${i}) is greater than the maximum bound (${a})`);
				return e[i][t]
			};
			this.buffered = {
				get length() {
					return e.length
				}, end: i => t("end", i, e.length), start: i => t("start", i, e.length)
			}
		}
	}, Ab = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/;

	function _b(e) {
		let t = e.querySelectorAll("source");
		[].slice.call(t).forEach((t => {
			e.removeChild(t)
		}))
	}

	var kb = {
			42: 225,
			92: 233,
			94: 237,
			95: 243,
			96: 250,
			123: 231,
			124: 247,
			125: 209,
			126: 241,
			127: 9608,
			128: 174,
			129: 176,
			130: 189,
			131: 191,
			132: 8482,
			133: 162,
			134: 163,
			135: 9834,
			136: 224,
			137: 32,
			138: 232,
			139: 226,
			140: 234,
			141: 238,
			142: 244,
			143: 251,
			144: 193,
			145: 201,
			146: 211,
			147: 218,
			148: 220,
			149: 252,
			150: 8216,
			151: 161,
			152: 42,
			153: 8217,
			154: 9473,
			155: 169,
			156: 8480,
			157: 8226,
			158: 8220,
			159: 8221,
			160: 192,
			161: 194,
			162: 199,
			163: 200,
			164: 202,
			165: 203,
			166: 235,
			167: 206,
			168: 207,
			169: 239,
			170: 212,
			171: 217,
			172: 249,
			173: 219,
			174: 171,
			175: 187,
			176: 195,
			177: 227,
			178: 205,
			179: 204,
			180: 236,
			181: 210,
			182: 242,
			183: 213,
			184: 245,
			185: 123,
			186: 125,
			187: 92,
			188: 94,
			189: 95,
			190: 124,
			191: 8764,
			192: 196,
			193: 228,
			194: 214,
			195: 246,
			196: 223,
			197: 165,
			198: 164,
			199: 9475,
			200: 197,
			201: 229,
			202: 216,
			203: 248,
			204: 9487,
			205: 9491,
			206: 9495,
			207: 9499
		}, Sb = function (e) {
			let t = e;
			return kb.hasOwnProperty(e) && (t = kb[e]), String.fromCharCode(t)
		}, wb = 15, Lb = 100, Rb = {17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14},
		Ib = {17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15},
		Db = {25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14},
		Cb = {25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15},
		xb = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"], Mb = function (e) {
			let t = [];
			for (let i = 0; i < e.length; i++) t.push(e[i].toString(16));
			return t
		}, Ob = class {
			constructor() {
				this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
			}

			reset() {
				this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
			}

			setStyles(e) {
				let t = ["foreground", "underline", "italics", "background", "flash"];
				for (let i = 0; i < t.length; i++) {
					let a = t[i];
					e.hasOwnProperty(a) && (this[a] = e[a])
				}
			}

			isDefault() {
				return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash
			}

			equals(e) {
				return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash
			}

			copy(e) {
				this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash
			}

			toString() {
				return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
			}
		}, Pb = class {
			constructor() {
				this.uchar = " ", this.penState = new Ob
			}

			reset() {
				this.uchar = " ", this.penState.reset()
			}

			setChar(e, t) {
				this.uchar = e, this.penState.copy(t)
			}

			setPenState(e) {
				this.penState.copy(e)
			}

			equals(e) {
				return this.uchar === e.uchar && this.penState.equals(e.penState)
			}

			copy(e) {
				this.uchar = e.uchar, this.penState.copy(e.penState)
			}

			isEmpty() {
				return " " === this.uchar && this.penState.isDefault()
			}
		}, Nb = class {
			constructor(e) {
				this.chars = [], this.pos = 0, this.currPenState = new Ob, this.cueStartTime = null, this.logger = void 0;
				for (let e = 0; e < Lb; e++) this.chars.push(new Pb);
				this.logger = e
			}

			equals(e) {
				for (let t = 0; t < Lb; t++) if (!this.chars[t].equals(e.chars[t])) return !1;
				return !0
			}

			copy(e) {
				for (let t = 0; t < Lb; t++) this.chars[t].copy(e.chars[t])
			}

			isEmpty() {
				let e = !0;
				for (let t = 0; t < Lb; t++) if (!this.chars[t].isEmpty()) {
					e = !1;
					break
				}
				return e
			}

			setCursor(e) {
				this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > Lb && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = Lb)
			}

			moveCursor(e) {
				let t = this.pos + e;
				if (e > 1) for (let e = this.pos + 1; e < t + 1; e++) this.chars[e].setPenState(this.currPenState);
				this.setCursor(t)
			}

			backSpace() {
				this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState)
			}

			insertChar(e) {
				e >= 144 && this.backSpace();
				let t = Sb(e);
				this.pos >= Lb ? this.logger.log(0, (() => "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!")) : (this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1))
			}

			clearFromPos(e) {
				let t;
				for (t = e; t < Lb; t++) this.chars[t].reset()
			}

			clear() {
				this.clearFromPos(0), this.pos = 0, this.currPenState.reset()
			}

			clearToEndOfRow() {
				this.clearFromPos(this.pos)
			}

			getTextString() {
				let e = [], t = !0;
				for (let i = 0; i < Lb; i++) {
					let a = this.chars[i].uchar;
					" " !== a && (t = !1), e.push(a)
				}
				return t ? "" : e.join("")
			}

			setPenStyles(e) {
				this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState)
			}
		}, Ub = class {
			constructor(e) {
				this.rows = [], this.currRow = 14, this.nrRollUpRows = null, this.lastOutputScreen = null, this.logger = void 0;
				for (let t = 0; t < wb; t++) this.rows.push(new Nb(e));
				this.logger = e
			}

			reset() {
				for (let e = 0; e < wb; e++) this.rows[e].clear();
				this.currRow = 14
			}

			equals(e) {
				let t = !0;
				for (let i = 0; i < wb; i++) if (!this.rows[i].equals(e.rows[i])) {
					t = !1;
					break
				}
				return t
			}

			copy(e) {
				for (let t = 0; t < wb; t++) this.rows[t].copy(e.rows[t])
			}

			isEmpty() {
				let e = !0;
				for (let t = 0; t < wb; t++) if (!this.rows[t].isEmpty()) {
					e = !1;
					break
				}
				return e
			}

			backSpace() {
				this.rows[this.currRow].backSpace()
			}

			clearToEndOfRow() {
				this.rows[this.currRow].clearToEndOfRow()
			}

			insertChar(e) {
				this.rows[this.currRow].insertChar(e)
			}

			setPen(e) {
				this.rows[this.currRow].setPenStyles(e)
			}

			moveCursor(e) {
				this.rows[this.currRow].moveCursor(e)
			}

			setCursor(e) {
				this.logger.log(2, "setCursor: " + e), this.rows[this.currRow].setCursor(e)
			}

			setPAC(e) {
				this.logger.log(2, (() => "pacData = " + JSON.stringify(e)));
				let t = e.row - 1;
				if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) {
					for (let e = 0; e < wb; e++) this.rows[e].clear();
					let e = this.currRow + 1 - this.nrRollUpRows, i = this.lastOutputScreen;
					if (i) {
						let a = i.rows[e].cueStartTime, r = this.logger.time;
						if (null !== a && null !== r && a < r) for (let a = 0; a < this.nrRollUpRows; a++) this.rows[t - this.nrRollUpRows + a + 1].copy(i.rows[e + a])
					}
				}
				this.currRow = t;
				let i = this.rows[this.currRow];
				if (null !== e.indent) {
					let t = e.indent, a = Math.max(t - 1, 0);
					i.setCursor(e.indent), e.color = i.chars[a].penState.foreground
				}
				let a = {foreground: e.color, underline: e.underline, italics: e.italics, background: "black", flash: !1};
				this.setPen(a)
			}

			setBkgData(e) {
				this.logger.log(2, (() => "bkgData = " + JSON.stringify(e))), this.backSpace(), this.setPen(e), this.insertChar(32)
			}

			setRollUpRows(e) {
				this.nrRollUpRows = e
			}

			rollUp() {
				if (null === this.nrRollUpRows) return void this.logger.log(3, "roll_up but nrRollUpRows not set yet");
				this.logger.log(1, (() => this.getDisplayText()));
				let e = this.currRow + 1 - this.nrRollUpRows, t = this.rows.splice(e, 1)[0];
				t.clear(), this.rows.splice(this.currRow, 0, t), this.logger.log(2, "Rolling up")
			}

			getDisplayText(e) {
				e = e || !1;
				let t = [], i = "", a = -1;
				for (let i = 0; i < wb; i++) {
					let r = this.rows[i].getTextString();
					r && (a = i + 1, e ? t.push("Row " + a + ": '" + r + "'") : t.push(r.trim()))
				}
				return t.length > 0 && (i = e ? "[" + t.join(" | ") + "]" : t.join("\n")), i
			}

			getTextAndFormat() {
				return this.rows
			}
		}, Fb = class {
			constructor(e, t, i) {
				this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new Ub(i), this.nonDisplayedMemory = new Ub(i), this.lastOutputScreen = new Ub(i), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = i
			}

			reset() {
				this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null
			}

			getHandler() {
				return this.outputFilter
			}

			setHandler(e) {
				this.outputFilter = e
			}

			setPAC(e) {
				this.writeScreen.setPAC(e)
			}

			setBkgData(e) {
				this.writeScreen.setBkgData(e)
			}

			setMode(e) {
				e !== this.mode && (this.mode = e, this.logger.log(2, (() => "MODE=" + e)), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e)
			}

			insertChars(e) {
				for (let t = 0; t < e.length; t++) this.writeScreen.insertChar(e[t]);
				let t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
				this.logger.log(2, (() => t + ": " + this.writeScreen.getDisplayText(!0))), ("MODE_PAINT-ON" === this.mode || "MODE_ROLL-UP" === this.mode) && (this.logger.log(1, (() => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0))), this.outputDataUpdate())
			}

			ccRCL() {
				this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON")
			}

			ccBS() {
				this.logger.log(2, "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate())
			}

			ccAOF() {
			}

			ccAON() {
			}

			ccDER() {
				this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate()
			}

			ccRU(e) {
				this.logger.log(2, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e)
			}

			ccFON() {
				this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({flash: !0})
			}

			ccRDC() {
				this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON")
			}

			ccTR() {
				this.logger.log(2, "TR"), this.setMode("MODE_TEXT")
			}

			ccRTD() {
				this.logger.log(2, "RTD"), this.setMode("MODE_TEXT")
			}

			ccEDM() {
				this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0)
			}

			ccCR() {
				this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0)
			}

			ccENM() {
				this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset()
			}

			ccEOC() {
				if (this.logger.log(2, "EOC - End Of Caption"), "MODE_POP-ON" === this.mode) {
					let e = this.displayedMemory;
					this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, (() => "DISP: " + this.displayedMemory.getDisplayText()))
				}
				this.outputDataUpdate(!0)
			}

			ccTO(e) {
				this.logger.log(2, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e)
			}

			ccMIDROW(e) {
				let t = {flash: !1};
				if (t.underline = e % 2 == 1, t.italics = e >= 46, t.italics) t.foreground = "white"; else {
					let i = Math.floor(e / 2) - 16, a = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
					t.foreground = a[i]
				}
				this.logger.log(2, "MIDROW: " + JSON.stringify(t)), this.writeScreen.setPen(t)
			}

			outputDataUpdate(e = !1) {
				let t = this.logger.time;
				null !== t && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t) : this.cueStartTime = t, this.lastOutputScreen.copy(this.displayedMemory))
			}

			cueSplitAtTime(e) {
				this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e))
			}
		}, Bb = class {
			constructor(e, t, i) {
				this.channels = void 0, this.currentChannel = 0, this.cmdHistory = {a: null, b: null}, this.logger = void 0;
				let a = this.logger = new class {
					constructor() {
						this.time = null, this.verboseLevel = 0
					}

					log(e, t) {
						if (this.verboseLevel >= e) {
							let i = "function" == typeof t ? t() : t;
							Rf.log(`${this.time} [${e}] ${i}`)
						}
					}
				};
				this.channels = [null, new Fb(e, t, a), new Fb(e + 1, i, a)]
			}

			getHandler(e) {
				return this.channels[e].getHandler()
			}

			setHandler(e, t) {
				this.channels[e].setHandler(t)
			}

			addData(e, t) {
				let i, a, r, n = !1;
				this.logger.time = e;
				for (let e = 0; e < t.length; e += 2) if (a = 127 & t[e], r = 127 & t[e + 1], 0 !== a || 0 !== r) {
					if (this.logger.log(3, "[" + Mb([t[e], t[e + 1]]) + "] -> (" + Mb([a, r]) + ")"), i = this.parseCmd(a, r), i || (i = this.parseMidrow(a, r)), i || (i = this.parsePAC(a, r)), i || (i = this.parseBackgroundAttributes(a, r)), !i && (n = this.parseChars(a, r), n)) {
						let e = this.currentChannel;
						e && e > 0 ? this.channels[e].insertChars(n) : this.logger.log(2, "No channel found yet. TEXT-MODE?")
					}
					!i && !n && this.logger.log(2, "Couldn't parse cleaned data " + Mb([a, r]) + " orig: " + Mb([t[e], t[e + 1]]))
				}
			}

			parseCmd(e, t) {
				let {cmdHistory: i} = this;
				if (!((20 === e || 28 === e || 21 === e || 29 === e) && t >= 32 && t <= 47) && !((23 === e || 31 === e) && t >= 33 && t <= 35)) return !1;
				if (Hb(e, t, i)) return $b(null, null, i), this.logger.log(3, "Repeated command (" + Mb([e, t]) + ") is dropped"), !0;
				let a = 20 === e || 21 === e || 23 === e ? 1 : 2, r = this.channels[a];
				return 20 === e || 21 === e || 28 === e || 29 === e ? 32 === t ? r.ccRCL() : 33 === t ? r.ccBS() : 34 === t ? r.ccAOF() : 35 === t ? r.ccAON() : 36 === t ? r.ccDER() : 37 === t ? r.ccRU(2) : 38 === t ? r.ccRU(3) : 39 === t ? r.ccRU(4) : 40 === t ? r.ccFON() : 41 === t ? r.ccRDC() : 42 === t ? r.ccTR() : 43 === t ? r.ccRTD() : 44 === t ? r.ccEDM() : 45 === t ? r.ccCR() : 46 === t ? r.ccENM() : 47 === t && r.ccEOC() : r.ccTO(t - 32), $b(e, t, i), this.currentChannel = a, !0
			}

			parseMidrow(e, t) {
				let i = 0;
				if ((17 === e || 25 === e) && t >= 32 && t <= 47) {
					if (i = 17 === e ? 1 : 2, i !== this.currentChannel) return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
					let a = this.channels[i];
					return !!a && (a.ccMIDROW(t), this.logger.log(3, "MIDROW (" + Mb([e, t]) + ")"), !0)
				}
				return !1
			}

			parsePAC(e, t) {
				let i, a = this.cmdHistory;
				if (!((e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127) && !((16 === e || 24 === e) && t >= 64 && t <= 95)) return !1;
				if (Hb(e, t, a)) return $b(null, null, a), !0;
				let r = e <= 23 ? 1 : 2;
				i = t >= 64 && t <= 95 ? 1 === r ? Rb[e] : Db[e] : 1 === r ? Ib[e] : Cb[e];
				let n = this.channels[r];
				return !!n && (n.setPAC(this.interpretPAC(i, t)), $b(e, t, a), this.currentChannel = r, !0)
			}

			interpretPAC(e, t) {
				let i, a = {color: null, italics: !1, indent: null, underline: !1, row: e};
				return i = t > 95 ? t - 96 : t - 64, a.underline = 1 == (1 & i), i <= 13 ? a.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(i / 2)] : i <= 15 ? (a.italics = !0, a.color = "white") : a.indent = 4 * Math.floor((i - 16) / 2), a
			}

			parseChars(e, t) {
				let i, a = null, r = null;
				if (e >= 25 ? (i = 2, r = e - 8) : (i = 1, r = e), r >= 17 && r <= 19) {
					let e;
					e = 17 === r ? t + 80 : 18 === r ? t + 112 : t + 144, this.logger.log(2, "Special char '" + Sb(e) + "' in channel " + i), a = [e]
				} else e >= 32 && e <= 127 && (a = 0 === t ? [e] : [e, t]);
				if (a) {
					let i = Mb(a);
					this.logger.log(3, "Char codes =  " + i.join(",")), $b(e, t, this.cmdHistory)
				}
				return a
			}

			parseBackgroundAttributes(e, t) {
				if (!((16 === e || 24 === e) && t >= 32 && t <= 47) && !((23 === e || 31 === e) && t >= 45 && t <= 47)) return !1;
				let i, a = {};
				16 === e || 24 === e ? (i = Math.floor((t - 32) / 2), a.background = xb[i], t % 2 == 1 && (a.background = a.background + "_semi")) : 45 === t ? a.background = "transparent" : (a.foreground = "black", 47 === t && (a.underline = !0));
				let r = e <= 23 ? 1 : 2;
				return this.channels[r].setBkgData(a), $b(e, t, this.cmdHistory), !0
			}

			reset() {
				for (let e = 0; e < Object.keys(this.channels).length; e++) {
					let t = this.channels[e];
					t && t.reset()
				}
				this.cmdHistory = {a: null, b: null}
			}

			cueSplitAtTime(e) {
				for (let t = 0; t < this.channels.length; t++) {
					let i = this.channels[t];
					i && i.cueSplitAtTime(e)
				}
			}
		};

	function $b(e, t, i) {
		i.a = e, i.b = t
	}

	function Hb(e, t, i) {
		return i.a === e && i.b === t
	}

	var Wb = class {
		constructor(e, t) {
			this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t
		}

		dispatchCue() {
			null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null)
		}

		newCue(e, t, i) {
			(null === this.startTime || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = i, this.timelineController.createCaptionsTrack(this.trackName)
		}

		reset() {
			this.cueRanges = [], this.startTime = null
		}
	}, Gb = function () {
		if (null != Kf && Kf.VTTCue) return self.VTTCue;
		let e = ["", "lr", "rl"], t = ["start", "middle", "end", "left", "right"];

		function i(e, t) {
			if ("string" != typeof t || !Array.isArray(e)) return !1;
			let i = t.toLowerCase();
			return !!~e.indexOf(i) && i
		}

		function a(e) {
			return i(t, e)
		}

		function r(e, ...t) {
			let i = 1;
			for (; i < arguments.length; i++) {
				let t = arguments[i];
				for (let i in t) e[i] = t[i]
			}
			return e
		}

		function n(t, n, s) {
			let o = this, l = {enumerable: !0};
			o.hasBeenReset = !1;
			let d = "", u = !1, h = t, c = n, m = s, f = null, p = "", g = !0, v = "auto", E = "start", b = 50,
				y = "middle", T = 50, A = "middle";
			Object.defineProperty(o, "id", r({}, l, {
				get: function () {
					return d
				}, set: function (e) {
					d = "" + e
				}
			})), Object.defineProperty(o, "pauseOnExit", r({}, l, {
				get: function () {
					return u
				}, set: function (e) {
					u = !!e
				}
			})), Object.defineProperty(o, "startTime", r({}, l, {
				get: function () {
					return h
				}, set: function (e) {
					if ("number" != typeof e) throw new TypeError("Start time must be set to a number.");
					h = e, this.hasBeenReset = !0
				}
			})), Object.defineProperty(o, "endTime", r({}, l, {
				get: function () {
					return c
				}, set: function (e) {
					if ("number" != typeof e) throw new TypeError("End time must be set to a number.");
					c = e, this.hasBeenReset = !0
				}
			})), Object.defineProperty(o, "text", r({}, l, {
				get: function () {
					return m
				}, set: function (e) {
					m = "" + e, this.hasBeenReset = !0
				}
			})), Object.defineProperty(o, "region", r({}, l, {
				get: function () {
					return f
				}, set: function (e) {
					f = e, this.hasBeenReset = !0
				}
			})), Object.defineProperty(o, "vertical", r({}, l, {
				get: function () {
					return p
				}, set: function (t) {
					let a = function (t) {
						return i(e, t)
					}(t);
					if (!1 === a) throw new SyntaxError("An invalid or illegal string was specified.");
					p = a, this.hasBeenReset = !0
				}
			})), Object.defineProperty(o, "snapToLines", r({}, l, {
				get: function () {
					return g
				}, set: function (e) {
					g = !!e, this.hasBeenReset = !0
				}
			})), Object.defineProperty(o, "line", r({}, l, {
				get: function () {
					return v
				}, set: function (e) {
					if ("number" != typeof e && "auto" !== e) throw new SyntaxError("An invalid number or illegal string was specified.");
					v = e, this.hasBeenReset = !0
				}
			})), Object.defineProperty(o, "lineAlign", r({}, l, {
				get: function () {
					return E
				}, set: function (e) {
					let t = a(e);
					if (!t) throw new SyntaxError("An invalid or illegal string was specified.");
					E = t, this.hasBeenReset = !0
				}
			})), Object.defineProperty(o, "position", r({}, l, {
				get: function () {
					return b
				}, set: function (e) {
					if (e < 0 || e > 100) throw new Error("Position must be between 0 and 100.");
					b = e, this.hasBeenReset = !0
				}
			})), Object.defineProperty(o, "positionAlign", r({}, l, {
				get: function () {
					return y
				}, set: function (e) {
					let t = a(e);
					if (!t) throw new SyntaxError("An invalid or illegal string was specified.");
					y = t, this.hasBeenReset = !0
				}
			})), Object.defineProperty(o, "size", r({}, l, {
				get: function () {
					return T
				}, set: function (e) {
					if (e < 0 || e > 100) throw new Error("Size must be between 0 and 100.");
					T = e, this.hasBeenReset = !0
				}
			})), Object.defineProperty(o, "align", r({}, l, {
				get: function () {
					return A
				}, set: function (e) {
					let t = a(e);
					if (!t) throw new SyntaxError("An invalid or illegal string was specified.");
					A = t, this.hasBeenReset = !0
				}
			})), o.displayState = void 0
		}

		return n.prototype.getCueAsHTML = function () {
			return self.WebVTT.convertCueToDOMTree(self, this.text)
		}, n
	}();

	function Vb(e) {
		function t(e, t, i, a) {
			return 3600 * (0 | e) + 60 * (0 | t) + (0 | i) + parseFloat(a || 0)
		}

		let i = e.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
		return i ? parseFloat(i[2]) > 59 ? t(i[2], i[3], 0, i[4]) : t(i[1], i[2], i[3], i[4]) : null
	}

	function Kb(e, t, i, a) {
		let r = a ? e.split(a) : [e];
		for (let e in r) {
			if ("string" != typeof r[e]) continue;
			let a = r[e].split(i);
			2 === a.length && t(a[0], a[1])
		}
	}

	var qb = new Gb(0, 0, ""), Yb = "middle" === qb.align ? "middle" : "center";

	function jb(e, t, i) {
		let a = e;

		function r() {
			let t = Vb(e);
			if (null === t) throw new Error("Malformed timestamp: " + a);
			return e = e.replace(/^[^\sa-zA-Z-]+/, ""), t
		}

		function n() {
			e = e.replace(/^\s+/, "")
		}

		if (n(), t.startTime = r(), n(), "--\x3e" !== e.slice(0, 3)) throw new Error("Malformed time stamp (time stamps must be separated by '--\x3e'): " + a);
		e = e.slice(3), n(), t.endTime = r(), n(), function (e, t) {
			let a = new class {
				constructor() {
					this.values = Object.create(null)
				}

				set(e, t) {
					!this.get(e) && "" !== t && (this.values[e] = t)
				}

				get(e, t, i) {
					return i ? this.has(e) ? this.values[e] : t[i] : this.has(e) ? this.values[e] : t
				}

				has(e) {
					return e in this.values
				}

				alt(e, t, i) {
					for (let a = 0; a < i.length; ++a) if (t === i[a]) {
						this.set(e, t);
						break
					}
				}

				integer(e, t) {
					/^-?\d+$/.test(t) && this.set(e, parseInt(t, 10))
				}

				percent(e, t) {
					if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
						let i = parseFloat(t);
						if (i >= 0 && i <= 100) return this.set(e, i), !0
					}
					return !1
				}
			};
			Kb(e, (function (e, t) {
				let r;
				switch (e) {
					case"region":
						for (let r = i.length - 1; r >= 0; r--) if (i[r].id === t) {
							a.set(e, i[r].region);
							break
						}
						break;
					case"vertical":
						a.alt(e, t, ["rl", "lr"]);
						break;
					case"line":
						r = t.split(","), a.integer(e, r[0]), a.percent(e, r[0]) && a.set("snapToLines", !1), a.alt(e, r[0], ["auto"]), 2 === r.length && a.alt("lineAlign", r[1], ["start", Yb, "end"]);
						break;
					case"position":
						r = t.split(","), a.percent(e, r[0]), 2 === r.length && a.alt("positionAlign", r[1], ["start", Yb, "end", "line-left", "line-right", "auto"]);
						break;
					case"size":
						a.percent(e, t);
						break;
					case"align":
						a.alt(e, t, ["start", Yb, "end", "left", "right"])
				}
			}), /:/, /\s/), t.region = a.get("region", null), t.vertical = a.get("vertical", "");
			let r = a.get("line", "auto");
			"auto" === r && -1 === qb.line && (r = -1), t.line = r, t.lineAlign = a.get("lineAlign", "start"), t.snapToLines = a.get("snapToLines", !0), t.size = a.get("size", 100), t.align = a.get("align", Yb);
			let n = a.get("position", "auto");
			"auto" === n && 50 === qb.position && (n = "start" === t.align || "left" === t.align ? 0 : "end" === t.align || "right" === t.align ? 100 : 50), t.position = n
		}(e, t)
	}

	function zb(e) {
		return e.replace(/<br(?: \/)?>/gi, "\n")
	}

	var Xb = /\r\n|\n\r|\n|\r/g, Qb = function (e, t, i = 0) {
		return e.slice(i, i + t.length) === t
	}, Zb = function (e) {
		let t = 5381, i = e.length;
		for (; i;) t = 33 * t ^ e.charCodeAt(--i);
		return (t >>> 0).toString()
	};

	function Jb(e, t, i) {
		return Zb(e.toString()) + Zb(t.toString()) + Zb(i)
	}

	function ey(e, t, i, a, r, n, s) {
		let o, l = new class {
			constructor() {
				this.state = "INITIAL", this.buffer = "", this.decoder = new class {
					decode(e, t) {
						if (!e) return "";
						if ("string" != typeof e) throw new Error("Error - expected string data.");
						return decodeURIComponent(encodeURIComponent(e))
					}
				}, this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0
			}

			parse(e) {
				let t = this;

				function i() {
					let e = t.buffer, i = 0;
					for (e = zb(e); i < e.length && "\r" !== e[i] && "\n" !== e[i];) ++i;
					let a = e.slice(0, i);
					return "\r" === e[i] && ++i, "\n" === e[i] && ++i, t.buffer = e.slice(i), a
				}

				function a(e) {
					Kb(e, (function (e, t) {
					}), /:/)
				}

				e && (t.buffer += t.decoder.decode(e, {stream: !0}));
				try {
					let e = "";
					if ("INITIAL" === t.state) {
						if (!/\r\n|\n/.test(t.buffer)) return this;
						e = i();
						let a = e.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
						if (null == a || !a[0]) throw new Error("Malformed WebVTT signature.");
						t.state = "HEADER"
					}
					let r = !1;
					for (; t.buffer;) {
						if (!/\r\n|\n/.test(t.buffer)) return this;
						switch (r ? r = !1 : e = i(), t.state) {
							case"HEADER":
								/:/.test(e) ? a(e) : e || (t.state = "ID");
								continue;
							case"NOTE":
								e || (t.state = "ID");
								continue;
							case"ID":
								if (/^NOTE($|[ \t])/.test(e)) {
									t.state = "NOTE";
									break
								}
								if (!e) continue;
								if (t.cue = new Gb(0, 0, ""), t.state = "CUE", -1 === e.indexOf("--\x3e")) {
									t.cue.id = e;
									continue
								}
							case"CUE":
								if (!t.cue) {
									t.state = "BADCUE";
									continue
								}
								try {
									jb(e, t.cue, t.regionList)
								} catch {
									t.cue = null, t.state = "BADCUE";
									continue
								}
								t.state = "CUETEXT";
								continue;
							case"CUETEXT": {
								let i = -1 !== e.indexOf("--\x3e");
								if (!e || i && (r = !0)) {
									t.oncue && t.cue && t.oncue(t.cue), t.cue = null, t.state = "ID";
									continue
								}
								if (null === t.cue) continue;
								t.cue.text && (t.cue.text += "\n"), t.cue.text += e
							}
								continue;
							case"BADCUE":
								e || (t.state = "ID")
						}
					}
				} catch {
					"CUETEXT" === t.state && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = "INITIAL" === t.state ? "BADWEBVTT" : "BADCUE"
				}
				return this
			}

			flush() {
				let e = this;
				try {
					if ((e.cue || "HEADER" === e.state) && (e.buffer += "\n\n", e.parse()), "INITIAL" === e.state || "BADWEBVTT" === e.state) throw new Error("Malformed WebVTT signature.")
				} catch (t) {
					e.onparsingerror && e.onparsingerror(t)
				}
				return e.onflush && e.onflush(), this
			}
		}, d = Ep(new Uint8Array(e)).trim().replace(Xb, "\n").split("\n"), u = [], h = t ? function (e, t = 1) {
			return eb(e, JE, 1 / t)
		}(t.baseTime, t.timescale) : 0, c = "00:00.000", m = 0, f = 0, p = !0;
		l.oncue = function (e) {
			let n = i[a], s = i.ccOffset, l = (m - h) / 9e4;
			if (null != n && n.new && (void 0 !== f ? s = i.ccOffset = n.start : function (e, t, i) {
				let a = e[t], r = e[a.prevCC];
				if (!r || !r.new && a.new) return e.ccOffset = e.presentationOffset = a.start, void (a.new = !1);
				for (; null != (n = r) && n.new;) {
					var n;
					e.ccOffset += a.start - r.start, a.new = !1, a = r, r = e[a.prevCC]
				}
				e.presentationOffset = i
			}(i, a, l)), l) {
				if (!t) return void (o = new Error("Missing initPTS for VTT MPEGTS"));
				s = l - i.presentationOffset
			}
			let d = e.endTime - e.startTime, c = nb(9e4 * (e.startTime + s - f), 9e4 * r) / 9e4;
			e.startTime = Math.max(c, 0), e.endTime = Math.max(c + d, 0);
			let p = e.text.trim();
			e.text = decodeURIComponent(encodeURIComponent(p)), e.id || (e.id = Jb(e.startTime, e.endTime, p)), e.endTime > 0 && u.push(e)
		}, l.onparsingerror = function (e) {
			o = e
		}, l.onflush = function () {
			o ? s(o) : n(u)
		}, d.forEach((e => {
			if (p) {
				if (Qb(e, "X-TIMESTAMP-MAP=")) {
					p = !1, e.slice(16).split(",").forEach((e => {
						Qb(e, "LOCAL:") ? c = e.slice(6) : Qb(e, "MPEGTS:") && (m = parseInt(e.slice(7)))
					}));
					try {
						f = function (e) {
							let t = parseInt(e.slice(-3)), i = parseInt(e.slice(-6, -4)), a = parseInt(e.slice(-9, -7)),
								r = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
							if (!(Ef(t) && Ef(i) && Ef(a) && Ef(r))) throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
							return t += 1e3 * i, t += 6e4 * a, t += 36e5 * r, t
						}(c) / 1e3
					} catch (e) {
						o = e
					}
					return
				}
				"" === e && (p = !1)
			}
			l.parse(e + "\n")
		})), l.flush()
	}

	var ty = "stpp.ttml.im1t", iy = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/,
		ay = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/,
		ry = {left: "start", center: "center", right: "end", start: "start", end: "end"};

	function ny(e, t, i, a) {
		let r = Ip(new Uint8Array(e), ["mdat"]);
		if (0 === r.length) return void a(new Error("Could not parse IMSC1 mdat"));
		let n = r.map((e => Ep(e))), s = function (e, t, i = 1, a = !1) {
			return eb(e, t, 1 / i, a)
		}(t.baseTime, 1, t.timescale);
		try {
			n.forEach((e => i(function (e, t) {
				let i = (new DOMParser).parseFromString(e, "text/xml").getElementsByTagName("tt")[0];
				if (!i) throw new Error("Invalid ttml");
				let a = {frameRate: 30, subFrameRate: 1, frameRateMultiplier: 0, tickRate: 0},
					r = Object.keys(a).reduce(((e, t) => (e[t] = i.getAttribute(`ttp:${t}`) || a[t], e)), {}),
					n = "preserve" !== i.getAttribute("xml:space"), s = oy(sy(i, "styling", "style")),
					o = oy(sy(i, "layout", "region")), l = sy(i, "body", "[begin]");
				return [].map.call(l, (e => {
					let i = ly(e, n);
					if (!i || !e.hasAttribute("begin")) return null;
					let a = hy(e.getAttribute("begin"), r), l = hy(e.getAttribute("dur"), r),
						d = hy(e.getAttribute("end"), r);
					if (null === a) throw uy(e);
					if (null === d) {
						if (null === l) throw uy(e);
						d = a + l
					}
					let u = new Gb(a - t, d - t, i);
					u.id = Jb(u.startTime, u.endTime, u.text);
					let h = function (e, t, i) {
						let a = "http://www.w3.org/ns/ttml#styling", r = null,
							n = ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"],
							s = null != e && e.hasAttribute("style") ? e.getAttribute("style") : null;
						return s && i.hasOwnProperty(s) && (r = i[s]), n.reduce(((i, n) => {
							let s = dy(t, a, n) || dy(e, a, n) || dy(r, a, n);
							return s && (i[n] = s), i
						}), {})
					}(o[e.getAttribute("region")], s[e.getAttribute("style")], s), {textAlign: c} = h;
					if (c) {
						let e = ry[c];
						e && (u.lineAlign = e), u.align = c
					}
					return vf(u, h), u
				})).filter((e => null !== e))
			}(e, s))))
		} catch (e) {
			a(e)
		}
	}

	function sy(e, t, i) {
		let a = e.getElementsByTagName(t)[0];
		return a ? [].slice.call(a.querySelectorAll(i)) : []
	}

	function oy(e) {
		return e.reduce(((e, t) => {
			let i = t.getAttribute("xml:id");
			return i && (e[i] = t), e
		}), {})
	}

	function ly(e, t) {
		return [].slice.call(e.childNodes).reduce(((e, i, a) => {
			var r;
			return "br" === i.nodeName && a ? e + "\n" : null != (r = i.childNodes) && r.length ? ly(i, t) : t ? e + i.textContent.trim().replace(/\s+/g, " ") : e + i.textContent
		}), "")
	}

	function dy(e, t, i) {
		return e && e.hasAttributeNS(t, i) ? e.getAttributeNS(t, i) : null
	}

	function uy(e) {
		return new Error(`Could not parse ttml timestamp ${e}`)
	}

	function hy(e, t) {
		if (!e) return null;
		let i = Vb(e);
		return null === i && (iy.test(e) ? i = function (e, t) {
			let i = iy.exec(e), a = (0 | i[4]) + (0 | i[5]) / t.subFrameRate;
			return 3600 * (0 | i[1]) + 60 * (0 | i[2]) + (0 | i[3]) + a / t.frameRate
		}(e, t) : ay.test(e) && (i = function (e, t) {
			let i = ay.exec(e), a = Number(i[1]);
			switch (i[2]) {
				case"h":
					return 3600 * a;
				case"m":
					return 60 * a;
				case"ms":
					return 1e3 * a;
				case"f":
					return a / t.frameRate;
				case"t":
					return a / t.tickRate
			}
			return a
		}(e, t))), i
	}

	function cy(e) {
		return e.characteristics && /transcribes-spoken-dialog/gi.test(e.characteristics) && /describes-music-and-sound/gi.test(e.characteristics) ? "captions" : "subtitles"
	}

	function my(e, t) {
		return !!e && e.kind === cy(t) && yb(t, e)
	}

	function fy(e, t, i, a) {
		return Math.min(t, a) - Math.max(e, i)
	}

	var py = "[eme]", gy = class e {
		constructor(t) {
			this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.setMediaKeysQueue = e.CDMCleanupPromise ? [e.CDMCleanupPromise] : [], this.onMediaEncrypted = this._onMediaEncrypted.bind(this), this.onWaitingForKey = this._onWaitingForKey.bind(this), this.debug = Rf.debug.bind(Rf, py), this.log = Rf.log.bind(Rf, py), this.warn = Rf.warn.bind(Rf, py), this.error = Rf.error.bind(Rf, py), this.hls = t, this.config = t.config, this.registerListeners()
		}

		destroy() {
			this.unregisterListeners(), this.onMediaDetached();
			let e = this.config;
			e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null, this.config = null
		}

		registerListeners() {
			this.hls.on(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(Tf.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(Tf.MANIFEST_LOADED, this.onManifestLoaded, this)
		}

		unregisterListeners() {
			this.hls.off(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(Tf.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(Tf.MANIFEST_LOADED, this.onManifestLoaded, this)
		}

		getLicenseServerUrl(e) {
			let {drmSystems: t, widevineLicenseUrl: i} = this.config, a = t[e];
			if (a) return a.licenseUrl;
			if (e === qf.WIDEVINE && i) return i;
			throw new Error(`no license server URL configured for key-system "${e}"`)
		}

		getServerCertificateUrl(e) {
			let {drmSystems: t} = this.config, i = t[e];
			if (i) return i.serverCertificateUrl;
			this.log(`No Server Certificate in config.drmSystems["${e}"]`)
		}

		attemptKeySystemAccess(e) {
			let t = this.hls.levels, i = (e, t, i) => !!e && i.indexOf(e) === t,
				a = t.map((e => e.audioCodec)).filter(i), r = t.map((e => e.videoCodec)).filter(i);
			return a.length + r.length === 0 && r.push("avc1.42e01e"), new Promise(((t, i) => {
				let n = e => {
					let s = e.shift();
					this.getMediaKeysPromise(s, a, r).then((e => t({keySystem: s, mediaKeys: e}))).catch((t => {
						e.length ? n(e) : i(t instanceof yy ? t : new yy({
							type: Af.KEY_SYSTEM_ERROR,
							details: _f.KEY_SYSTEM_NO_ACCESS,
							error: t,
							fatal: !0
						}, t.message))
					}))
				};
				n(e)
			}))
		}

		requestMediaKeySystemAccess(e, t) {
			let {requestMediaKeySystemAccessFunc: i} = this.config;
			if ("function" != typeof i) {
				let e = `Configured requestMediaKeySystemAccess is not a function ${i}`;
				return null === tp && "http:" === self.location.protocol && (e = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(e))
			}
			return i(e, t)
		}

		getMediaKeysPromise(e, t, i) {
			let a = function (e, t, i, a) {
					let r;
					switch (e) {
						case qf.FAIRPLAY:
							r = ["cenc", "sinf"];
							break;
						case qf.WIDEVINE:
						case qf.PLAYREADY:
							r = ["cenc"];
							break;
						case qf.CLEARKEY:
							r = ["cenc", "keyids"];
							break;
						default:
							throw new Error(`Unknown key-system: ${e}`)
					}
					return function (e, t, i, a) {
						return [{
							initDataTypes: e,
							persistentState: a.persistentState || "optional",
							distinctiveIdentifier: a.distinctiveIdentifier || "optional",
							sessionTypes: a.sessionTypes || [a.sessionType || "temporary"],
							audioCapabilities: t.map((e => ({
								contentType: `audio/mp4; codecs="${e}"`,
								robustness: a.audioRobustness || "",
								encryptionScheme: a.audioEncryptionScheme || null
							}))),
							videoCapabilities: i.map((e => ({
								contentType: `video/mp4; codecs="${e}"`,
								robustness: a.videoRobustness || "",
								encryptionScheme: a.videoEncryptionScheme || null
							})))
						}]
					}(r, t, i, a)
				}(e, t, i, this.config.drmSystemOptions), r = this.keySystemAccessPromises[e],
				n = null == r ? void 0 : r.keySystemAccess;
			if (!n) {
				this.log(`Requesting encrypted media "${e}" key-system access with config: ${JSON.stringify(a)}`), n = this.requestMediaKeySystemAccess(e, a);
				let t = this.keySystemAccessPromises[e] = {keySystemAccess: n};
				return n.catch((t => {
					this.log(`Failed to obtain access to key-system "${e}": ${t}`)
				})), n.then((i => {
					this.log(`Access for key-system "${i.keySystem}" obtained`);
					let a = this.fetchServerCertificate(e);
					return this.log(`Create media-keys for "${e}"`), t.mediaKeys = i.createMediaKeys().then((t => (this.log(`Media-keys created for "${e}"`), a.then((i => i ? this.setMediaKeysServerCertificate(t, e, i) : t))))), t.mediaKeys.catch((t => {
						this.error(`Failed to create media-keys for "${e}"}: ${t}`)
					})), t.mediaKeys
				}))
			}
			return n.then((() => r.mediaKeys))
		}

		createMediaKeySessionContext({decryptdata: e, keySystem: t, mediaKeys: i}) {
			this.log(`Creating key-system session "${t}" keyId: ${bp(e.keyId || [])}`);
			let a = i.createSession(),
				r = {decryptdata: e, keySystem: t, mediaKeys: i, mediaKeysSession: a, keyStatus: "status-pending"};
			return this.mediaKeySessions.push(r), r
		}

		renewKeySession(e) {
			let t = e.decryptdata;
			if (t.pssh) {
				let i = this.createMediaKeySessionContext(e), a = this.getKeyIdString(t), r = "cenc";
				this.keyIdToKeySessionPromise[a] = this.generateRequestWithPreferredKeySession(i, r, t.pssh, "expired")
			} else this.warn("Could not renew expired session. Missing pssh initData.");
			this.removeSession(e)
		}

		getKeyIdString(e) {
			if (!e) throw new Error("Could not read keyId of undefined decryptdata");
			if (null === e.keyId) throw new Error("keyId is null");
			return bp(e.keyId)
		}

		updateKeySession(e, t) {
			var i;
			let a = e.mediaKeysSession;
			return this.log(`Updating key-session "${a.sessionId}" for keyID ${bp((null == (i = e.decryptdata) ? void 0 : i.keyId) || [])}\n      } (data length: ${t && t.byteLength})`), a.update(t)
		}

		selectKeySystemFormat(e) {
			let t = Object.keys(e.levelkeys || {});
			return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(t)), this.keyFormatPromise
		}

		getKeyFormatPromise(e) {
			return new Promise(((t, i) => {
				let a = ep(this.config), r = e.map(Qf).filter((e => !!e && -1 !== a.indexOf(e)));
				return this.getKeySystemSelectionPromise(r).then((({keySystem: e}) => {
					let a = Jf(e);
					a ? t(a) : i(new Error(`Unable to find format for key-system "${e}"`))
				})).catch(i)
			}))
		}

		loadKey(e) {
			let t = e.keyInfo.decryptdata, i = this.getKeyIdString(t),
				a = `(keyId: ${i} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`;
			this.log(`Starting session for key ${a}`);
			let r = this.keyIdToKeySessionPromise[i];
			return r || (r = this.keyIdToKeySessionPromise[i] = this.getKeySystemForKeyPromise(t).then((({
				                                                                                             keySystem: i,
				                                                                                             mediaKeys: r
			                                                                                             }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${a}`), this.attemptSetMediaKeys(i, r).then((() => {
				this.throwIfDestroyed();
				let e = this.createMediaKeySessionContext({keySystem: i, mediaKeys: r, decryptdata: t});
				return this.generateRequestWithPreferredKeySession(e, "cenc", t.pssh, "playlist-key")
			}))))), r.catch((e => this.handleError(e)))), r
		}

		throwIfDestroyed(e = "Invalid state") {
			if (!this.hls) throw new Error("invalid state")
		}

		handleError(e) {
			this.hls && (this.error(e.message), e instanceof yy ? this.hls.trigger(Tf.ERROR, e.data) : this.hls.trigger(Tf.ERROR, {
				type: Af.KEY_SYSTEM_ERROR,
				details: _f.KEY_SYSTEM_NO_KEYS,
				error: e,
				fatal: !0
			}))
		}

		getKeySystemForKeyPromise(e) {
			let t = this.getKeyIdString(e), i = this.keyIdToKeySessionPromise[t];
			if (!i) {
				let t = Qf(e.keyFormat), i = t ? [t] : ep(this.config);
				return this.attemptKeySystemAccess(i)
			}
			return i
		}

		getKeySystemSelectionPromise(e) {
			if (e.length || (e = ep(this.config)), 0 === e.length) throw new yy({
				type: Af.KEY_SYSTEM_ERROR,
				details: _f.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
				fatal: !0
			}, `Missing key-system license configuration options ${JSON.stringify({drmSystems: this.config.drmSystems})}`);
			return this.attemptKeySystemAccess(e)
		}

		_onMediaEncrypted(e) {
			let t, i, {initDataType: a, initData: r} = e;
			if (this.debug(`"${e.type}" event: init data type: "${a}"`), null === r) return;
			if ("sinf" === a && this.config.drmSystems[qf.FAIRPLAY]) {
				let e = _p(new Uint8Array(r));
				try {
					let a = Wf(JSON.parse(e).sinf), r = Np(new Uint8Array(a));
					if (!r) return;
					t = r.subarray(8, 24), i = qf.FAIRPLAY
				} catch {
					return void this.warn('Failed to parse sinf "encrypted" event message initData')
				}
			} else {
				let e = function (e) {
					if (!(e instanceof ArrayBuffer) || e.byteLength < 32) return null;
					let t = {version: 0, systemId: "", kids: null, data: null}, i = new DataView(e), a = i.getUint32(0);
					if (e.byteLength !== a && a > 44 || 1886614376 !== i.getUint32(4) || (t.version = i.getUint32(8) >>> 24, t.version > 1)) return null;
					t.systemId = bp(new Uint8Array(e, 12, 16));
					let r = i.getUint32(28);
					if (0 === t.version) {
						if (a - 32 < r) return null;
						t.data = new Uint8Array(e, 32, r)
					} else if (1 === t.version) {
						t.kids = [];
						for (let i = 0; i < r; i++) t.kids.push(new Uint8Array(e, 32 + 16 * i, 16))
					}
					return t
				}(r);
				if (null === e) return;
				0 === e.version && e.systemId === Zf && e.data && (t = e.data.subarray(8, 24)), i = function (e) {
					if (e === Zf) return qf.WIDEVINE
				}(e.systemId)
			}
			if (!i || !t) return;
			let n = bp(t), {keyIdToKeySessionPromise: s, mediaKeySessions: o} = this, l = s[n];
			for (let e = 0; e < o.length; e++) {
				let i = o[e], d = i.decryptdata;
				if (d.pssh || !d.keyId) continue;
				let u = bp(d.keyId);
				if (n === u || -1 !== d.uri.replace(/-/g, "").indexOf(n)) {
					l = s[u], delete s[u], d.pssh = new Uint8Array(r), d.keyId = t, l = s[n] = l.then((() => this.generateRequestWithPreferredKeySession(i, a, r, "encrypted-event-key-match")));
					break
				}
			}
			l || (l = s[n] = this.getKeySystemSelectionPromise([i]).then((({keySystem: e, mediaKeys: i}) => {
				var s;
				this.throwIfDestroyed();
				let o = new Kp("ISO-23001-7", n, null != (s = Jf(e)) ? s : "");
				return o.pssh = new Uint8Array(r), o.keyId = t, this.attemptSetMediaKeys(e, i).then((() => {
					this.throwIfDestroyed();
					let t = this.createMediaKeySessionContext({decryptdata: o, keySystem: e, mediaKeys: i});
					return this.generateRequestWithPreferredKeySession(t, a, r, "encrypted-event-no-match")
				}))
			}))), l.catch((e => this.handleError(e)))
		}

		_onWaitingForKey(e) {
			this.log(`"${e.type}" event`)
		}

		attemptSetMediaKeys(e, t) {
			let i = this.setMediaKeysQueue.slice();
			this.log(`Setting media-keys for "${e}"`);
			let a = Promise.all(i).then((() => {
				if (!this.media) throw new Error("Attempted to set mediaKeys without media element attached");
				return this.media.setMediaKeys(t)
			}));
			return this.setMediaKeysQueue.push(a), a.then((() => {
				this.log(`Media-keys set for "${e}"`), i.push(a), this.setMediaKeysQueue = this.setMediaKeysQueue.filter((e => -1 === i.indexOf(e)))
			}))
		}

		generateRequestWithPreferredKeySession(e, t, i, a) {
			var r, n;
			let s = null == (r = this.config.drmSystems) || null == (n = r[e.keySystem]) ? void 0 : n.generateRequest;
			if (s) try {
				let a = s.call(this.hls, t, i, e);
				if (!a) throw new Error("Invalid response from configured generateRequest filter");
				t = a.initDataType, i = e.decryptdata.pssh = a.initData ? new Uint8Array(a.initData) : null
			} catch (e) {
				var o;
				if (this.warn(e.message), null != (o = this.hls) && o.config.debug) throw e
			}
			if (null === i) return this.log(`Skipping key-session request for "${a}" (no initData)`), Promise.resolve(e);
			let l = this.getKeyIdString(e.decryptdata);
			this.log(`Generating key-session request for "${a}": ${l} (init data type: ${t} length: ${i ? i.byteLength : null})`);
			let d = new gb, u = e._onmessage = t => {
				let i = e.mediaKeysSession;
				if (!i) return void d.emit("error", new Error("invalid state"));
				let {messageType: a, message: r} = t;
				this.log(`"${a}" message event for session "${i.sessionId}" message size: ${r.byteLength}`), "license-request" === a || "license-renewal" === a ? this.renewLicense(e, r).catch((e => {
					this.handleError(e), d.emit("error", e)
				})) : "license-release" === a ? e.keySystem === qf.FAIRPLAY && (this.updateKeySession(e, Vf("acknowledged")), this.removeSession(e)) : this.warn(`unhandled media key message type "${a}"`)
			}, h = e._onkeystatuseschange = t => {
				if (!e.mediaKeysSession) return void d.emit("error", new Error("invalid state"));
				this.onKeyStatusChange(e);
				let i = e.keyStatus;
				d.emit("keyStatus", i), "expired" === i && (this.warn(`${e.keySystem} expired for key ${l}`), this.renewKeySession(e))
			};
			e.mediaKeysSession.addEventListener("message", u), e.mediaKeysSession.addEventListener("keystatuseschange", h);
			let c = new Promise(((e, t) => {
				d.on("error", t), d.on("keyStatus", (i => {
					i.startsWith("usable") ? e() : "output-restricted" === i ? t(new yy({
						type: Af.KEY_SYSTEM_ERROR,
						details: _f.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
						fatal: !1
					}, "HDCP level output restricted")) : "internal-error" === i ? t(new yy({
						type: Af.KEY_SYSTEM_ERROR,
						details: _f.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
						fatal: !0
					}, `key status changed to "${i}"`)) : "expired" === i ? t(new Error("key expired while generating request")) : this.warn(`unhandled key status change "${i}"`)
				}))
			}));
			return e.mediaKeysSession.generateRequest(t, i).then((() => {
				var t;
				this.log(`Request generated for key-session "${null == (t = e.mediaKeysSession) ? void 0 : t.sessionId}" keyId: ${l}`)
			})).catch((e => {
				throw new yy({
					type: Af.KEY_SYSTEM_ERROR,
					details: _f.KEY_SYSTEM_NO_SESSION,
					error: e,
					fatal: !1
				}, `Error generating key-session request: ${e}`)
			})).then((() => c)).catch((t => {
				throw d.removeAllListeners(), this.removeSession(e), t
			})).then((() => (d.removeAllListeners(), e)))
		}

		onKeyStatusChange(e) {
			e.mediaKeysSession.keyStatuses.forEach(((t, i) => {
				this.log(`key status change "${t}" for keyStatuses keyId: ${bp("buffer" in i ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : new Uint8Array(i))} session keyId: ${bp(new Uint8Array(e.decryptdata.keyId || []))} uri: ${e.decryptdata.uri}`), e.keyStatus = t
			}))
		}

		fetchServerCertificate(e) {
			let t = this.config, i = new (0, t.loader)(t), a = this.getServerCertificateUrl(e);
			return a ? (this.log(`Fetching server certificate for "${e}"`), new Promise(((r, n) => {
				let s = {responseType: "arraybuffer", url: a}, o = t.certLoadPolicy.default,
					l = {loadPolicy: o, timeout: o.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0}, d = {
						onSuccess: (e, t, i, a) => {
							r(e.data)
						}, onError: (t, i, r, o) => {
							n(new yy({
								type: Af.KEY_SYSTEM_ERROR,
								details: _f.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
								fatal: !0,
								networkDetails: r,
								response: ff({url: s.url, data: void 0}, t)
							}, `"${e}" certificate request failed (${a}). Status: ${t.code} (${t.text})`))
						}, onTimeout: (t, i, r) => {
							n(new yy({
								type: Af.KEY_SYSTEM_ERROR,
								details: _f.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
								fatal: !0,
								networkDetails: r,
								response: {url: s.url, data: void 0}
							}, `"${e}" certificate request timed out (${a})`))
						}, onAbort: (e, t, i) => {
							n(new Error("aborted"))
						}
					};
				i.load(s, l, d)
			}))) : Promise.resolve()
		}

		setMediaKeysServerCertificate(e, t, i) {
			return new Promise(((a, r) => {
				e.setServerCertificate(i).then((r => {
					this.log(`setServerCertificate ${r ? "success" : "not supported by CDM"} (${null == i ? void 0 : i.byteLength}) on "${t}"`), a(e)
				})).catch((e => {
					r(new yy({
						type: Af.KEY_SYSTEM_ERROR,
						details: _f.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
						error: e,
						fatal: !0
					}, e.message))
				}))
			}))
		}

		renewLicense(e, t) {
			return this.requestLicense(e, new Uint8Array(t)).then((t => this.updateKeySession(e, new Uint8Array(t)).catch((e => {
				throw new yy({
					type: Af.KEY_SYSTEM_ERROR,
					details: _f.KEY_SYSTEM_SESSION_UPDATE_FAILED,
					error: e,
					fatal: !0
				}, e.message)
			}))))
		}

		unpackPlayReadyKeyMessage(e, t) {
			let i = String.fromCharCode.apply(null, new Uint16Array(t.buffer));
			if (!i.includes("PlayReadyKeyMessage")) return e.setRequestHeader("Content-Type", "text/xml; charset=utf-8"), t;
			let a = (new DOMParser).parseFromString(i, "application/xml"), r = a.querySelectorAll("HttpHeader");
			if (r.length > 0) {
				let t;
				for (let i = 0, a = r.length; i < a; i++) {
					var n, s;
					t = r[i];
					let a = null == (n = t.querySelector("name")) ? void 0 : n.textContent,
						o = null == (s = t.querySelector("value")) ? void 0 : s.textContent;
					a && o && e.setRequestHeader(a, o)
				}
			}
			let o = a.querySelector("Challenge"), l = null == o ? void 0 : o.textContent;
			if (!l) throw new Error("Cannot find <Challenge> in key message");
			return Vf(atob(l))
		}

		setupLicenseXHR(e, t, i, a) {
			let r = this.config.licenseXhrSetup;
			return r ? Promise.resolve().then((() => {
				if (!i.decryptdata) throw new Error("Key removed");
				return r.call(this.hls, e, t, i, a)
			})).catch((n => {
				if (!i.decryptdata) throw n;
				return e.open("POST", t, !0), r.call(this.hls, e, t, i, a)
			})).then((i => (e.readyState || e.open("POST", t, !0), {
				xhr: e,
				licenseChallenge: i || a
			}))) : (e.open("POST", t, !0), Promise.resolve({xhr: e, licenseChallenge: a}))
		}

		requestLicense(e, t) {
			let i = this.config.keyLoadPolicy.default;
			return new Promise(((a, r) => {
				let n = this.getLicenseServerUrl(e.keySystem);
				this.log(`Sending license request to URL: ${n}`);
				let s = new XMLHttpRequest;
				s.responseType = "arraybuffer", s.onreadystatechange = () => {
					if (!this.hls || !e.mediaKeysSession) return r(new Error("invalid state"));
					if (4 === s.readyState) if (200 === s.status) {
						this._requestLicenseFailureCount = 0;
						let t = s.response;
						this.log(`License received ${t instanceof ArrayBuffer ? t.byteLength : t}`);
						let i = this.config.licenseResponseCallback;
						if (i) try {
							t = i.call(this.hls, s, n, e)
						} catch (e) {
							this.error(e)
						}
						a(t)
					} else {
						let o = i.errorRetry, l = o ? o.maxNumRetry : 0;
						if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > l || s.status >= 400 && s.status < 500) r(new yy({
							type: Af.KEY_SYSTEM_ERROR,
							details: _f.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
							fatal: !0,
							networkDetails: s,
							response: {url: n, data: void 0, code: s.status, text: s.statusText}
						}, `License Request XHR failed (${n}). Status: ${s.status} (${s.statusText})`)); else {
							let i = l - this._requestLicenseFailureCount + 1;
							this.warn(`Retrying license request, ${i} attempts left`), this.requestLicense(e, t).then(a, r)
						}
					}
				}, e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(), e.licenseXhr = s, this.setupLicenseXHR(s, n, e, t).then((({
					                                                                                                                                                      xhr: t,
					                                                                                                                                                      licenseChallenge: i
				                                                                                                                                                      }) => {
					e.keySystem == qf.PLAYREADY && (i = this.unpackPlayReadyKeyMessage(t, i)), t.send(i)
				}))
			}))
		}

		onMediaAttached(e, t) {
			if (!this.config.emeEnabled) return;
			let i = t.media;
			this.media = i, i.addEventListener("encrypted", this.onMediaEncrypted), i.addEventListener("waitingforkey", this.onWaitingForKey)
		}

		onMediaDetached() {
			let t = this.media, i = this.mediaKeySessions;
			t && (t.removeEventListener("encrypted", this.onMediaEncrypted), t.removeEventListener("waitingforkey", this.onWaitingForKey), this.media = null), this._requestLicenseFailureCount = 0, this.setMediaKeysQueue = [], this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, Kp.clearKeyUriToKeyIdMap();
			let a = i.length;
			e.CDMCleanupPromise = Promise.all(i.map((e => this.removeSession(e))).concat(null == t ? void 0 : t.setMediaKeys(null).catch((e => {
				this.log(`Could not clear media keys: ${e}`)
			})))).then((() => {
				a && (this.log("finished closing key sessions and clearing media keys"), i.length = 0)
			})).catch((e => {
				this.log(`Could not close sessions and clear media keys: ${e}`)
			}))
		}

		onManifestLoading() {
			this.keyFormatPromise = null
		}

		onManifestLoaded(e, {sessionKeys: t}) {
			if (t && this.config.emeEnabled && !this.keyFormatPromise) {
				let e = t.reduce(((e, t) => (-1 === e.indexOf(t.keyFormat) && e.push(t.keyFormat), e)), []);
				this.log(`Selecting key-system from session-keys ${e.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(e)
			}
		}

		removeSession(e) {
			let {mediaKeysSession: t, licenseXhr: i} = e;
			if (t) {
				this.log(`Remove licenses and keys and close session ${t.sessionId}`), e._onmessage && (t.removeEventListener("message", e._onmessage), e._onmessage = void 0), e._onkeystatuseschange && (t.removeEventListener("keystatuseschange", e._onkeystatuseschange), e._onkeystatuseschange = void 0), i && i.readyState !== XMLHttpRequest.DONE && i.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0;
				let a = this.mediaKeySessions.indexOf(e);
				return a > -1 && this.mediaKeySessions.splice(a, 1), t.remove().catch((e => {
					this.log(`Could not remove session: ${e}`)
				})).then((() => t.close())).catch((e => {
					this.log(`Could not close session: ${e}`)
				}))
			}
		}
	};
	gy.CDMCleanupPromise = void 0;
	var vy, Ey, by, yy = class extends Error {
		constructor(e, t) {
			super(t), this.data = void 0, e.error || (e.error = new Error(t)), this.data = e, e.err = e.error
		}
	};
	!function (e) {
		e.MANIFEST = "m", e.AUDIO = "a", e.VIDEO = "v", e.MUXED = "av", e.INIT = "i", e.CAPTION = "c", e.TIMED_TEXT = "tt", e.KEY = "k", e.OTHER = "o"
	}(vy || (vy = {})), function (e) {
		e.DASH = "d", e.HLS = "h", e.SMOOTH = "s", e.OTHER = "o"
	}(Ey || (Ey = {})), function (e) {
		e.OBJECT = "CMCD-Object", e.REQUEST = "CMCD-Request", e.SESSION = "CMCD-Session", e.STATUS = "CMCD-Status"
	}(by || (by = {}));
	var Ty = {
		[by.OBJECT]: ["br", "d", "ot", "tb"],
		[by.REQUEST]: ["bl", "dl", "mtp", "nor", "nrr", "su"],
		[by.SESSION]: ["cid", "pr", "sf", "sid", "st", "v"],
		[by.STATUS]: ["bs", "rtp"]
	}, Ay = class e {
		constructor(t, i) {
			this.value = void 0, this.params = void 0, Array.isArray(t) && (t = t.map((t => t instanceof e ? t : new e(t)))), this.value = t, this.params = i
		}
	}, _y = class {
		constructor(e) {
			this.description = void 0, this.description = e
		}
	}, ky = "Dict";

	function Sy(e, t, i, a) {
		return new Error(`failed to ${e} "${function (e) {
			return Array.isArray(e) ? JSON.stringify(e) : e instanceof Map ? "Map{}" : e instanceof Set ? "Set{}" : "object" == typeof e ? JSON.stringify(e) : String(e)
		}(t)}" as ${i}`, {cause: a})
	}

	var wy = "Bare Item", Ly = "Boolean", Ry = "Byte Sequence", Iy = "Decimal", Dy = "Integer";
	var Cy = /[\x00-\x1f\x7f]+/, xy = "Token", My = "Key";

	function Oy(e, t, i) {
		return Sy("serialize", e, t, i)
	}

	function Py(e) {
		if (!1 === ArrayBuffer.isView(e)) throw Oy(e, Ry);
		return `:${function (e) {
			return btoa(String.fromCharCode(...e))
		}(e)}:`
	}

	function Ny(e) {
		if (function (e) {
			return e < -999999999999999 || 999999999999999 < e
		}(e)) throw Oy(e, Dy);
		return e.toString()
	}

	function Uy(e, t) {
		if (e < 0) return -Uy(-e, t);
		let i = Math.pow(10, t);
		if (Math.abs(e * i % 1 - .5) < Number.EPSILON) {
			let t = Math.floor(e * i);
			return (t % 2 == 0 ? t : t + 1) / i
		}
		return Math.round(e * i) / i
	}

	function Fy(e) {
		let t = Uy(e, 3);
		if (Math.floor(Math.abs(t)).toString().length > 12) throw Oy(e, Iy);
		let i = t.toString();
		return i.includes(".") ? i : `${i}.0`
	}

	var By = "String";

	function $y(e) {
		let t = function (e) {
			return e.description || e.toString().slice(7, -1)
		}(e);
		if (!1 === /^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(t)) throw Oy(t, xy);
		return t
	}

	function Hy(e) {
		switch (typeof e) {
			case"number":
				if (!Ef(e)) throw Oy(e, wy);
				return Number.isInteger(e) ? Ny(e) : Fy(e);
			case"string":
				return function (e) {
					if (Cy.test(e)) throw Oy(e, By);
					return `"${e.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`
				}(e);
			case"symbol":
				return $y(e);
			case"boolean":
				return function (e) {
					if ("boolean" != typeof e) throw Oy(e, Ly);
					return e ? "?1" : "?0"
				}(e);
			case"object":
				if (e instanceof Date) return function (e) {
					return `@${Ny(e.getTime() / 1e3)}`
				}(e);
				if (e instanceof Uint8Array) return Py(e);
				if (e instanceof _y) return $y(e);
			default:
				throw Oy(e, wy)
		}
	}

	function Wy(e) {
		if (!1 === /^[a-z*][a-z0-9\-_.*]*$/.test(e)) throw Oy(e, My);
		return e
	}

	function Gy(e) {
		return null == e ? "" : Object.entries(e).map((([e, t]) => !0 === t ? `;${Wy(e)}` : `;${Wy(e)}=${Hy(t)}`)).join("")
	}

	function Vy(e) {
		return e instanceof Ay ? `${Hy(e.value)}${Gy(e.params)}` : Hy(e)
	}

	function Ky(e, t = {whitespace: !0}) {
		if ("object" != typeof e) throw Oy(e, ky);
		let i = e instanceof Map ? e.entries() : Object.entries(e), a = null != t && t.whitespace ? " " : "";
		return Array.from(i).map((([e, t]) => {
			t instanceof Ay || (t = new Ay(t));
			let i = Wy(e);
			return !0 === t.value ? i += Gy(t.params) : (i += "=", Array.isArray(t.value) ? i += function (e) {
				return `(${e.value.map(Vy).join(" ")})${Gy(e.params)}`
			}(t) : i += Vy(t)), i
		})).join(`,${a}`)
	}

	var qy = e => "ot" === e || "sf" === e || "st" === e,
		Yy = e => "number" == typeof e ? Ef(e) : null != e && "" !== e && !1 !== e;
	var jy = e => Math.round(e), zy = e => 100 * jy(e / 100), Xy = {
		br: jy, d: jy, bl: zy, dl: zy, mtp: zy, nor: (e, t) => (null != t && t.baseUrl && (e = function (e, t) {
			let i = new URL(e), a = new URL(t);
			if (i.origin !== a.origin) return e;
			let r = i.pathname.split("/").slice(1), n = a.pathname.split("/").slice(1, -1);
			for (; r[0] === n[0];) r.shift(), n.shift();
			for (; n.length;) n.shift(), r.unshift("..");
			return r.join("/")
		}(e, t.baseUrl)), encodeURIComponent(e)), rtp: zy, tb: jy
	};

	function Qy(e, t = {}) {
		return e ? function (e, t) {
			return Ky(e, t)
		}(function (e, t) {
			let i = {};
			if (null == e || "object" != typeof e) return i;
			let a = Object.keys(e).sort(), r = vf({}, Xy, null == t ? void 0 : t.formatters),
				n = null == t ? void 0 : t.filter;
			return a.forEach((a => {
				if (null != n && n(a)) return;
				let s = e[a], o = r[a];
				o && (s = o(s, t)), ("v" !== a || 1 !== s) && ("pr" == a && 1 === s || Yy(s) && (qy(a) && "string" == typeof s && (s = new _y(s)), i[a] = s))
			})), i
		}(e, t), vf({whitespace: !1}, t)) : ""
	}

	function Zy(e, t, i) {
		return vf(e, function (e, t = {}) {
			if (!e) return {};
			let i = Object.entries(e),
				a = Object.entries(Ty).concat(Object.entries((null == t ? void 0 : t.customHeaderMap) || {})),
				r = i.reduce(((e, t) => {
					var i;
					let [r, n] = t, s = (null == (i = a.find((e => e[1].includes(r)))) ? void 0 : i[0]) || by.REQUEST;
					return null != e[s] || (e[s] = {}), e[s][r] = n, e
				}), {});
			return Object.entries(r).reduce(((e, [i, a]) => (e[i] = Qy(a, t), e)), {})
		}(t, i))
	}

	var Jy = "CMCD";
	var eT = /CMCD=[^&#]+/;

	function tT(e, t, i) {
		let a = function (e, t = {}) {
			if (!e) return "";
			let i = Qy(e, t);
			return `${Jy}=${encodeURIComponent(i)}`
		}(t, i);
		if (!a) return e;
		if (eT.test(e)) return e.replace(eT, a);
		let r = e.includes("?") ? "&" : "?";
		return `${e}${r}${a}`
	}

	function iT(e, t, i, a) {
		e && Object.keys(t).forEach((r => {
			let n = e.filter((e => e.groupId === r)).map((e => {
				let n = vf({}, e);
				return n.details = void 0, n.attrs = new Cf(n.attrs), n.url = n.attrs.URI = aT(e.url, e.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", i), n.groupId = n.attrs["GROUP-ID"] = t[r], n.attrs["PATHWAY-ID"] = a, n
			}));
			e.push(...n)
		}))
	}

	function aT(e, t, i, a) {
		let r, {HOST: n, PARAMS: s, [i]: o} = a;
		t && (r = null == o ? void 0 : o[t], r && (e = r));
		let l = new self.URL(e);
		return n && !r && (l.host = n), s && Object.keys(s).sort().forEach((e => {
			e && l.searchParams.set(e, s[e])
		})), l.href
	}

	var rT = /^age:\s*[\d.]+\s*$/im, nT = class {
		constructor(e) {
			this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = null, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new Pf, this.retryDelay = 0
		}

		destroy() {
			this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null, this.context = null, this.xhrSetup = null, this.stats = null
		}

		abortInternal() {
			let e = this.loader;
			self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, 4 !== e.readyState && (this.stats.aborted = !0, e.abort()))
		}

		abort() {
			var e;
			this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
		}

		load(e, t, i) {
			if (this.stats.loading.start) throw new Error("Loader can only be used once.");
			this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = i, this.loadInternal()
		}

		loadInternal() {
			let {config: e, context: t} = this;
			if (!e || !t) return;
			let i = this.loader = new self.XMLHttpRequest, a = this.stats;
			a.loading.first = 0, a.loaded = 0, a.aborted = !1;
			let r = this.xhrSetup;
			r ? Promise.resolve().then((() => {
				if (!this.stats.aborted) return r(i, t.url)
			})).catch((e => (i.open("GET", t.url, !0), r(i, t.url)))).then((() => {
				this.stats.aborted || this.openAndSendXhr(i, t, e)
			})).catch((e => {
				this.callbacks.onError({code: i.status, text: e.message}, t, i, a)
			})) : this.openAndSendXhr(i, t, e)
		}

		openAndSendXhr(e, t, i) {
			e.readyState || e.open("GET", t.url, !0);
			let a = t.headers, {maxTimeToFirstByteMs: r, maxLoadTimeMs: n} = i.loadPolicy;
			if (a) for (let t in a) e.setRequestHeader(t, a[t]);
			t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, self.clearTimeout(this.requestTimeout), i.timeout = r && Ef(r) ? r : n, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), i.timeout), e.send()
		}

		readystatechange() {
			let {context: e, loader: t, stats: i} = this;
			if (!e || !t) return;
			let a = t.readyState, r = this.config;
			if (!i.aborted && a >= 2 && (0 === i.loading.first && (i.loading.first = Math.max(self.performance.now(), i.loading.start), r.timeout !== r.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), r.timeout = r.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), r.loadPolicy.maxLoadTimeMs - (i.loading.first - i.loading.start)))), 4 === a)) {
				self.clearTimeout(this.requestTimeout), t.onreadystatechange = null, t.onprogress = null;
				let a = t.status, n = "text" !== t.responseType;
				if (a >= 200 && a < 300 && (n && t.response || null !== t.responseText)) {
					i.loading.end = Math.max(self.performance.now(), i.loading.first);
					let r = n ? t.response : t.responseText,
						s = "arraybuffer" === t.responseType ? r.byteLength : r.length;
					if (i.loaded = i.total = s, i.bwEstimate = 8e3 * i.total / (i.loading.end - i.loading.first), !this.callbacks) return;
					let o = this.callbacks.onProgress;
					if (o && o(i, e, r, t), !this.callbacks) return;
					let l = {url: t.responseURL, data: r, code: a};
					this.callbacks.onSuccess(l, i, e, t)
				} else {
					let n = r.loadPolicy.errorRetry;
					cv(n, i.retry, !1, {
						url: e.url,
						data: void 0,
						code: a
					}) ? this.retry(n) : (Rf.error(`${a} while loading ${e.url}`), this.callbacks.onError({
						code: a,
						text: t.statusText
					}, e, t, i))
				}
			}
		}

		loadtimeout() {
			var e;
			let t = null == (e = this.config) ? void 0 : e.loadPolicy.timeoutRetry;
			if (cv(t, this.stats.retry, !0)) this.retry(t); else {
				var i;
				Rf.warn(`timeout while loading ${null == (i = this.context) ? void 0 : i.url}`);
				let e = this.callbacks;
				e && (this.abortInternal(), e.onTimeout(this.stats, this.context, this.loader))
			}
		}

		retry(e) {
			let {context: t, stats: i} = this;
			this.retryDelay = uv(e, i.retry), i.retry++, Rf.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${null == t ? void 0 : t.url}, retrying ${i.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay)
		}

		loadprogress(e) {
			let t = this.stats;
			t.loaded = e.loaded, e.lengthComputable && (t.total = e.total)
		}

		getCacheAge() {
			let e = null;
			if (this.loader && rT.test(this.loader.getAllResponseHeaders())) {
				let t = this.loader.getResponseHeader("age");
				e = t ? parseFloat(t) : null
			}
			return e
		}

		getResponseHeader(e) {
			return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null
		}
	};
	var sT = /(\d+)-(\d+)\/(\d+)/, oT = class {
		constructor(e) {
			this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = null, this.response = null, this.controller = void 0, this.context = null, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || lT, this.controller = new self.AbortController, this.stats = new Pf
		}

		destroy() {
			this.loader = this.callbacks = this.context = this.config = this.request = null, this.abortInternal(), this.response = null, this.fetchSetup = this.controller = this.stats = null
		}

		abortInternal() {
			this.controller && !this.stats.loading.end && (this.stats.aborted = !0, this.controller.abort())
		}

		abort() {
			var e;
			this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
		}

		load(e, t, i) {
			let a = this.stats;
			if (a.loading.start) throw new Error("Loader can only be used once.");
			a.loading.start = self.performance.now();
			let r = function (e, t) {
					let i = {
						method: "GET",
						mode: "cors",
						credentials: "same-origin",
						signal: t,
						headers: new self.Headers(vf({}, e.headers))
					};
					return e.rangeEnd && i.headers.set("Range", "bytes=" + e.rangeStart + "-" + String(e.rangeEnd - 1)), i
				}(e, this.controller.signal), n = i.onProgress, s = "arraybuffer" === e.responseType,
				o = s ? "byteLength" : "length", {maxTimeToFirstByteMs: l, maxLoadTimeMs: d} = t.loadPolicy;
			this.context = e, this.config = t, this.callbacks = i, this.request = this.fetchSetup(e, r), self.clearTimeout(this.requestTimeout), t.timeout = l && Ef(l) ? l : d, this.requestTimeout = self.setTimeout((() => {
				this.abortInternal(), i.onTimeout(a, e, this.response)
			}), t.timeout), self.fetch(this.request).then((r => {
				this.response = this.loader = r;
				let o = Math.max(self.performance.now(), a.loading.start);
				if (self.clearTimeout(this.requestTimeout), t.timeout = d, this.requestTimeout = self.setTimeout((() => {
					this.abortInternal(), i.onTimeout(a, e, this.response)
				}), d - (o - a.loading.start)), !r.ok) {
					let {status: e, statusText: t} = r;
					throw new dT(t || "fetch, bad network response", e, r)
				}
				return a.loading.first = o, a.total = function (e) {
					let t = e.get("Content-Range");
					if (t) {
						let e = function (e) {
							let t = sT.exec(e);
							if (t) return parseInt(t[2]) - parseInt(t[1]) + 1
						}(t);
						if (Ef(e)) return e
					}
					let i = e.get("Content-Length");
					if (i) return parseInt(i)
				}(r.headers) || a.total, n && Ef(t.highWaterMark) ? this.loadProgressively(r, a, e, t.highWaterMark, n) : s ? r.arrayBuffer() : "json" === e.responseType ? r.json() : r.text()
			})).then((r => {
				let s = this.response;
				if (!s) throw new Error("loader destroyed");
				self.clearTimeout(this.requestTimeout), a.loading.end = Math.max(self.performance.now(), a.loading.first);
				let l = r[o];
				l && (a.loaded = a.total = l);
				let d = {url: s.url, data: r, code: s.status};
				n && !Ef(t.highWaterMark) && n(a, e, r, s), i.onSuccess(d, a, e, s)
			})).catch((t => {
				if (self.clearTimeout(this.requestTimeout), a.aborted) return;
				let r = t && t.code || 0, n = t ? t.message : null;
				i.onError({code: r, text: n}, e, t ? t.details : null, a)
			}))
		}

		getCacheAge() {
			let e = null;
			if (this.response) {
				let t = this.response.headers.get("age");
				e = t ? parseFloat(t) : null
			}
			return e
		}

		getResponseHeader(e) {
			return this.response ? this.response.headers.get(e) : null
		}

		loadProgressively(e, t, i, a = 0, r) {
			let n = new gE, s = e.body.getReader(), o = () => s.read().then((s => {
				if (s.done) return n.dataLength && r(t, i, n.flush(), e), Promise.resolve(new ArrayBuffer(0));
				let l = s.value, d = l.length;
				return t.loaded += d, d < a || n.dataLength ? (n.push(l), n.dataLength >= a && r(t, i, n.flush(), e)) : r(t, i, l, e), o()
			})).catch((() => Promise.reject()));
			return o()
		}
	};

	function lT(e, t) {
		return new self.Request(e.url, t)
	}

	var dT = class extends Error {
		constructor(e, t, i) {
			super(e), this.code = void 0, this.details = void 0, this.code = t, this.details = i
		}
	}, uT = /\s/, hT = {
		newCue(e, t, i, a) {
			let r, n, s, o, l, d = [], u = self.VTTCue || self.TextTrackCue;
			for (let c = 0; c < a.rows.length; c++) if (r = a.rows[c], s = !0, o = 0, l = "", !r.isEmpty()) {
				var h;
				for (let e = 0; e < r.chars.length; e++) uT.test(r.chars[e].uchar) && s ? o++ : (l += r.chars[e].uchar, s = !1);
				r.cueStartTime = t, t === i && (i += 1e-4), o >= 16 ? o-- : o++;
				let a = zb(l.trim()), m = Jb(t, i, a);
				null != e && null != (h = e.cues) && h.getCueById(m) || (n = new u(t, i, a), n.id = m, n.line = c + 1, n.align = "left", n.position = 10 + Math.min(80, 10 * Math.floor(8 * o / 32)), d.push(n))
			}
			return e && d.length && (d.sort(((e, t) => "auto" === e.line || "auto" === t.line ? 0 : e.line > 8 && t.line > 8 ? t.line - e.line : e.line - t.line)), d.forEach((t => xg(e, t)))), d
		}
	}, cT = ff(ff({
		autoStartLoad: !0,
		startPosition: -1,
		defaultAudioCodec: void 0,
		debug: !1,
		capLevelOnFPSDrop: !1,
		capLevelToPlayerSize: !1,
		ignoreDevicePixelRatio: !1,
		preferManagedMediaSource: !0,
		initialLiveManifestSize: 1,
		maxBufferLength: 30,
		backBufferLength: 1 / 0,
		frontBufferFlushThreshold: 1 / 0,
		maxBufferSize: 6e7,
		maxBufferHole: .1,
		highBufferWatchdogPeriod: 2,
		nudgeOffset: .1,
		nudgeMaxRetry: 3,
		maxFragLookUpTolerance: .25,
		liveSyncDurationCount: 3,
		liveMaxLatencyDurationCount: 1 / 0,
		liveSyncDuration: void 0,
		liveMaxLatencyDuration: void 0,
		maxLiveSyncPlaybackRate: 1,
		liveDurationInfinity: !1,
		liveBackBufferLength: null,
		maxMaxBufferLength: 600,
		enableWorker: !0,
		workerPath: null,
		enableSoftwareAES: !0,
		startLevel: void 0,
		startFragPrefetch: !1,
		fpsDroppedMonitoringPeriod: 5e3,
		fpsDroppedMonitoringThreshold: .2,
		appendErrorMaxRetry: 3,
		loader: nT,
		fLoader: void 0,
		pLoader: void 0,
		xhrSetup: void 0,
		licenseXhrSetup: void 0,
		licenseResponseCallback: void 0,
		abrController: class {
			constructor(e) {
				this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = -1, this.firstSelection = -1, this._nextAutoLevel = -1, this.nextAutoLevelKey = "", this.audioTracksByGroup = null, this.codecTiers = null, this.timer = -1, this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this._abandonRulesCheck = () => {
					let {fragCurrent: e, partCurrent: t, hls: i} = this, {autoLevelEnabled: a, media: r} = i;
					if (!e || !r) return;
					let n = performance.now(), s = t ? t.stats : e.stats, o = t ? t.duration : e.duration,
						l = n - s.loading.start, d = i.minAutoLevel;
					if (s.aborted || s.loaded && s.loaded === s.total || e.level <= d) return this.clearTimer(), void (this._nextAutoLevel = -1);
					if (!a || r.paused || !r.playbackRate || !r.readyState) return;
					let u = i.mainForwardBufferInfo;
					if (null === u) return;
					let h = this.bwEstimator.getEstimateTTFB(), c = Math.abs(r.playbackRate);
					if (l <= Math.max(h, o / (2 * c) * 1e3)) return;
					let m = u.len / c, f = s.loading.first ? s.loading.first - s.loading.start : -1,
						p = s.loaded && f > -1, g = this.getBwEstimate(), v = i.levels, E = v[e.level],
						b = s.total || Math.max(s.loaded, Math.round(o * E.averageBitrate / 8)), y = p ? l - f : l;
					y < 1 && p && (y = Math.min(l, 8 * s.loaded / g));
					let T = p ? 1e3 * s.loaded / y : 0, A = T ? (b - s.loaded) / T : 8 * b / g + h / 1e3;
					if (A <= m) return;
					let _, k = T ? 8 * T : g, S = Number.POSITIVE_INFINITY;
					for (_ = e.level - 1; _ > d; _--) {
						let e = v[_].maxBitrate;
						if (S = this.getTimeToLoadFrag(h / 1e3, k, o * e, !v[_].details), S < m) break
					}
					if (S >= A || S > 10 * o) return;
					i.nextLoadLevel = i.nextAutoLevel = _, p ? this.bwEstimator.sample(l - Math.min(h, f), s.loaded) : this.bwEstimator.sampleTTFB(l);
					let w = v[_].maxBitrate;
					this.getBwEstimate() * this.hls.config.abrBandWidthUpFactor > w && this.resetEstimator(w), this.clearTimer(), Rf.warn(`[abr] Fragment ${e.sn}${t ? " part " + t.index : ""} of level ${e.level} is loading too slowly;\n      Time to underbuffer: ${m.toFixed(3)} s\n      Estimated load time for current fragment: ${A.toFixed(3)} s\n      Estimated load time for down switch fragment: ${S.toFixed(3)} s\n      TTFB estimate: ${0 | f} ms\n      Current BW estimate: ${Ef(g) ? 0 | g : "Unknown"} bps\n      New BW estimate: ${0 | this.getBwEstimate()} bps\n      Switching to level ${_} @ ${0 | w} bps`), i.trigger(Tf.FRAG_LOAD_EMERGENCY_ABORTED, {
						frag: e,
						part: t,
						stats: s
					})
				}, this.hls = e, this.bwEstimator = this.initEstimator(), this.registerListeners()
			}

			get firstAutoLevel() {
				let {maxAutoLevel: e, minAutoLevel: t} = this.hls, i = this.getBwEstimate(),
					a = this.hls.config.maxStarvationDelay, r = this.findBestLevel(i, t, e, 0, a, 1, 1);
				if (r > -1) return r;
				let n = this.hls.firstLevel, s = Math.min(Math.max(n, t), e);
				return Rf.warn(`[abr] Could not find best starting auto level. Defaulting to first in playlist ${n} clamped to ${s}`), s
			}

			get forcedAutoLevel() {
				return this.nextAutoLevelKey ? -1 : this._nextAutoLevel
			}

			get nextAutoLevel() {
				let e = this.forcedAutoLevel, t = this.bwEstimator.canEstimate(), i = this.lastLoadedFragLevel > -1;
				if (!(-1 === e || t && i && this.nextAutoLevelKey !== this.getAutoLevelKey())) return e;
				let a = t && i ? this.getNextABRAutoLevel() : this.firstAutoLevel;
				if (-1 !== e) {
					let t = this.hls.levels;
					if (t.length > Math.max(e, a) && t[e].loadError <= t[a].loadError) return e
				}
				return this._nextAutoLevel = a, this.nextAutoLevelKey = this.getAutoLevelKey(), a
			}

			set nextAutoLevel(e) {
				let {maxAutoLevel: t, minAutoLevel: i} = this.hls, a = Math.min(Math.max(e, i), t);
				this._nextAutoLevel !== a && (this.nextAutoLevelKey = "", this._nextAutoLevel = a)
			}

			resetEstimator(e) {
				e && (Rf.log(`setting initial bwe to ${e}`), this.hls.config.abrEwmaDefaultEstimate = e), this.firstSelection = -1, this.bwEstimator = this.initEstimator()
			}

			initEstimator() {
				let e = this.hls.config;
				return new class {
					constructor(e, t, i, a = 100) {
						this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = i, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new Sv(e), this.fast_ = new Sv(t), this.defaultTTFB_ = a, this.ttfb_ = new Sv(e)
					}

					update(e, t) {
						let {slow_: i, fast_: a, ttfb_: r} = this;
						i.halfLife !== e && (this.slow_ = new Sv(e, i.getEstimate(), i.getTotalWeight())), a.halfLife !== t && (this.fast_ = new Sv(t, a.getEstimate(), a.getTotalWeight())), r.halfLife !== e && (this.ttfb_ = new Sv(e, r.getEstimate(), r.getTotalWeight()))
					}

					sample(e, t) {
						let i = (e = Math.max(e, this.minDelayMs_)) / 1e3, a = 8 * t / i;
						this.fast_.sample(i, a), this.slow_.sample(i, a)
					}

					sampleTTFB(e) {
						let t = e / 1e3, i = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2);
						this.ttfb_.sample(i, Math.max(e, 5))
					}

					canEstimate() {
						return this.fast_.getTotalWeight() >= this.minWeight_
					}

					getEstimate() {
						return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
					}

					getEstimateTTFB() {
						return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_
					}

					destroy() {
					}
				}(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate)
			}

			registerListeners() {
				let {hls: e} = this;
				e.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.on(Tf.FRAG_LOADING, this.onFragLoading, this), e.on(Tf.FRAG_LOADED, this.onFragLoaded, this), e.on(Tf.FRAG_BUFFERED, this.onFragBuffered, this), e.on(Tf.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(Tf.LEVEL_LOADED, this.onLevelLoaded, this), e.on(Tf.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(Tf.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.on(Tf.ERROR, this.onError, this)
			}

			unregisterListeners() {
				let {hls: e} = this;
				e && (e.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.off(Tf.FRAG_LOADING, this.onFragLoading, this), e.off(Tf.FRAG_LOADED, this.onFragLoaded, this), e.off(Tf.FRAG_BUFFERED, this.onFragBuffered, this), e.off(Tf.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(Tf.LEVEL_LOADED, this.onLevelLoaded, this), e.off(Tf.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(Tf.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.off(Tf.ERROR, this.onError, this))
			}

			destroy() {
				this.unregisterListeners(), this.clearTimer(), this.hls = this._abandonRulesCheck = null, this.fragCurrent = this.partCurrent = null
			}

			onManifestLoading(e, t) {
				this.lastLoadedFragLevel = -1, this.firstSelection = -1, this.lastLevelLoadSec = 0, this.fragCurrent = this.partCurrent = null, this.onLevelsUpdated(), this.clearTimer()
			}

			onLevelsUpdated() {
				this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level), this._nextAutoLevel = -1, this.onMaxAutoLevelUpdated(), this.codecTiers = null, this.audioTracksByGroup = null
			}

			onMaxAutoLevelUpdated() {
				this.firstSelection = -1, this.nextAutoLevelKey = ""
			}

			onFragLoading(e, t) {
				let i = t.frag;
				if (!this.ignoreFragment(i)) {
					var a;
					if (!i.bitrateTest) this.fragCurrent = i, this.partCurrent = null != (a = t.part) ? a : null;
					this.clearTimer(), this.timer = self.setInterval(this._abandonRulesCheck, 100)
				}
			}

			onLevelSwitching(e, t) {
				this.clearTimer()
			}

			onError(e, t) {
				if (!t.fatal) switch (t.details) {
					case _f.BUFFER_ADD_CODEC_ERROR:
					case _f.BUFFER_APPEND_ERROR:
						this.lastLoadedFragLevel = -1, this.firstSelection = -1;
						break;
					case _f.FRAG_LOAD_TIMEOUT: {
						let e = t.frag, {fragCurrent: i, partCurrent: a} = this;
						if (e && i && e.sn === i.sn && e.level === i.level) {
							let t = performance.now(), i = a ? a.stats : e.stats, r = t - i.loading.start,
								n = i.loading.first ? i.loading.first - i.loading.start : -1;
							if (i.loaded && n > -1) {
								let e = this.bwEstimator.getEstimateTTFB();
								this.bwEstimator.sample(r - Math.min(e, n), i.loaded)
							} else this.bwEstimator.sampleTTFB(r)
						}
						break
					}
				}
			}

			getTimeToLoadFrag(e, t, i, a) {
				return e + i / t + (a ? this.lastLevelLoadSec : 0)
			}

			onLevelLoaded(e, t) {
				let i = this.hls.config, {loading: a} = t.stats, r = a.end - a.start;
				Ef(r) && (this.lastLevelLoadSec = r / 1e3), t.details.live ? this.bwEstimator.update(i.abrEwmaSlowLive, i.abrEwmaFastLive) : this.bwEstimator.update(i.abrEwmaSlowVoD, i.abrEwmaFastVoD)
			}

			onFragLoaded(e, {frag: t, part: i}) {
				let a = i ? i.stats : t.stats;
				if (t.type === wg && this.bwEstimator.sampleTTFB(a.loading.first - a.loading.start), !this.ignoreFragment(t)) {
					if (this.clearTimer(), t.level === this._nextAutoLevel && (this._nextAutoLevel = -1), this.firstSelection = -1, this.hls.config.abrMaxWithRealBitrate) {
						let e = i ? i.duration : t.duration, r = this.hls.levels[t.level],
							n = (r.loaded ? r.loaded.bytes : 0) + a.loaded, s = (r.loaded ? r.loaded.duration : 0) + e;
						r.loaded = {bytes: n, duration: s}, r.realBitrate = Math.round(8 * n / s)
					}
					if (t.bitrateTest) {
						let e = {stats: a, frag: t, part: i, id: t.type};
						this.onFragBuffered(Tf.FRAG_BUFFERED, e), t.bitrateTest = !1
					} else this.lastLoadedFragLevel = t.level
				}
			}

			onFragBuffered(e, t) {
				let {frag: i, part: a} = t, r = null != a && a.stats.loaded ? a.stats : i.stats;
				if (r.aborted || this.ignoreFragment(i)) return;
				let n = r.parsing.end - r.loading.start - Math.min(r.loading.first - r.loading.start, this.bwEstimator.getEstimateTTFB());
				this.bwEstimator.sample(n, r.loaded), r.bwEstimate = this.getBwEstimate(), i.bitrateTest ? this.bitrateTestDelay = n / 1e3 : this.bitrateTestDelay = 0
			}

			ignoreFragment(e) {
				return e.type !== wg || "initSegment" === e.sn
			}

			clearTimer() {
				this.timer > -1 && (self.clearInterval(this.timer), this.timer = -1)
			}

			getAutoLevelKey() {
				return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`
			}

			getNextABRAutoLevel() {
				let {fragCurrent: e, partCurrent: t, hls: i} = this, {maxAutoLevel: a, config: r, minAutoLevel: n} = i,
					s = t ? t.duration : e ? e.duration : 0, o = this.getBwEstimate(), l = this.getStarvationDelay(),
					d = r.abrBandWidthFactor, u = r.abrBandWidthUpFactor;
				if (l) {
					let e = this.findBestLevel(o, n, a, l, 0, d, u);
					if (e >= 0) return e
				}
				let h = s ? Math.min(s, r.maxStarvationDelay) : r.maxStarvationDelay;
				if (!l) {
					let e = this.bitrateTestDelay;
					e && (h = (s ? Math.min(s, r.maxLoadingDelay) : r.maxLoadingDelay) - e, Rf.info(`[abr] bitrate test took ${Math.round(1e3 * e)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * h)} ms`), d = u = 1)
				}
				let c = this.findBestLevel(o, n, a, l, h, d, u);
				if (Rf.info(`[abr] ${l ? "rebuffering expected" : "buffer is empty"}, optimal quality level ${c}`), c > -1) return c;
				let m = i.levels[n], f = i.levels[i.loadLevel];
				return (null == m ? void 0 : m.bitrate) < (null == f ? void 0 : f.bitrate) ? n : i.loadLevel
			}

			getStarvationDelay() {
				let e = this.hls, t = e.media;
				if (!t) return 1 / 0;
				let i = t && 0 !== t.playbackRate ? Math.abs(t.playbackRate) : 1, a = e.mainForwardBufferInfo;
				return (a ? a.len : 0) / i
			}

			getBwEstimate() {
				return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate
			}

			findBestLevel(e, t, i, a, r, n, s) {
				var o;
				let l = a + r, d = this.lastLoadedFragLevel, u = -1 === d ? this.hls.firstLevel : d, {
					fragCurrent: h,
					partCurrent: c
				} = this, {levels: m, allAudioTracks: f, loadLevel: p, config: g} = this.hls;
				if (1 === m.length) return 0;
				let v, E = m[u], b = !(null == E || null == (o = E.details) || !o.live), y = -1 === p || -1 === d,
					T = "SDR", A = (null == E ? void 0 : E.frameRate) || 0, {
						audioPreference: _,
						videoPreference: k
					} = g, S = this.audioTracksByGroup || (this.audioTracksByGroup = function (e) {
						return e.reduce(((e, t) => {
							let i = e.groups[t.groupId];
							i || (i = e.groups[t.groupId] = {
								tracks: [],
								channels: {2: 0},
								hasDefault: !1,
								hasAutoSelect: !1
							}), i.tracks.push(t);
							let a = t.channels || "2";
							return i.channels[a] = (i.channels[a] || 0) + 1, i.hasDefault = i.hasDefault || t.default, i.hasAutoSelect = i.hasAutoSelect || t.autoselect, i.hasDefault && (e.hasDefaultAudio = !0), i.hasAutoSelect && (e.hasAutoSelectAudio = !0), e
						}), {hasDefaultAudio: !1, hasAutoSelectAudio: !1, groups: {}})
					}(f));
				if (y) {
					if (-1 !== this.firstSelection) return this.firstSelection;
					let a = this.codecTiers || (this.codecTiers = function (e, t, i, a) {
						return e.slice(i, a + 1).reduce(((e, i) => {
							if (!i.codecSet) return e;
							let a = i.audioGroups, r = e[i.codecSet];
							r || (e[i.codecSet] = r = {
								minBitrate: 1 / 0,
								minHeight: 1 / 0,
								minFramerate: 1 / 0,
								maxScore: 0,
								videoRanges: {SDR: 0},
								channels: {2: 0},
								hasDefaultAudio: !a,
								fragmentError: 0
							}), r.minBitrate = Math.min(r.minBitrate, i.bitrate);
							let n = Math.min(i.height, i.width);
							return r.minHeight = Math.min(r.minHeight, n), r.minFramerate = Math.min(r.minFramerate, i.frameRate), r.maxScore = Math.max(r.maxScore, i.score), r.fragmentError += i.fragmentError, r.videoRanges[i.videoRange] = (r.videoRanges[i.videoRange] || 0) + 1, a && a.forEach((e => {
								if (!e) return;
								let i = t.groups[e];
								i && (r.hasDefaultAudio = r.hasDefaultAudio || t.hasDefaultAudio ? i.hasDefault : i.hasAutoSelect || !t.hasDefaultAudio && !t.hasAutoSelectAudio, Object.keys(i.channels).forEach((e => {
									r.channels[e] = (r.channels[e] || 0) + i.channels[e]
								})))
							})), e
						}), {})
					}(m, S, t, i)), r = function (e, t, i, a, r) {
						let n = Object.keys(e), s = null == a ? void 0 : a.channels,
							o = null == a ? void 0 : a.audioCodec, l = s && 2 === parseInt(s), d = !0, u = !1,
							h = 1 / 0, c = 1 / 0, m = 1 / 0, f = 0, p = [], {
								preferHDR: g,
								allowedVideoRanges: v
							} = Dv(t, r);
						for (let t = n.length; t--;) {
							let i = e[n[t]];
							d = i.channels[2] > 0, h = Math.min(h, i.minHeight), c = Math.min(c, i.minFramerate), m = Math.min(m, i.minBitrate);
							let a = v.filter((e => i.videoRanges[e] > 0));
							a.length > 0 && (u = !0, p = a)
						}
						h = Ef(h) ? h : 0, c = Ef(c) ? c : 0;
						let E = Math.max(1080, h), b = Math.max(30, c);
						return m = Ef(m) ? m : i, i = Math.max(m, i), u || (t = void 0, p = []), {
							codecSet: n.reduce(((t, a) => {
								let r = e[a];
								if (a === t) return t;
								if (r.minBitrate > i) return Cv(a, `min bitrate of ${r.minBitrate} > current estimate of ${i}`), t;
								if (!r.hasDefaultAudio) return Cv(a, "no renditions with default or auto-select sound found"), t;
								if (o && a.indexOf(o.substring(0, 4)) % 5 != 0) return Cv(a, `audio codec preference "${o}" not found`), t;
								if (s && !l) {
									if (!r.channels[s]) return Cv(a, `no renditions with ${s} channel sound found (channels options: ${Object.keys(r.channels)})`), t
								} else if ((!o || l) && d && 0 === r.channels[2]) return Cv(a, "no renditions with stereo sound found"), t;
								return r.minHeight > E ? (Cv(a, `min resolution of ${r.minHeight} > maximum of ${E}`), t) : r.minFramerate > b ? (Cv(a, `min framerate of ${r.minFramerate} > maximum of ${b}`), t) : p.some((e => r.videoRanges[e] > 0)) ? r.maxScore < f ? (Cv(a, `max score of ${r.maxScore} < selected max of ${f}`), t) : t && (rg(a) >= rg(t) || r.fragmentError > e[t].fragmentError) ? t : (f = r.maxScore, a) : (Cv(a, `no variants with VIDEO-RANGE of ${JSON.stringify(p)} found`), t)
							}), void 0), videoRanges: p, preferHDR: g, minFramerate: c, minBitrate: m
						}
					}(a, T, e, _, k), {codecSet: n, videoRanges: s, minFramerate: o, minBitrate: l, preferHDR: d} = r;
					v = n, T = d ? s[s.length - 1] : s[0], A = o, e = Math.max(e, l), Rf.log(`[abr] picked start tier ${JSON.stringify(r)}`)
				} else v = null == E ? void 0 : E.codecSet, T = null == E ? void 0 : E.videoRange;
				let w = c ? c.duration : h ? h.duration : 0, L = this.bwEstimator.getEstimateTTFB() / 1e3, R = [];
				for (let o = i; o >= t; o--) {
					var I;
					let t = m[o], h = o > u;
					if (!t) continue;
					if (g.useMediaCapabilities && !t.supportedResult && !t.supportedPromise) {
						let i = navigator.mediaCapabilities;
						"function" == typeof (null == i ? void 0 : i.decodingInfo) && Rv(t, S, T, A, e, _) ? (t.supportedPromise = Iv(t, S, i), t.supportedPromise.then((e => {
							if (!this.hls) return;
							t.supportedResult = e;
							let i = this.hls.levels, a = i.indexOf(t);
							e.error ? Rf.warn(`[abr] MediaCapabilities decodingInfo error: "${e.error}" for level ${a} ${JSON.stringify(e)}`) : e.supported || (Rf.warn(`[abr] Unsupported MediaCapabilities decodingInfo result for level ${a} ${JSON.stringify(e)}`), a > -1 && i.length > 1 && (Rf.log(`[abr] Removing unsupported level ${a}`), this.hls.removeLevel(a)))
						}))) : t.supportedResult = wv
					}
					if (v && t.codecSet !== v || T && t.videoRange !== T || h && A > t.frameRate || !h && A > 0 && A < t.frameRate || t.supportedResult && (null == (I = t.supportedResult.decodingInfoResults) || !I[0].smooth)) {
						R.push(o);
						continue
					}
					let f, k = t.details,
						D = (c ? null == k ? void 0 : k.partTarget : null == k ? void 0 : k.averagetargetduration) || w;
					f = h ? s * e : n * e;
					let C = w && a >= 2 * w && 0 === r ? m[o].averageBitrate : m[o].maxBitrate,
						x = this.getTimeToLoadFrag(L, f, C * D, void 0 === k);
					if (f >= C && (o === d || 0 === t.loadError && 0 === t.fragmentError) && (x <= L || !Ef(x) || b && !this.bitrateTestDelay || x < l)) {
						let e = this.forcedAutoLevel;
						return o !== p && (-1 === e || e !== p) && (R.length && Rf.trace(`[abr] Skipped level(s) ${R.join(",")} of ${i} max with CODECS and VIDEO-RANGE:"${m[R[0]].codecs}" ${m[R[0]].videoRange}; not compatible with "${E.codecs}" ${T}`), Rf.info(`[abr] switch candidate:${u}->${o} adjustedbw(${Math.round(f)})-bitrate=${Math.round(f - C)} ttfb:${L.toFixed(1)} avgDuration:${D.toFixed(1)} maxFetchDuration:${l.toFixed(1)} fetchDuration:${x.toFixed(1)} firstSelection:${y} codecSet:${v} videoRange:${T} hls.loadLevel:${p}`)), y && (this.firstSelection = o), o
					}
				}
				return -1
			}
		},
		bufferController: class {
			constructor(e) {
				this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.appendSource = void 0, this.appendErrors = {
					audio: 0,
					video: 0,
					audiovideo: 0
				}, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this.log = void 0, this.warn = void 0, this.error = void 0, this._onEndStreaming = e => {
					this.hls && this.hls.pauseBuffering()
				}, this._onStartStreaming = e => {
					this.hls && this.hls.resumeBuffering()
				}, this._onMediaSourceOpen = () => {
					let {media: e, mediaSource: t} = this;
					this.log("Media source opened"), e && (e.removeEventListener("emptied", this._onMediaEmptied), this.updateMediaElementDuration(), this.hls.trigger(Tf.MEDIA_ATTACHED, {
						media: e,
						mediaSource: t
					})), t && t.removeEventListener("sourceopen", this._onMediaSourceOpen), this.checkPendingTracks()
				}, this._onMediaSourceClose = () => {
					this.log("Media source closed")
				}, this._onMediaSourceEnded = () => {
					this.log("Media source ended")
				}, this._onMediaEmptied = () => {
					let {mediaSrc: e, _objectUrl: t} = this;
					e !== t && Rf.error(`Media element src was set while attaching MediaSource (${t} > ${e})`)
				}, this.hls = e;
				let t = "[buffer-controller]";
				this.appendSource = function (e) {
					return "undefined" != typeof self && e === self.ManagedMediaSource
				}(Zp(e.config.preferManagedMediaSource)), this.log = Rf.log.bind(Rf, t), this.warn = Rf.warn.bind(Rf, t), this.error = Rf.error.bind(Rf, t), this._initSourceBuffer(), this.registerListeners()
			}

			get mediaSrc() {
				var e;
				let t = (null == (e = this.media) ? void 0 : e.firstChild) || this.media;
				return null == t ? void 0 : t.src
			}

			hasSourceTypes() {
				return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0
			}

			destroy() {
				this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = null, this.hls = null
			}

			registerListeners() {
				let {hls: e} = this;
				e.on(Tf.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.on(Tf.MANIFEST_PARSED, this.onManifestParsed, this), e.on(Tf.BUFFER_RESET, this.onBufferReset, this), e.on(Tf.BUFFER_APPENDING, this.onBufferAppending, this), e.on(Tf.BUFFER_CODECS, this.onBufferCodecs, this), e.on(Tf.BUFFER_EOS, this.onBufferEos, this), e.on(Tf.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(Tf.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(Tf.FRAG_PARSED, this.onFragParsed, this), e.on(Tf.FRAG_CHANGED, this.onFragChanged, this)
			}

			unregisterListeners() {
				let {hls: e} = this;
				e.off(Tf.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.off(Tf.MANIFEST_PARSED, this.onManifestParsed, this), e.off(Tf.BUFFER_RESET, this.onBufferReset, this), e.off(Tf.BUFFER_APPENDING, this.onBufferAppending, this), e.off(Tf.BUFFER_CODECS, this.onBufferCodecs, this), e.off(Tf.BUFFER_EOS, this.onBufferEos, this), e.off(Tf.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(Tf.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(Tf.FRAG_PARSED, this.onFragParsed, this), e.off(Tf.FRAG_CHANGED, this.onFragChanged, this)
			}

			_initSourceBuffer() {
				this.sourceBuffer = {}, this.operationQueue = new class {
					constructor(e) {
						this.buffers = void 0, this.queues = {video: [], audio: [], audiovideo: []}, this.buffers = e
					}

					append(e, t, i) {
						let a = this.queues[t];
						a.push(e), 1 === a.length && !i && this.executeNext(t)
					}

					insertAbort(e, t) {
						this.queues[t].unshift(e), this.executeNext(t)
					}

					appendBlocker(e) {
						let t, i = new Promise((e => {
							t = e
						})), a = {
							execute: t, onStart: () => {
							}, onComplete: () => {
							}, onError: () => {
							}
						};
						return this.append(a, e), i
					}

					executeNext(e) {
						let t = this.queues[e];
						if (t.length) {
							let i = t[0];
							try {
								i.execute()
							} catch (t) {
								Rf.warn(`[buffer-operation-queue]: Exception executing "${e}" SourceBuffer operation: ${t}`), i.onError(t);
								let a = this.buffers[e];
								null != a && a.updating || this.shiftAndExecuteNext(e)
							}
						}
					}

					shiftAndExecuteNext(e) {
						this.queues[e].shift(), this.executeNext(e)
					}

					current(e) {
						return this.queues[e][0]
					}
				}(this.sourceBuffer), this.listeners = {
					audio: [],
					video: [],
					audiovideo: []
				}, this.appendErrors = {audio: 0, video: 0, audiovideo: 0}, this.lastMpegAudioChunk = null
			}

			onManifestLoading() {
				this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0, this.details = null
			}

			onManifestParsed(e, t) {
				let i = 2;
				(t.audio && !t.video || !t.altAudio) && (i = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = i, this.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`)
			}

			onMediaAttaching(e, t) {
				let i = this.media = t.media, a = Zp(this.appendSource);
				if (i && a) {
					var r;
					let e = this.mediaSource = new a;
					this.log(`created media source: ${null == (r = e.constructor) ? void 0 : r.name}`), e.addEventListener("sourceopen", this._onMediaSourceOpen), e.addEventListener("sourceended", this._onMediaSourceEnded), e.addEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (e.addEventListener("startstreaming", this._onStartStreaming), e.addEventListener("endstreaming", this._onEndStreaming));
					let t = this._objectUrl = self.URL.createObjectURL(e);
					if (this.appendSource) try {
						i.removeAttribute("src");
						let a = self.ManagedMediaSource;
						i.disableRemotePlayback = i.disableRemotePlayback || a && e instanceof a, _b(i), function (e, t) {
							let i = self.document.createElement("source");
							i.type = "video/mp4", i.src = t, e.appendChild(i)
						}(i, t), i.load()
					} catch {
						i.src = t
					} else i.src = t;
					i.addEventListener("emptied", this._onMediaEmptied)
				}
			}

			onMediaDetaching() {
				let {media: e, mediaSource: t, _objectUrl: i} = this;
				if (t) {
					if (this.log("media source detaching"), "open" === t.readyState) try {
						t.endOfStream()
					} catch (e) {
						this.warn(`onMediaDetaching: ${e.message} while calling endOfStream`)
					}
					this.onBufferReset(), t.removeEventListener("sourceopen", this._onMediaSourceOpen), t.removeEventListener("sourceended", this._onMediaSourceEnded), t.removeEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (t.removeEventListener("startstreaming", this._onStartStreaming), t.removeEventListener("endstreaming", this._onEndStreaming)), e && (e.removeEventListener("emptied", this._onMediaEmptied), i && self.URL.revokeObjectURL(i), this.mediaSrc === i ? (e.removeAttribute("src"), this.appendSource && _b(e), e.load()) : this.warn("media|source.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {}
				}
				this.hls.trigger(Tf.MEDIA_DETACHED, void 0)
			}

			onBufferReset() {
				this.getSourceBufferTypes().forEach((e => {
					this.resetBuffer(e)
				})), this._initSourceBuffer()
			}

			resetBuffer(e) {
				let t = this.sourceBuffer[e];
				try {
					var i;
					if (t) this.removeBufferListeners(e), this.sourceBuffer[e] = void 0, null != (i = this.mediaSource) && i.sourceBuffers.length && this.mediaSource.removeSourceBuffer(t)
				} catch (t) {
					this.warn(`onBufferReset ${e}`, t)
				}
			}

			onBufferCodecs(e, t) {
				let i = this.getSourceBufferTypes().length, a = Object.keys(t);
				if (a.forEach((e => {
					if (i) {
						let i = this.tracks[e];
						if (i && "function" == typeof i.buffer.changeType) {
							var a;
							let {id: r, codec: n, levelCodec: s, container: o, metadata: l} = t[e],
								d = lg(i.codec, i.levelCodec), u = null == d ? void 0 : d.replace(Ab, "$1"),
								h = lg(n, s), c = null == (a = h) ? void 0 : a.replace(Ab, "$1");
							if (h && u !== c) {
								"audio" === e.slice(0, 5) && (h = og(h, this.appendSource));
								let t = `${o};codecs=${h}`;
								this.appendChangeType(e, t), this.log(`switching codec ${d} to ${h}`), this.tracks[e] = {
									buffer: i.buffer,
									codec: n,
									container: o,
									levelCodec: s,
									metadata: l,
									id: r
								}
							}
						}
					} else this.pendingTracks[e] = t[e]
				})), i) return;
				let r = Math.max(this.bufferCodecEventsExpected - 1, 0);
				this.bufferCodecEventsExpected !== r && (this.log(`${r} bufferCodec event(s) expected ${a.join(",")}`), this.bufferCodecEventsExpected = r), this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks()
			}

			appendChangeType(e, t) {
				let {operationQueue: i} = this, a = {
					execute: () => {
						let a = this.sourceBuffer[e];
						a && (this.log(`changing ${e} sourceBuffer type to ${t}`), a.changeType(t)), i.shiftAndExecuteNext(e)
					}, onStart: () => {
					}, onComplete: () => {
					}, onError: t => {
						this.warn(`Failed to change ${e} SourceBuffer type`, t)
					}
				};
				i.append(a, e, !!this.pendingTracks[e])
			}

			onBufferAppending(e, t) {
				let {hls: i, operationQueue: a, tracks: r} = this, {
					data: n,
					type: s,
					frag: o,
					part: l,
					chunkMeta: d
				} = t, u = d.buffering[s], h = self.performance.now();
				u.start = h;
				let c = o.stats.buffering, m = l ? l.stats.buffering : null;
				0 === c.start && (c.start = h), m && 0 === m.start && (m.start = h);
				let f = r.audio, p = !1;
				"audio" === s && "audio/mpeg" === (null == f ? void 0 : f.container) && (p = !this.lastMpegAudioChunk || 1 === d.id || this.lastMpegAudioChunk.sn !== d.sn, this.lastMpegAudioChunk = d);
				let g = o.start, v = {
					execute: () => {
						if (u.executeStart = self.performance.now(), p) {
							let e = this.sourceBuffer[s];
							if (e) {
								let t = g - e.timestampOffset;
								Math.abs(t) >= .1 && (this.log(`Updating audio SourceBuffer timestampOffset to ${g} (delta: ${t}) sn: ${o.sn})`), e.timestampOffset = g)
							}
						}
						this.appendExecutor(n, s)
					}, onStart: () => {
					}, onComplete: () => {
						let e = self.performance.now();
						u.executeEnd = u.end = e, 0 === c.first && (c.first = e), m && 0 === m.first && (m.first = e);
						let {sourceBuffer: t} = this, i = {};
						for (let e in t) i[e] = Vv.getBuffered(t[e]);
						this.appendErrors[s] = 0, "audio" === s || "video" === s ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0, this.appendErrors.video = 0), this.hls.trigger(Tf.BUFFER_APPENDED, {
							type: s,
							frag: o,
							part: l,
							chunkMeta: d,
							parent: o.type,
							timeRanges: i
						})
					}, onError: e => {
						let t = {
							type: Af.MEDIA_ERROR,
							parent: o.type,
							details: _f.BUFFER_APPEND_ERROR,
							sourceBufferName: s,
							frag: o,
							part: l,
							chunkMeta: d,
							error: e,
							err: e,
							fatal: !1
						};
						if (e.code === DOMException.QUOTA_EXCEEDED_ERR) t.details = _f.BUFFER_FULL_ERROR; else {
							let e = ++this.appendErrors[s];
							t.details = _f.BUFFER_APPEND_ERROR, this.warn(`Failed ${e}/${i.config.appendErrorMaxRetry} times to append segment in "${s}" sourceBuffer`), e >= i.config.appendErrorMaxRetry && (t.fatal = !0)
						}
						i.trigger(Tf.ERROR, t)
					}
				};
				a.append(v, s, !!this.pendingTracks[s])
			}

			onBufferFlushing(e, t) {
				let {operationQueue: i} = this, a = e => ({
					execute: this.removeExecutor.bind(this, e, t.startOffset, t.endOffset), onStart: () => {
					}, onComplete: () => {
						this.hls.trigger(Tf.BUFFER_FLUSHED, {type: e})
					}, onError: t => {
						this.warn(`Failed to remove from ${e} SourceBuffer`, t)
					}
				});
				t.type ? i.append(a(t.type), t.type) : this.getSourceBufferTypes().forEach((e => {
					i.append(a(e), e)
				}))
			}

			onFragParsed(e, t) {
				let {frag: i, part: a} = t, r = [], n = a ? a.elementaryStreams : i.elementaryStreams;
				n[Ff] ? r.push("audiovideo") : (n[Nf] && r.push("audio"), n[Uf] && r.push("video"));
				0 === r.length && this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${i.type} level: ${i.level} sn: ${i.sn}`), this.blockBuffers((() => {
					let e = self.performance.now();
					i.stats.buffering.end = e, a && (a.stats.buffering.end = e);
					let t = a ? a.stats : i.stats;
					this.hls.trigger(Tf.FRAG_BUFFERED, {frag: i, part: a, stats: t, id: i.type})
				}), r)
			}

			onFragChanged(e, t) {
				this.trimBuffers()
			}

			onBufferEos(e, t) {
				this.getSourceBufferTypes().reduce(((e, i) => {
					let a = this.sourceBuffer[i];
					return a && (!t.type || t.type === i) && (a.ending = !0, a.ended || (a.ended = !0, this.log(`${i} sourceBuffer now EOS`))), e && !(a && !a.ended)
				}), !0) && (this.log("Queueing mediaSource.endOfStream()"), this.blockBuffers((() => {
					this.getSourceBufferTypes().forEach((e => {
						let t = this.sourceBuffer[e];
						t && (t.ending = !1)
					}));
					let {mediaSource: e} = this;
					e && "open" === e.readyState ? (this.log("Calling mediaSource.endOfStream()"), e.endOfStream()) : e && this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${e.readyState}`)
				})))
			}

			onLevelUpdated(e, {details: t}) {
				t.fragments.length && (this.details = t, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration())
			}

			trimBuffers() {
				let {hls: e, details: t, media: i} = this;
				if (!i || null === t || !this.getSourceBufferTypes().length) return;
				let a = e.config, r = i.currentTime, n = t.levelTargetDuration,
					s = t.live && null !== a.liveBackBufferLength ? a.liveBackBufferLength : a.backBufferLength;
				if (Ef(s) && s > 0) {
					let e = Math.max(s, n), t = Math.floor(r / n) * n - e;
					this.flushBackBuffer(r, n, t)
				}
				if (Ef(a.frontBufferFlushThreshold) && a.frontBufferFlushThreshold > 0) {
					let e = Math.max(a.maxBufferLength, a.frontBufferFlushThreshold), t = Math.max(e, n),
						i = Math.floor(r / n) * n + t;
					this.flushFrontBuffer(r, n, i)
				}
			}

			flushBackBuffer(e, t, i) {
				let {details: a, sourceBuffer: r} = this;
				this.getSourceBufferTypes().forEach((n => {
					let s = r[n];
					if (s) {
						let r = Vv.getBuffered(s);
						if (r.length > 0 && i > r.start(0)) {
							if (this.hls.trigger(Tf.BACK_BUFFER_REACHED, {bufferEnd: i}), null != a && a.live) this.hls.trigger(Tf.LIVE_BACK_BUFFER_REACHED, {bufferEnd: i}); else if (s.ended && r.end(r.length - 1) - e < 2 * t) return void this.log(`Cannot flush ${n} back buffer while SourceBuffer is in ended state`);
							this.hls.trigger(Tf.BUFFER_FLUSHING, {startOffset: 0, endOffset: i, type: n})
						}
					}
				}))
			}

			flushFrontBuffer(e, t, i) {
				let {sourceBuffer: a} = this;
				this.getSourceBufferTypes().forEach((r => {
					let n = a[r];
					if (n) {
						let a = Vv.getBuffered(n), s = a.length;
						if (s < 2) return;
						let o = a.start(s - 1), l = a.end(s - 1);
						if (i > o || e >= o && e <= l) return;
						if (n.ended && e - l < 2 * t) return void this.log(`Cannot flush ${r} front buffer while SourceBuffer is in ended state`);
						this.hls.trigger(Tf.BUFFER_FLUSHING, {startOffset: o, endOffset: 1 / 0, type: r})
					}
				}))
			}

			updateMediaElementDuration() {
				if (!this.details || !this.media || !this.mediaSource || "open" !== this.mediaSource.readyState) return;
				let {details: e, hls: t, media: i, mediaSource: a} = this, r = e.fragments[0].start + e.totalduration,
					n = i.duration, s = Ef(a.duration) ? a.duration : 0;
				e.live && t.config.liveDurationInfinity ? (a.duration = 1 / 0, this.updateSeekableRange(e)) : (r > s && r > n || !Ef(n)) && (this.log(`Updating Media Source duration to ${r.toFixed(3)}`), a.duration = r)
			}

			updateSeekableRange(e) {
				let t = this.mediaSource, i = e.fragments;
				if (i.length && e.live && null != t && t.setLiveSeekableRange) {
					let a = Math.max(0, i[0].start), r = Math.max(a, a + e.totalduration);
					this.log(`Media Source duration is set to ${t.duration}. Setting seekable range to ${a}-${r}.`), t.setLiveSeekableRange(a, r)
				}
			}

			checkPendingTracks() {
				let {bufferCodecEventsExpected: e, operationQueue: t, pendingTracks: i} = this,
					a = Object.keys(i).length;
				if (a && (!e || 2 === a || "audiovideo" in i)) {
					this.createSourceBuffers(i), this.pendingTracks = {};
					let e = this.getSourceBufferTypes();
					if (e.length) this.hls.trigger(Tf.BUFFER_CREATED, {tracks: this.tracks}), e.forEach((e => {
						t.executeNext(e)
					})); else {
						let e = new Error("could not create source buffer for media codec(s)");
						this.hls.trigger(Tf.ERROR, {
							type: Af.MEDIA_ERROR,
							details: _f.BUFFER_INCOMPATIBLE_CODECS_ERROR,
							fatal: !0,
							error: e,
							reason: e.message
						})
					}
				}
			}

			createSourceBuffers(e) {
				let {sourceBuffer: t, mediaSource: i} = this;
				if (!i) throw Error("createSourceBuffers called when mediaSource was null");
				for (let r in e) if (!t[r]) {
					var a;
					let n = e[r];
					if (!n) throw Error(`source buffer exists for track ${r}, however track does not`);
					let s = -1 === (null == (a = n.levelCodec) ? void 0 : a.indexOf(",")) ? n.levelCodec : n.codec;
					s && "audio" === r.slice(0, 5) && (s = og(s, this.appendSource));
					let o = `${n.container};codecs=${s}`;
					this.log(`creating sourceBuffer(${o})`);
					try {
						let e = t[r] = i.addSourceBuffer(o), a = r;
						this.addBufferListener(a, "updatestart", this._onSBUpdateStart), this.addBufferListener(a, "updateend", this._onSBUpdateEnd), this.addBufferListener(a, "error", this._onSBUpdateError), this.appendSource && this.addBufferListener(a, "bufferedchange", ((e, t) => {
							let i = t.removedRanges;
							null != i && i.length && this.hls.trigger(Tf.BUFFER_FLUSHED, {type: r})
						})), this.tracks[r] = {
							buffer: e,
							codec: s,
							container: n.container,
							levelCodec: n.levelCodec,
							metadata: n.metadata,
							id: n.id
						}
					} catch (e) {
						this.error(`error while trying to add sourceBuffer: ${e.message}`), this.hls.trigger(Tf.ERROR, {
							type: Af.MEDIA_ERROR,
							details: _f.BUFFER_ADD_CODEC_ERROR,
							fatal: !1,
							error: e,
							sourceBufferName: r,
							mimeType: o
						})
					}
				}
			}

			_onSBUpdateStart(e) {
				let {operationQueue: t} = this;
				t.current(e).onStart()
			}

			_onSBUpdateEnd(e) {
				var t;
				if ("closed" === (null == (t = this.mediaSource) ? void 0 : t.readyState)) return void this.resetBuffer(e);
				let {operationQueue: i} = this;
				i.current(e).onComplete(), i.shiftAndExecuteNext(e)
			}

			_onSBUpdateError(e, t) {
				var i;
				let a = new Error(`${e} SourceBuffer error. MediaSource readyState: ${null == (i = this.mediaSource) ? void 0 : i.readyState}`);
				this.error(`${a}`, t), this.hls.trigger(Tf.ERROR, {
					type: Af.MEDIA_ERROR,
					details: _f.BUFFER_APPENDING_ERROR,
					sourceBufferName: e,
					error: a,
					fatal: !1
				});
				let r = this.operationQueue.current(e);
				r && r.onError(a)
			}

			removeExecutor(e, t, i) {
				let {media: a, mediaSource: r, operationQueue: n, sourceBuffer: s} = this, o = s[e];
				if (!a || !r || !o) return this.warn(`Attempting to remove from the ${e} SourceBuffer, but it does not exist`), void n.shiftAndExecuteNext(e);
				let l = Ef(a.duration) ? a.duration : 1 / 0, d = Ef(r.duration) ? r.duration : 1 / 0,
					u = Math.max(0, t), h = Math.min(i, l, d);
				h > u && (!o.ending || o.ended) ? (o.ended = !1, this.log(`Removing [${u},${h}] from the ${e} SourceBuffer`), o.remove(u, h)) : n.shiftAndExecuteNext(e)
			}

			appendExecutor(e, t) {
				let i = this.sourceBuffer[t];
				if (i) i.ended = !1, i.appendBuffer(e); else if (!this.pendingTracks[t]) throw new Error(`Attempting to append to the ${t} SourceBuffer, but it does not exist`)
			}

			blockBuffers(e, t = this.getSourceBufferTypes()) {
				if (!t.length) return this.log("Blocking operation requested, but no SourceBuffers exist"), void Promise.resolve().then(e);
				let {operationQueue: i} = this, a = t.map((e => i.appendBlocker(e)));
				Promise.all(a).then((() => {
					e(), t.forEach((e => {
						let t = this.sourceBuffer[e];
						null != t && t.updating || i.shiftAndExecuteNext(e)
					}))
				}))
			}

			getSourceBufferTypes() {
				return Object.keys(this.sourceBuffer)
			}

			addBufferListener(e, t, i) {
				let a = this.sourceBuffer[e];
				if (!a) return;
				let r = i.bind(this, e);
				this.listeners[e].push({event: t, listener: r}), a.addEventListener(t, r)
			}

			removeBufferListeners(e) {
				let t = this.sourceBuffer[e];
				t && this.listeners[e].forEach((e => {
					t.removeEventListener(e.event, e.listener)
				}))
			}
		},
		capLevelController: class e {
			constructor(e) {
				this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners()
			}

			get mediaWidth() {
				return this.getDimensions().width * this.contentScaleFactor
			}

			get mediaHeight() {
				return this.getDimensions().height * this.contentScaleFactor
			}

			get contentScaleFactor() {
				let e = 1;
				if (!this.hls.config.ignoreDevicePixelRatio) try {
					e = self.devicePixelRatio
				} catch {
				}
				return e
			}

			static getMaxLevelByMediaSize(e, t, i) {
				if (null == e || !e.length) return -1;
				let a = (e, t) => !t || (e.width !== t.width || e.height !== t.height), r = e.length - 1,
					n = Math.max(t, i);
				for (let t = 0; t < e.length; t += 1) {
					let i = e[t];
					if ((i.width >= n || i.height >= n) && a(i, e[t + 1])) {
						r = t;
						break
					}
				}
				return r
			}

			setStreamController(e) {
				this.streamController = e
			}

			destroy() {
				this.hls && this.unregisterListener(), this.timer && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null
			}

			registerListeners() {
				let {hls: e} = this;
				e.on(Tf.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(Tf.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(Tf.MANIFEST_PARSED, this.onManifestParsed, this), e.on(Tf.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(Tf.BUFFER_CODECS, this.onBufferCodecs, this), e.on(Tf.MEDIA_DETACHING, this.onMediaDetaching, this)
			}

			unregisterListener() {
				let {hls: e} = this;
				e.off(Tf.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(Tf.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(Tf.MANIFEST_PARSED, this.onManifestParsed, this), e.off(Tf.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(Tf.BUFFER_CODECS, this.onBufferCodecs, this), e.off(Tf.MEDIA_DETACHING, this.onMediaDetaching, this)
			}

			onFpsDropLevelCapping(e, t) {
				let i = this.hls.levels[t.droppedLevel];
				this.isLevelAllowed(i) && this.restrictedLevels.push({
					bitrate: i.bitrate,
					height: i.height,
					width: i.width
				})
			}

			onMediaAttaching(e, t) {
				this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null, this.timer && this.hls.levels.length && this.detectPlayerSize()
			}

			onManifestParsed(e, t) {
				let i = this.hls;
				this.restrictedLevels = [], this.firstLevel = t.firstLevel, i.config.capLevelToPlayerSize && t.video && this.startCapping()
			}

			onLevelsUpdated(e, t) {
				this.timer && Ef(this.autoLevelCapping) && this.detectPlayerSize()
			}

			onBufferCodecs(e, t) {
				this.hls.config.capLevelToPlayerSize && t.video && this.startCapping()
			}

			onMediaDetaching() {
				this.stopCapping()
			}

			detectPlayerSize() {
				if (this.media) {
					if (this.mediaHeight <= 0 || this.mediaWidth <= 0) return void (this.clientRect = null);
					let e = this.hls.levels;
					if (e.length) {
						let t = this.hls, i = this.getMaxLevel(e.length - 1);
						i !== this.autoLevelCapping && Rf.log(`Setting autoLevelCapping to ${i}: ${e[i].height}p@${e[i].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`), t.autoLevelCapping = i, t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping
					}
				}
			}

			getMaxLevel(t) {
				let i = this.hls.levels;
				if (!i.length) return -1;
				let a = i.filter(((e, i) => this.isLevelAllowed(e) && i <= t));
				return this.clientRect = null, e.getMaxLevelByMediaSize(a, this.mediaWidth, this.mediaHeight)
			}

			startCapping() {
				this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize())
			}

			stopCapping() {
				this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0)
			}

			getDimensions() {
				if (this.clientRect) return this.clientRect;
				let e = this.media, t = {width: 0, height: 0};
				if (e) {
					let i = e.getBoundingClientRect();
					t.width = i.width, t.height = i.height, !t.width && !t.height && (t.width = i.right - i.left || e.width || 0, t.height = i.bottom - i.top || e.height || 0)
				}
				return this.clientRect = t, t
			}

			isLevelAllowed(e) {
				return !this.restrictedLevels.some((t => e.bitrate === t.bitrate && e.width === t.width && e.height === t.height))
			}
		},
		errorController: class {
			constructor(e) {
				this.hls = void 0, this.playlistError = 0, this.penalizedRenditions = {}, this.log = void 0, this.warn = void 0, this.error = void 0, this.hls = e, this.log = Rf.log.bind(Rf, "[info]:"), this.warn = Rf.warn.bind(Rf, "[warning]:"), this.error = Rf.error.bind(Rf, "[error]:"), this.registerListeners()
			}

			registerListeners() {
				let e = this.hls;
				e.on(Tf.ERROR, this.onError, this), e.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.on(Tf.LEVEL_UPDATED, this.onLevelUpdated, this)
			}

			unregisterListeners() {
				let e = this.hls;
				e && (e.off(Tf.ERROR, this.onError, this), e.off(Tf.ERROR, this.onErrorOut, this), e.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.off(Tf.LEVEL_UPDATED, this.onLevelUpdated, this))
			}

			destroy() {
				this.unregisterListeners(), this.hls = null, this.penalizedRenditions = {}
			}

			startLoad(e) {
			}

			stopLoad() {
				this.playlistError = 0
			}

			getVariantLevelIndex(e) {
				return (null == e ? void 0 : e.type) === wg ? e.level : this.hls.loadLevel
			}

			onManifestLoading() {
				this.playlistError = 0, this.penalizedRenditions = {}
			}

			onLevelUpdated() {
				this.playlistError = 0
			}

			onError(e, t) {
				var i, a;
				if (t.fatal) return;
				let r = this.hls, n = t.context;
				switch (t.details) {
					case _f.FRAG_LOAD_ERROR:
					case _f.FRAG_LOAD_TIMEOUT:
					case _f.KEY_LOAD_ERROR:
					case _f.KEY_LOAD_TIMEOUT:
						return void (t.errorAction = this.getFragRetryOrSwitchAction(t));
					case _f.FRAG_PARSING_ERROR:
						if (null != (i = t.frag) && i.gap) return void (t.errorAction = {action: vv, flags: Tv});
					case _f.FRAG_GAP:
					case _f.FRAG_DECRYPT_ERROR:
						return t.errorAction = this.getFragRetryOrSwitchAction(t), void (t.errorAction.action = Ev);
					case _f.LEVEL_EMPTY_ERROR:
					case _f.LEVEL_PARSING_ERROR: {
						var s, o;
						let e = t.parent === wg ? t.level : r.loadLevel;
						t.details === _f.LEVEL_EMPTY_ERROR && null != (s = t.context) && null != (o = s.levelDetails) && o.live ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, e) : (t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, e))
					}
						return;
					case _f.LEVEL_LOAD_ERROR:
					case _f.LEVEL_LOAD_TIMEOUT:
						return void ("number" == typeof (null == n ? void 0 : n.level) && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, n.level)));
					case _f.AUDIO_TRACK_LOAD_ERROR:
					case _f.AUDIO_TRACK_LOAD_TIMEOUT:
					case _f.SUBTITLE_LOAD_ERROR:
					case _f.SUBTITLE_TRACK_LOAD_TIMEOUT:
						if (n) {
							let e = r.levels[r.loadLevel];
							if (e && (n.type === kg && e.hasAudioGroup(n.groupId) || n.type === Sg && e.hasSubtitleGroup(n.groupId))) return t.errorAction = this.getPlaylistRetryOrSwitchAction(t, r.loadLevel), t.errorAction.action = Ev, void (t.errorAction.flags = Av)
						}
						return;
					case _f.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED: {
						let e = r.levels[r.loadLevel], i = null == e ? void 0 : e.attrs["HDCP-LEVEL"];
						i ? t.errorAction = {action: Ev, flags: _v, hdcpLevel: i} : this.keySystemError(t)
					}
						return;
					case _f.BUFFER_ADD_CODEC_ERROR:
					case _f.REMUX_ALLOC_ERROR:
					case _f.BUFFER_APPEND_ERROR:
						return void (t.errorAction = this.getLevelSwitchAction(t, null != (a = t.level) ? a : r.loadLevel));
					case _f.INTERNAL_EXCEPTION:
					case _f.BUFFER_APPENDING_ERROR:
					case _f.BUFFER_FULL_ERROR:
					case _f.LEVEL_SWITCH_ERROR:
					case _f.BUFFER_STALLED_ERROR:
					case _f.BUFFER_SEEK_OVER_HOLE:
					case _f.BUFFER_NUDGE_ON_STALL:
						return void (t.errorAction = {action: vv, flags: Tv})
				}
				t.type === Af.KEY_SYSTEM_ERROR && this.keySystemError(t)
			}

			keySystemError(e) {
				let t = this.getVariantLevelIndex(e.frag);
				e.levelRetry = !1, e.errorAction = this.getLevelSwitchAction(e, t)
			}

			getPlaylistRetryOrSwitchAction(e, t) {
				let i = dv(this.hls.config.playlistLoadPolicy, e), a = this.playlistError++;
				if (cv(i, a, lv(e), e.response)) return {action: yv, flags: Tv, retryConfig: i, retryCount: a};
				let r = this.getLevelSwitchAction(e, t);
				return i && (r.retryConfig = i, r.retryCount = a), r
			}

			getFragRetryOrSwitchAction(e) {
				let t = this.hls, i = this.getVariantLevelIndex(e.frag), a = t.levels[i], {
						fragLoadPolicy: r,
						keyLoadPolicy: n
					} = t.config, s = dv(e.details.startsWith("key") ? n : r, e),
					o = t.levels.reduce(((e, t) => e + t.fragmentError), 0);
				if (a && (e.details !== _f.FRAG_GAP && a.fragmentError++, cv(s, o, lv(e), e.response))) return {
					action: yv,
					flags: Tv,
					retryConfig: s,
					retryCount: o
				};
				let l = this.getLevelSwitchAction(e, i);
				return s && (l.retryConfig = s, l.retryCount = o), l
			}

			getLevelSwitchAction(e, t) {
				let i = this.hls;
				null == t && (t = i.loadLevel);
				let a = this.hls.levels[t];
				if (a) {
					var r, n;
					let t = e.details;
					a.loadError++, t === _f.BUFFER_APPEND_ERROR && a.fragmentError++;
					let l = -1, {levels: d, loadLevel: u, minAutoLevel: h, maxAutoLevel: c} = i;
					i.autoLevelEnabled || (i.loadLevel = -1);
					let m = null == (r = e.frag) ? void 0 : r.type,
						f = (m === Lg && t === _f.FRAG_PARSING_ERROR || "audio" === e.sourceBufferName && (t === _f.BUFFER_ADD_CODEC_ERROR || t === _f.BUFFER_APPEND_ERROR)) && d.some((({audioCodec: e}) => a.audioCodec !== e)),
						p = "video" === e.sourceBufferName && (t === _f.BUFFER_ADD_CODEC_ERROR || t === _f.BUFFER_APPEND_ERROR) && d.some((({
							                                                                                                                    codecSet: e,
							                                                                                                                    audioCodec: t
						                                                                                                                    }) => a.codecSet !== e && a.audioCodec === t)), {
							type: g,
							groupId: v
						} = null != (n = e.context) ? n : {};
					for (let i = d.length; i--;) {
						let r = (i + u) % d.length;
						if (r !== u && r >= h && r <= c && 0 === d[r].loadError) {
							var s, o;
							let i = d[r];
							if (t === _f.FRAG_GAP && e.frag) {
								let t = d[r].details;
								if (t) {
									let i = fv(e.frag, t.fragments, e.frag.start);
									if (null != i && i.gap) continue
								}
							} else {
								if (g === kg && i.hasAudioGroup(v) || g === Sg && i.hasSubtitleGroup(v)) continue;
								if (m === Lg && null != (s = a.audioGroups) && s.some((e => i.hasAudioGroup(e))) || m === Rg && null != (o = a.subtitleGroups) && o.some((e => i.hasSubtitleGroup(e))) || f && a.audioCodec === i.audioCodec || !f && a.audioCodec !== i.audioCodec || p && a.codecSet === i.codecSet) continue
							}
							l = r;
							break
						}
					}
					if (l > -1 && i.loadLevel !== l) return e.levelRetry = !0, this.playlistError = 0, {
						action: Ev,
						flags: Tv,
						nextAutoLevel: l
					}
				}
				return {action: Ev, flags: Av}
			}

			onErrorOut(e, t) {
				var i;
				switch (null == (i = t.errorAction) ? void 0 : i.action) {
					case vv:
						break;
					case Ev:
						this.sendAlternateToPenaltyBox(t), t.errorAction.resolved || t.details === _f.FRAG_GAP ? /MediaSource readyState: ended/.test(t.error.message) && (this.warn(`MediaSource ended after "${t.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`), this.hls.recoverMediaError()) : t.fatal = !0
				}
				t.fatal && this.hls.stopLoad()
			}

			sendAlternateToPenaltyBox(e) {
				let t = this.hls, i = e.errorAction;
				if (!i) return;
				let {flags: a, hdcpLevel: r, nextAutoLevel: n} = i;
				switch (a) {
					case Tv:
						this.switchLevel(e, n);
						break;
					case _v:
						r && (t.maxHdcpLevel = Kg[Kg.indexOf(r) - 1], i.resolved = !0), this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`)
				}
				i.resolved || this.switchLevel(e, n)
			}

			switchLevel(e, t) {
				void 0 !== t && e.errorAction && (this.warn(`switching to level ${t} after ${e.details}`), this.hls.nextAutoLevel = t, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel)
			}
		},
		fpsController: class {
			constructor(e) {
				this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners()
			}

			setStreamController(e) {
				this.streamController = e
			}

			registerListeners() {
				this.hls.on(Tf.MEDIA_ATTACHING, this.onMediaAttaching, this)
			}

			unregisterListeners() {
				this.hls.off(Tf.MEDIA_ATTACHING, this.onMediaAttaching, this)
			}

			destroy() {
				this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null
			}

			onMediaAttaching(e, t) {
				let i = this.hls.config;
				if (i.capLevelOnFPSDrop) {
					let e = t.media instanceof self.HTMLVideoElement ? t.media : null;
					this.media = e, e && "function" == typeof e.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), i.fpsDroppedMonitoringPeriod)
				}
			}

			checkFPS(e, t, i) {
				let a = performance.now();
				if (t) {
					if (this.lastTime) {
						let e = a - this.lastTime, r = i - this.lastDroppedFrames, n = t - this.lastDecodedFrames,
							s = 1e3 * r / e, o = this.hls;
						if (o.trigger(Tf.FPS_DROP, {
							currentDropped: r,
							currentDecoded: n,
							totalDroppedFrames: i
						}), s > 0 && r > o.config.fpsDroppedMonitoringThreshold * n) {
							let e = o.currentLevel;
							Rf.warn("drop FPS ratio greater than max allowed value for currentLevel: " + e), e > 0 && (-1 === o.autoLevelCapping || o.autoLevelCapping >= e) && (e -= 1, o.trigger(Tf.FPS_DROP_LEVEL_CAPPING, {
								level: e,
								droppedLevel: o.currentLevel
							}), o.autoLevelCapping = e, this.streamController.nextLevelSwitch())
						}
					}
					this.lastTime = a, this.lastDroppedFrames = i, this.lastDecodedFrames = t
				}
			}

			checkFPSInterval() {
				let e = this.media;
				if (e) if (this.isVideoPlaybackQualityAvailable) {
					let t = e.getVideoPlaybackQuality();
					this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames)
				} else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount)
			}
		},
		stretchShortVideoTrack: !1,
		maxAudioFramesDrift: 1,
		forceKeyFrameOnDiscontinuity: !0,
		abrEwmaFastLive: 3,
		abrEwmaSlowLive: 9,
		abrEwmaFastVoD: 3,
		abrEwmaSlowVoD: 9,
		abrEwmaDefaultEstimate: 5e5,
		abrEwmaDefaultEstimateMax: 5e6,
		abrBandWidthFactor: .95,
		abrBandWidthUpFactor: .7,
		abrMaxWithRealBitrate: !1,
		maxStarvationDelay: 4,
		maxLoadingDelay: 4,
		minAutoBitrate: 0,
		emeEnabled: !1,
		widevineLicenseUrl: void 0,
		drmSystems: {},
		drmSystemOptions: {},
		requestMediaKeySystemAccessFunc: tp,
		testBandwidth: !0,
		progressive: !1,
		lowLatencyMode: !0,
		cmcd: void 0,
		enableDateRangeMetadataCues: !0,
		enableEmsgMetadataCues: !0,
		enableID3MetadataCues: !0,
		useMediaCapabilities: !0,
		certLoadPolicy: {
			default: {
				maxTimeToFirstByteMs: 8e3,
				maxLoadTimeMs: 2e4,
				timeoutRetry: null,
				errorRetry: null
			}
		},
		keyLoadPolicy: {
			default: {
				maxTimeToFirstByteMs: 8e3,
				maxLoadTimeMs: 2e4,
				timeoutRetry: {maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 2e4, backoff: "linear"},
				errorRetry: {maxNumRetry: 8, retryDelayMs: 1e3, maxRetryDelayMs: 2e4, backoff: "linear"}
			}
		},
		manifestLoadPolicy: {
			default: {
				maxTimeToFirstByteMs: 1 / 0,
				maxLoadTimeMs: 2e4,
				timeoutRetry: {maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0},
				errorRetry: {maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3}
			}
		},
		playlistLoadPolicy: {
			default: {
				maxTimeToFirstByteMs: 1e4,
				maxLoadTimeMs: 2e4,
				timeoutRetry: {maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0},
				errorRetry: {maxNumRetry: 2, retryDelayMs: 1e3, maxRetryDelayMs: 8e3}
			}
		},
		fragLoadPolicy: {
			default: {
				maxTimeToFirstByteMs: 1e4,
				maxLoadTimeMs: 12e4,
				timeoutRetry: {maxNumRetry: 4, retryDelayMs: 0, maxRetryDelayMs: 0},
				errorRetry: {maxNumRetry: 6, retryDelayMs: 1e3, maxRetryDelayMs: 8e3}
			}
		},
		steeringManifestLoadPolicy: {
			default: {
				maxTimeToFirstByteMs: 1e4,
				maxLoadTimeMs: 2e4,
				timeoutRetry: {maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0},
				errorRetry: {maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3}
			}
		},
		manifestLoadingTimeOut: 1e4,
		manifestLoadingMaxRetry: 1,
		manifestLoadingRetryDelay: 1e3,
		manifestLoadingMaxRetryTimeout: 64e3,
		levelLoadingTimeOut: 1e4,
		levelLoadingMaxRetry: 4,
		levelLoadingRetryDelay: 1e3,
		levelLoadingMaxRetryTimeout: 64e3,
		fragLoadingTimeOut: 2e4,
		fragLoadingMaxRetry: 6,
		fragLoadingRetryDelay: 1e3,
		fragLoadingMaxRetryTimeout: 64e3
	}, {
		cueHandler: hT,
		enableWebVTT: !0,
		enableIMSC1: !0,
		enableCEA708Captions: !0,
		captionsTextTrack1Label: "English",
		captionsTextTrack1LanguageCode: "en",
		captionsTextTrack2Label: "Spanish",
		captionsTextTrack2LanguageCode: "es",
		captionsTextTrack3Label: "Unknown CC",
		captionsTextTrack3LanguageCode: "",
		captionsTextTrack4Label: "Unknown CC",
		captionsTextTrack4LanguageCode: "",
		renderTextTracksNatively: !0
	}), {}, {
		subtitleStreamController: class extends pE {
			constructor(e, t, i) {
				super(e, t, i, "[subtitle-stream-controller]", Rg), this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this._registerListeners()
			}

			get mediaBufferTimeRanges() {
				return new Tb(this.tracksBuffered[this.currentTrackId] || [])
			}

			onHandlerDestroying() {
				this._unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null
			}

			_registerListeners() {
				let {hls: e} = this;
				e.on(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.on(Tf.LEVEL_LOADED, this.onLevelLoaded, this), e.on(Tf.ERROR, this.onError, this), e.on(Tf.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(Tf.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(Tf.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(Tf.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(Tf.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(Tf.FRAG_BUFFERED, this.onFragBuffered, this)
			}

			_unregisterListeners() {
				let {hls: e} = this;
				e.off(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.off(Tf.LEVEL_LOADED, this.onLevelLoaded, this), e.off(Tf.ERROR, this.onError, this), e.off(Tf.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(Tf.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(Tf.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(Tf.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(Tf.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(Tf.FRAG_BUFFERED, this.onFragBuffered, this)
			}

			startLoad(e) {
				this.stopLoad(), this.state = rE, this.setInterval(500), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
			}

			onManifestLoading() {
				this.mainDetails = null, this.fragmentTracker.removeAllFragments()
			}

			onMediaDetaching() {
				this.tracksBuffered = [], super.onMediaDetaching()
			}

			onLevelLoaded(e, t) {
				this.mainDetails = t.details
			}

			onSubtitleFragProcessed(e, t) {
				let {frag: i, success: a} = t;
				if (this.fragPrevious = i, this.state = rE, !a) return;
				let r = this.tracksBuffered[this.currentTrackId];
				if (!r) return;
				let n, s = i.start;
				for (let e = 0; e < r.length; e++) if (s >= r[e].start && s <= r[e].end) {
					n = r[e];
					break
				}
				let o = i.start + i.duration;
				n ? n.end = o : (n = {
					start: s,
					end: o
				}, r.push(n)), this.fragmentTracker.fragBuffered(i), this.fragBufferedComplete(i, null)
			}

			onBufferFlushing(e, t) {
				let {startOffset: i, endOffset: a} = t;
				if (0 === i && a !== Number.POSITIVE_INFINITY) {
					let e = a - 1;
					if (e <= 0) return;
					t.endOffsetSubtitles = Math.max(0, e), this.tracksBuffered.forEach((t => {
						for (let i = 0; i < t.length;) if (t[i].end <= e) t.shift(); else {
							if (!(t[i].start < e)) break;
							t[i].start = e, i++
						}
					})), this.fragmentTracker.removeFragmentsInRange(i, e, Rg)
				}
			}

			onFragBuffered(e, t) {
				var i;
				this.loadedmetadata || t.frag.type !== wg || null != (i = this.media) && i.buffered.length && (this.loadedmetadata = !0)
			}

			onError(e, t) {
				let i = t.frag;
				(null == i ? void 0 : i.type) === Rg && (this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== aE && (this.state = rE))
			}

			onSubtitleTracksUpdated(e, {subtitleTracks: t}) {
				this.levels && Eb(this.levels, t) ? this.levels = t.map((e => new Zg(e))) : (this.tracksBuffered = [], this.levels = t.map((e => {
					let t = new Zg(e);
					return this.tracksBuffered[t.id] = [], t
				})), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, Rg), this.fragPrevious = null, this.mediaBuffer = null)
			}

			onSubtitleTrackSwitch(e, t) {
				var i;
				if (this.currentTrackId = t.id, null == (i = this.levels) || !i.length || -1 === this.currentTrackId) return void this.clearInterval();
				let a = this.levels[this.currentTrackId];
				null != a && a.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, a && this.setInterval(500)
			}

			onSubtitleTrackLoaded(e, t) {
				var i;
				let {currentTrackId: a, levels: r} = this, {details: n, id: s} = t;
				if (!r) return void this.warn(`Subtitle tracks were reset while loading level ${s}`);
				let o = r[a];
				if (s >= r.length || s !== a || !o) return;
				this.log(`Subtitle track ${s} loaded [${n.startSN},${n.endSN}]${n.lastPartSn ? `[part-${n.lastPartSn}-${n.lastPartIndex}]` : ""},duration:${n.totalduration}`), this.mediaBuffer = this.mediaBufferTimeRanges;
				let l = 0;
				if (n.live || null != (i = o.details) && i.live) {
					let e = this.mainDetails;
					if (n.deltaUpdateFailed || !e) return;
					let t = e.fragments[0];
					var d;
					if (o.details) l = this.alignPlaylists(n, o.details, null == (d = this.levelLastLoaded) ? void 0 : d.details), 0 === l && t && (l = t.start, rv(n, l)); else n.hasProgramDateTime && e.hasProgramDateTime ? (Xv(n, e), l = n.fragments[0].start) : t && (l = t.start, rv(n, l))
				}
				o.details = n, this.levelLastLoaded = o, !this.startFragRequested && (this.mainDetails || !n.live) && this.setStartPosition(this.mainDetails || n, l), this.tick(), n.live && !this.fragCurrent && this.media && this.state === rE && (fv(null, n.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), o.details = void 0))
			}

			_handleFragmentLoadComplete(e) {
				let {frag: t, payload: i} = e, a = t.decryptdata, r = this.hls;
				if (!this.fragContextChanged(t) && i && i.byteLength > 0 && null != a && a.key && a.iv && "AES-128" === a.method) {
					let e = performance.now();
					this.decrypter.decrypt(new Uint8Array(i), a.key.buffer, a.iv.buffer).catch((e => {
						throw r.trigger(Tf.ERROR, {
							type: Af.MEDIA_ERROR,
							details: _f.FRAG_DECRYPT_ERROR,
							fatal: !1,
							error: e,
							reason: e.message,
							frag: t
						}), e
					})).then((i => {
						let a = performance.now();
						r.trigger(Tf.FRAG_DECRYPTED, {frag: t, payload: i, stats: {tstart: e, tdecrypt: a}})
					})).catch((e => {
						this.warn(`${e.name}: ${e.message}`), this.state = rE
					}))
				}
			}

			doTick() {
				if (this.media) {
					if (this.state === rE) {
						let {currentTrackId: e, levels: t} = this, i = null == t ? void 0 : t[e];
						if (!i || !t.length || !i.details) return;
						let {config: a} = this, r = this.getLoadPosition(),
							n = Vv.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], r, a.maxBufferHole), {
								end: s,
								len: o
							} = n, l = this.getFwdBufferInfo(this.media, wg), d = i.details;
						if (o > this.getMaxBufferLength(null == l ? void 0 : l.len) + d.levelTargetDuration) return;
						let u = d.fragments, h = u.length, c = d.edge, m = null, f = this.fragPrevious;
						if (s < c) {
							let e = a.maxFragLookUpTolerance, t = s > c - e ? 0 : e;
							m = fv(f, u, Math.max(u[0].start, s), t), !m && f && f.start < u[0].start && (m = u[0])
						} else m = u[h - 1];
						if (!m) return;
						if (m = this.mapToInitFragWhenRequired(m), "initSegment" !== m.sn) {
							let e = u[m.sn - d.startSN - 1];
							e && e.cc === m.cc && this.fragmentTracker.getState(e) === Uv && (m = e)
						}
						this.fragmentTracker.getState(m) === Uv && this.loadFragment(m, i, s)
					}
				} else this.state = rE
			}

			getMaxBufferLength(e) {
				let t = super.getMaxBufferLength();
				return e ? Math.max(t, e) : t
			}

			loadFragment(e, t, i) {
				this.fragCurrent = e, "initSegment" === e.sn ? this._loadInitSegment(e, t) : (this.startFragRequested = !0, super.loadFragment(e, t, i))
			}
		}, subtitleTrackController: class extends kv {
			constructor(e) {
				super(e, "[subtitle-track-controller]"), this.media = null, this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.asyncPollTrackChange = () => this.pollTrackChange(0), this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.onTextTracksChanged = () => {
					if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively) return;
					let e = null, t = Pg(this.media.textTracks);
					for (let i = 0; i < t.length; i++) if ("hidden" === t[i].mode) e = t[i]; else if ("showing" === t[i].mode) {
						e = t[i];
						break
					}
					let i = this.findTrackForTextTrack(e);
					this.subtitleTrack !== i && this.setSubtitleTrack(i)
				}, this.registerListeners()
			}

			get subtitleDisplay() {
				return this._subtitleDisplay
			}

			set subtitleDisplay(e) {
				this._subtitleDisplay = e, this.trackId > -1 && this.toggleTrackModes()
			}

			get allSubtitleTracks() {
				return this.tracks
			}

			get subtitleTracks() {
				return this.tracksInGroup
			}

			get subtitleTrack() {
				return this.trackId
			}

			set subtitleTrack(e) {
				this.selectDefaultTrack = !1, this.setSubtitleTrack(e)
			}

			destroy() {
				this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, this.onTextTracksChanged = this.asyncPollTrackChange = null, super.destroy()
			}

			registerListeners() {
				let {hls: e} = this;
				e.on(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.on(Tf.MANIFEST_PARSED, this.onManifestParsed, this), e.on(Tf.LEVEL_LOADING, this.onLevelLoading, this), e.on(Tf.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(Tf.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(Tf.ERROR, this.onError, this)
			}

			unregisterListeners() {
				let {hls: e} = this;
				e.off(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.off(Tf.MANIFEST_PARSED, this.onManifestParsed, this), e.off(Tf.LEVEL_LOADING, this.onLevelLoading, this), e.off(Tf.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(Tf.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(Tf.ERROR, this.onError, this)
			}

			onMediaAttached(e, t) {
				this.media = t.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange))
			}

			pollTrackChange(e) {
				self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, e)
			}

			onMediaDetaching() {
				this.media && (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), Pg(this.media.textTracks).forEach((e => {
					Mg(e)
				})), this.subtitleTrack = -1, this.media = null)
			}

			onManifestLoading() {
				this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0
			}

			onManifestParsed(e, t) {
				this.tracks = t.subtitleTracks
			}

			onSubtitleTrackLoaded(e, t) {
				let {id: i, groupId: a, details: r} = t, n = this.tracksInGroup[i];
				if (!n || n.groupId !== a) return void this.warn(`Subtitle track with id:${i} and group:${a} not found in active group ${null == n ? void 0 : n.groupId}`);
				let s = n.details;
				n.details = t.details, this.log(`Subtitle track ${i} "${n.name}" lang:${n.lang} group:${a} loaded [${r.startSN}-${r.endSN}]`), i === this.trackId && this.playlistLoaded(i, t, s)
			}

			onLevelLoading(e, t) {
				this.switchLevel(t.level)
			}

			onLevelSwitching(e, t) {
				this.switchLevel(t.level)
			}

			switchLevel(e) {
				let t = this.hls.levels[e];
				if (!t) return;
				let i = t.subtitleGroups || null, a = this.groupIds, r = this.currentTrack;
				if (!i || (null == a ? void 0 : a.length) !== (null == i ? void 0 : i.length) || null != i && i.some((e => -1 === (null == a ? void 0 : a.indexOf(e))))) {
					this.groupIds = i, this.trackId = -1, this.currentTrack = null;
					let e = this.tracks.filter((e => !i || -1 !== i.indexOf(e.groupId)));
					if (e.length) this.selectDefaultTrack && !e.some((e => e.default)) && (this.selectDefaultTrack = !1), e.forEach(((e, t) => {
						e.id = t
					})); else if (!r && !this.tracksInGroup.length) return;
					this.tracksInGroup = e;
					let t = this.hls.config.subtitlePreference;
					if (!r && t) {
						this.selectDefaultTrack = !1;
						let i = xv(t, e);
						if (i > -1) r = e[i]; else {
							let e = xv(t, this.tracks);
							r = this.tracks[e]
						}
					}
					let a = this.findTrackId(r);
					-1 === a && r && (a = this.findTrackId(null));
					let n = {subtitleTracks: e};
					this.log(`Updating subtitle tracks, ${e.length} track(s) found in "${null == i ? void 0 : i.join(",")}" group-id`), this.hls.trigger(Tf.SUBTITLE_TRACKS_UPDATED, n), -1 !== a && -1 === this.trackId && this.setSubtitleTrack(a)
				} else this.shouldReloadPlaylist(r) && this.setSubtitleTrack(this.trackId)
			}

			findTrackId(e) {
				let t = this.tracksInGroup, i = this.selectDefaultTrack;
				for (let a = 0; a < t.length; a++) {
					let r = t[a];
					if ((!i || r.default) && (i || e) && (!e || Mv(r, e))) return a
				}
				if (e) {
					for (let i = 0; i < t.length; i++) {
						let a = t[i];
						if (bb(e.attrs, a.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) return i
					}
					for (let i = 0; i < t.length; i++) {
						let a = t[i];
						if (bb(e.attrs, a.attrs, ["LANGUAGE"])) return i
					}
				}
				return -1
			}

			findTrackForTextTrack(e) {
				if (e) {
					let t = this.tracksInGroup;
					for (let i = 0; i < t.length; i++) {
						if (yb(t[i], e)) return i
					}
				}
				return -1
			}

			onError(e, t) {
				t.fatal || !t.context || t.context.type === Sg && t.context.id === this.trackId && (!this.groupIds || -1 !== this.groupIds.indexOf(t.context.groupId)) && this.checkRetry(t)
			}

			setSubtitleOption(e) {
				if (this.hls.config.subtitlePreference = e, e) {
					let t = this.allSubtitleTracks;
					if (this.selectDefaultTrack = !1, t.length) {
						let i = this.currentTrack;
						if (i && Mv(e, i)) return i;
						let a = xv(e, this.tracksInGroup);
						if (a > -1) {
							let e = this.tracksInGroup[a];
							return this.setSubtitleTrack(a), e
						}
						if (i) return null;
						{
							let i = xv(e, t);
							if (i > -1) return t[i]
						}
					}
				}
				return null
			}

			loadPlaylist(e) {
				super.loadPlaylist();
				let t = this.currentTrack;
				if (this.shouldLoadPlaylist(t) && t) {
					let i = t.id, a = t.groupId, r = t.url;
					if (e) try {
						r = e.addDirectives(r)
					} catch (e) {
						this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`)
					}
					this.log(`Loading subtitle playlist for id ${i}`), this.hls.trigger(Tf.SUBTITLE_TRACK_LOADING, {
						url: r,
						id: i,
						groupId: a,
						deliveryDirectives: e || null
					})
				}
			}

			toggleTrackModes() {
				let {media: e} = this;
				if (!e) return;
				let t, i = Pg(e.textTracks), a = this.currentTrack;
				if (a && (t = i.filter((e => yb(a, e)))[0], t || this.warn(`Unable to find subtitle TextTrack with name "${a.name}" and language "${a.lang}"`)), [].slice.call(i).forEach((e => {
					"disabled" !== e.mode && e !== t && (e.mode = "disabled")
				})), t) {
					let e = this.subtitleDisplay ? "showing" : "hidden";
					t.mode !== e && (t.mode = e)
				}
			}

			setSubtitleTrack(e) {
				let t = this.tracksInGroup;
				if (!this.media) return void (this.queuedDefaultTrack = e);
				if (e < -1 || e >= t.length || !Ef(e)) return void this.warn(`Invalid subtitle track id: ${e}`);
				this.clearTimer(), this.selectDefaultTrack = !1;
				let i = this.currentTrack, a = t[e] || null;
				if (this.trackId = e, this.currentTrack = a, this.toggleTrackModes(), !a) return void this.hls.trigger(Tf.SUBTITLE_TRACK_SWITCH, {id: e});
				let r = !!a.details && !a.details.live;
				if (e === this.trackId && a === i && r) return;
				this.log(`Switching to subtitle-track ${e}` + (a ? ` "${a.name}" lang:${a.lang} group:${a.groupId}` : ""));
				let {id: n, groupId: s = "", name: o, type: l, url: d} = a;
				this.hls.trigger(Tf.SUBTITLE_TRACK_SWITCH, {id: n, groupId: s, name: o, type: l, url: d});
				let u = this.switchParams(a.url, null == i ? void 0 : i.details, a.details);
				this.loadPlaylist(u)
			}
		}, timelineController: class {
			constructor(e) {
				this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
					ccOffset: 0,
					presentationOffset: 0,
					0: {start: 0, prevCC: -1, new: !0}
				}, this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = {
					textTrack1: {
						label: this.config.captionsTextTrack1Label,
						languageCode: this.config.captionsTextTrack1LanguageCode
					},
					textTrack2: {
						label: this.config.captionsTextTrack2Label,
						languageCode: this.config.captionsTextTrack2LanguageCode
					},
					textTrack3: {
						label: this.config.captionsTextTrack3Label,
						languageCode: this.config.captionsTextTrack3LanguageCode
					},
					textTrack4: {
						label: this.config.captionsTextTrack4Label,
						languageCode: this.config.captionsTextTrack4LanguageCode
					}
				}, e.on(Tf.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.on(Tf.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(Tf.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(Tf.FRAG_LOADING, this.onFragLoading, this), e.on(Tf.FRAG_LOADED, this.onFragLoaded, this), e.on(Tf.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(Tf.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(Tf.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(Tf.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(Tf.BUFFER_FLUSHING, this.onBufferFlushing, this)
			}

			destroy() {
				let {hls: e} = this;
				e.off(Tf.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.off(Tf.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(Tf.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(Tf.FRAG_LOADING, this.onFragLoading, this), e.off(Tf.FRAG_LOADED, this.onFragLoaded, this), e.off(Tf.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(Tf.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(Tf.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(Tf.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(Tf.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = null, this.cea608Parser1 = this.cea608Parser2 = void 0
			}

			initCea608Parsers() {
				if (this.config.enableCEA708Captions && (!this.cea608Parser1 || !this.cea608Parser2)) {
					let e = new Wb(this, "textTrack1"), t = new Wb(this, "textTrack2"), i = new Wb(this, "textTrack3"),
						a = new Wb(this, "textTrack4");
					this.cea608Parser1 = new Bb(1, e, t), this.cea608Parser2 = new Bb(3, i, a)
				}
			}

			addCues(e, t, i, a, r) {
				let n = !1;
				for (let e = r.length; e--;) {
					let a = r[e], s = fy(a[0], a[1], t, i);
					if (s >= 0 && (a[0] = Math.min(a[0], t), a[1] = Math.max(a[1], i), n = !0, s / (i - t) > .5)) return
				}
				if (n || r.push([t, i]), this.config.renderTextTracksNatively) {
					let r = this.captionsTracks[e];
					this.Cues.newCue(r, t, i, a)
				} else {
					let r = this.Cues.newCue(null, t, i, a);
					this.hls.trigger(Tf.CUES_PARSED, {type: "captions", cues: r, track: e})
				}
			}

			onInitPtsFound(e, {frag: t, id: i, initPTS: a, timescale: r}) {
				let {unparsedVttFrags: n} = this;
				"main" === i && (this.initPTS[t.cc] = {
					baseTime: a,
					timescale: r
				}), n.length && (this.unparsedVttFrags = [], n.forEach((e => {
					this.onFragLoaded(Tf.FRAG_LOADED, e)
				})))
			}

			getExistingTrack(e, t) {
				let {media: i} = this;
				if (i) for (let a = 0; a < i.textTracks.length; a++) {
					let r = i.textTracks[a];
					if (my(r, {name: e, lang: t, attrs: {}})) return r
				}
				return null
			}

			createCaptionsTrack(e) {
				this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e)
			}

			createNativeTrack(e) {
				if (this.captionsTracks[e]) return;
				let {captionsProperties: t, captionsTracks: i, media: a} = this, {label: r, languageCode: n} = t[e],
					s = this.getExistingTrack(r, n);
				if (s) i[e] = s, Mg(i[e]), Cg(i[e], a); else {
					let t = this.createTextTrack("captions", r, n);
					t && (t[e] = !0, i[e] = t)
				}
			}

			createNonNativeTrack(e) {
				if (this.nonNativeCaptionsTracks[e]) return;
				let t = this.captionsProperties[e];
				if (!t) return;
				let i = {
					_id: e,
					label: t.label,
					kind: "captions",
					default: !!t.media && !!t.media.default,
					closedCaptions: t.media
				};
				this.nonNativeCaptionsTracks[e] = i, this.hls.trigger(Tf.NON_NATIVE_TEXT_TRACKS_FOUND, {tracks: [i]})
			}

			createTextTrack(e, t, i) {
				let a = this.media;
				if (a) return a.addTextTrack(e, t, i)
			}

			onMediaAttaching(e, t) {
				this.media = t.media, this._cleanTracks()
			}

			onMediaDetaching() {
				let {captionsTracks: e} = this;
				Object.keys(e).forEach((t => {
					Mg(e[t]), delete e[t]
				})), this.nonNativeCaptionsTracks = {}
			}

			onManifestLoading() {
				this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
					ccOffset: 0,
					presentationOffset: 0,
					0: {start: 0, prevCC: -1, new: !0}
				}, this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset())
			}

			_cleanTracks() {
				let {media: e} = this;
				if (!e) return;
				let t = e.textTracks;
				if (t) for (let e = 0; e < t.length; e++) Mg(t[e])
			}

			onSubtitleTracksUpdated(e, t) {
				let i = t.subtitleTracks || [], a = i.some((e => e.textCodec === ty));
				if (this.config.enableWebVTT || a && this.config.enableIMSC1) {
					if (Eb(this.tracks, i)) return void (this.tracks = i);
					if (this.textTracks = [], this.tracks = i, this.config.renderTextTracksNatively) {
						let e = this.media, t = e ? Pg(e.textTracks) : null;
						if (this.tracks.forEach(((e, i) => {
							let a;
							if (t) {
								let i = null;
								for (let a = 0; a < t.length; a++) if (t[a] && my(t[a], e)) {
									i = t[a], t[a] = null;
									break
								}
								i && (a = i)
							}
							if (a) Mg(a); else {
								let t = cy(e);
								a = this.createTextTrack(t, e.name, e.lang), a && (a.mode = "disabled")
							}
							a && this.textTracks.push(a)
						})), null != t && t.length) {
							let e = t.filter((e => null !== e)).map((e => e.label));
							e.length && Rf.warn(`Media element contains unused subtitle tracks: ${e.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`)
						}
					} else if (this.tracks.length) {
						let e = this.tracks.map((e => ({
							label: e.name,
							kind: e.type.toLowerCase(),
							default: e.default,
							subtitleTrack: e
						})));
						this.hls.trigger(Tf.NON_NATIVE_TEXT_TRACKS_FOUND, {tracks: e})
					}
				}
			}

			onManifestLoaded(e, t) {
				this.config.enableCEA708Captions && t.captions && t.captions.forEach((e => {
					let t = /(?:CC|SERVICE)([1-4])/.exec(e.instreamId);
					if (!t) return;
					let i = `textTrack${t[1]}`, a = this.captionsProperties[i];
					a && (a.label = e.name, e.lang && (a.languageCode = e.lang), a.media = e)
				}))
			}

			closedCaptionsForLevel(e) {
				let t = this.hls.levels[e.level];
				return null == t ? void 0 : t.attrs["CLOSED-CAPTIONS"]
			}

			onFragLoading(e, t) {
				this.initCea608Parsers();
				let {cea608Parser1: i, cea608Parser2: a, lastCc: r, lastSn: n, lastPartIndex: s} = this;
				if (this.enabled && i && a && t.frag.type === wg) {
					var o, l;
					let {cc: e, sn: d} = t.frag,
						u = null != (o = null == t || null == (l = t.part) ? void 0 : l.index) ? o : -1;
					d === n + 1 || d === n && u === s + 1 || e === r || (i.reset(), a.reset()), this.lastCc = e, this.lastSn = d, this.lastPartIndex = u
				}
			}

			onFragLoaded(e, t) {
				let {frag: i, payload: a} = t;
				if (i.type === Rg) if (a.byteLength) {
					let e = i.decryptdata, r = "stats" in t;
					if (null == e || !e.encrypted || r) {
						let e = this.tracks[i.level], r = this.vttCCs;
						r[i.cc] || (r[i.cc] = {
							start: i.start,
							prevCC: this.prevCC,
							new: !0
						}, this.prevCC = i.cc), e && e.textCodec === ty ? this._parseIMSC1(i, a) : this._parseVTTs(t)
					}
				} else this.hls.trigger(Tf.SUBTITLE_FRAG_PROCESSED, {
					success: !1,
					frag: i,
					error: new Error("Empty subtitle payload")
				})
			}

			_parseIMSC1(e, t) {
				let i = this.hls;
				ny(t, this.initPTS[e.cc], (t => {
					this._appendCues(t, e.level), i.trigger(Tf.SUBTITLE_FRAG_PROCESSED, {success: !0, frag: e})
				}), (t => {
					Rf.log(`Failed to parse IMSC1: ${t}`), i.trigger(Tf.SUBTITLE_FRAG_PROCESSED, {
						success: !1,
						frag: e,
						error: t
					})
				}))
			}

			_parseVTTs(e) {
				var t;
				let {frag: i, payload: a} = e, {initPTS: r, unparsedVttFrags: n} = this, s = r.length - 1;
				if (!r[i.cc] && -1 === s) return void n.push(e);
				let o = this.hls;
				ey(null != (t = i.initSegment) && t.data ? Fp(i.initSegment.data, new Uint8Array(a)) : a, this.initPTS[i.cc], this.vttCCs, i.cc, i.start, (e => {
					this._appendCues(e, i.level), o.trigger(Tf.SUBTITLE_FRAG_PROCESSED, {success: !0, frag: i})
				}), (t => {
					let r = "Missing initPTS for VTT MPEGTS" === t.message;
					r ? n.push(e) : this._fallbackToIMSC1(i, a), Rf.log(`Failed to parse VTT cue: ${t}`), !(r && s > i.cc) && o.trigger(Tf.SUBTITLE_FRAG_PROCESSED, {
						success: !1,
						frag: i,
						error: t
					})
				}))
			}

			_fallbackToIMSC1(e, t) {
				let i = this.tracks[e.level];
				i.textCodec || ny(t, this.initPTS[e.cc], (() => {
					i.textCodec = ty, this._parseIMSC1(e, t)
				}), (() => {
					i.textCodec = "wvtt"
				}))
			}

			_appendCues(e, t) {
				let i = this.hls;
				if (this.config.renderTextTracksNatively) {
					let i = this.textTracks[t];
					if (!i || "disabled" === i.mode) return;
					e.forEach((e => xg(i, e)))
				} else {
					let a = this.tracks[t];
					if (!a) return;
					let r = a.default ? "default" : "subtitles" + t;
					i.trigger(Tf.CUES_PARSED, {type: "subtitles", cues: e, track: r})
				}
			}

			onFragDecrypted(e, t) {
				let {frag: i} = t;
				i.type === Rg && this.onFragLoaded(Tf.FRAG_LOADED, t)
			}

			onSubtitleTracksCleared() {
				this.tracks = [], this.captionsTracks = {}
			}

			onFragParsingUserdata(e, t) {
				this.initCea608Parsers();
				let {cea608Parser1: i, cea608Parser2: a} = this;
				if (!this.enabled || !i || !a) return;
				let {frag: r, samples: n} = t;
				if (r.type !== wg || "NONE" !== this.closedCaptionsForLevel(r)) for (let e = 0; e < n.length; e++) {
					let t = n[e].bytes;
					if (t) {
						let r = this.extractCea608Data(t);
						i.addData(n[e].pts, r[0]), a.addData(n[e].pts, r[1])
					}
				}
			}

			onBufferFlushing(e, {startOffset: t, endOffset: i, endOffsetSubtitles: a, type: r}) {
				let {media: n} = this;
				if (n && !(n.currentTime < i)) {
					if (!r || "video" === r) {
						let {captionsTracks: e} = this;
						Object.keys(e).forEach((a => Og(e[a], t, i)))
					}
					if (this.config.renderTextTracksNatively && 0 === t && void 0 !== a) {
						let {textTracks: e} = this;
						Object.keys(e).forEach((i => Og(e[i], t, a)))
					}
				}
			}

			extractCea608Data(e) {
				let t = [[], []], i = 31 & e[0], a = 2;
				for (let r = 0; r < i; r++) {
					let i = e[a++], r = 127 & e[a++], n = 127 & e[a++];
					if ((0 !== r || 0 !== n) && 0 != (4 & i)) {
						let e = 3 & i;
						(0 === e || 1 === e) && (t[e].push(r), t[e].push(n))
					}
				}
				return t
			}
		}, audioStreamController: class extends pE {
			constructor(e, t, i) {
				super(e, t, i, "[audio-stream-controller]", Lg), this.videoBuffer = null, this.videoTrackCC = -1, this.waitingVideoCC = -1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.flushing = !1, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this._registerListeners()
			}

			onHandlerDestroying() {
				this._unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null, this.bufferedTrack = null, this.switchingTrack = null
			}

			_registerListeners() {
				let {hls: e} = this;
				e.on(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.on(Tf.LEVEL_LOADED, this.onLevelLoaded, this), e.on(Tf.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(Tf.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(Tf.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(Tf.ERROR, this.onError, this), e.on(Tf.BUFFER_RESET, this.onBufferReset, this), e.on(Tf.BUFFER_CREATED, this.onBufferCreated, this), e.on(Tf.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(Tf.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(Tf.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(Tf.FRAG_BUFFERED, this.onFragBuffered, this)
			}

			_unregisterListeners() {
				let {hls: e} = this;
				e.off(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.off(Tf.LEVEL_LOADED, this.onLevelLoaded, this), e.off(Tf.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(Tf.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(Tf.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(Tf.ERROR, this.onError, this), e.off(Tf.BUFFER_RESET, this.onBufferReset, this), e.off(Tf.BUFFER_CREATED, this.onBufferCreated, this), e.off(Tf.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(Tf.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(Tf.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(Tf.FRAG_BUFFERED, this.onFragBuffered, this)
			}

			onInitPtsFound(e, {frag: t, id: i, initPTS: a, timescale: r}) {
				if ("main" === i) {
					let e = t.cc;
					this.initPTS[t.cc] = {
						baseTime: a,
						timescale: r
					}, this.log(`InitPTS for cc: ${e} found from main: ${a}`), this.videoTrackCC = e, this.state === mE && this.tick()
				}
			}

			startLoad(e) {
				if (!this.levels) return this.startPosition = e, void (this.state = aE);
				let t = this.lastCurrentTime;
				this.stopLoad(), this.setInterval(100), t > 0 && -1 === e ? (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t, this.state = rE) : (this.loadedmetadata = !1, this.state = lE), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
			}

			doTick() {
				switch (this.state) {
					case rE:
						this.doTickIdle();
						break;
					case lE: {
						var e;
						let {levels: t, trackId: i} = this, a = null == t || null == (e = t[i]) ? void 0 : e.details;
						if (a) {
							if (this.waitForCdnTuneIn(a)) break;
							this.state = mE
						}
						break
					}
					case oE: {
						var t;
						let e = performance.now(), i = this.retryDate;
						if (!i || e >= i || null != (t = this.media) && t.seeking) {
							let {levels: e, trackId: t} = this;
							this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded((null == e ? void 0 : e[t]) || null), this.state = rE
						}
						break
					}
					case mE: {
						let e = this.waitingData;
						if (e) {
							let {frag: t, part: i, cache: a, complete: r} = e;
							if (void 0 !== this.initPTS[t.cc]) {
								this.waitingData = null, this.waitingVideoCC = -1, this.state = sE;
								let e = {frag: t, part: i, payload: a.flush(), networkDetails: null};
								this._handleFragmentLoadProgress(e), r && super._handleFragmentLoadComplete(e)
							} else if (this.videoTrackCC !== this.waitingVideoCC) this.log(`Waiting fragment cc (${t.cc}) cancelled because video is at cc ${this.videoTrackCC}`), this.clearWaitingFragment(); else {
								let e = this.getLoadPosition(),
									i = Vv.bufferInfo(this.mediaBuffer, e, this.config.maxBufferHole);
								pv(i.end, this.config.maxFragLookUpTolerance, t) < 0 && (this.log(`Waiting fragment cc (${t.cc}) @ ${t.start} cancelled because another fragment at ${i.end} is needed`), this.clearWaitingFragment())
							}
						} else this.state = rE
					}
				}
				this.onTickEnd()
			}

			clearWaitingFragment() {
				let e = this.waitingData;
				e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = rE)
			}

			resetLoadingState() {
				this.clearWaitingFragment(), super.resetLoadingState()
			}

			onTickEnd() {
				let {media: e} = this;
				null != e && e.readyState && (this.lastCurrentTime = e.currentTime)
			}

			doTickIdle() {
				let {hls: e, levels: t, media: i, trackId: a} = this, r = e.config;
				if (!i && (this.startFragRequested || !r.startFragPrefetch) || null == t || !t[a]) return;
				let n = t[a], s = n.details;
				if (!s || s.live && this.levelLastLoaded !== n || this.waitForCdnTuneIn(s)) return void (this.state = lE);
				let o = this.mediaBuffer ? this.mediaBuffer : this.media;
				this.bufferFlushed && o && (this.bufferFlushed = !1, this.afterBufferFlushed(o, Nf, Lg));
				let l = this.getFwdBufferInfo(o, Lg);
				if (null === l) return;
				let {bufferedTrack: d, switchingTrack: u} = this;
				if (!u && this._streamEnded(l, s)) return e.trigger(Tf.BUFFER_EOS, {type: "audio"}), void (this.state = hE);
				let h = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, wg), c = l.len,
					m = this.getMaxBufferLength(null == h ? void 0 : h.len), f = s.fragments, p = f[0].start,
					g = this.flushing ? this.getLoadPosition() : l.end;
				if (u && i) {
					let e = this.getLoadPosition();
					d && !bb(u.attrs, d.attrs) && (g = e), s.PTSKnown && e < p && (l.end > p || l.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), i.currentTime = p + .05)
				}
				if (c >= m && !u && g < f[f.length - 1].start) return;
				let v = this.getNextFragment(g, s), E = !1;
				if (v && this.isLoopLoading(v, g) && (E = !!v.gap, v = this.getNextFragmentLoopLoading(v, s, l, wg, m)), !v) return void (this.bufferFlushed = !0);
				let b = h && v.start > h.end + s.targetduration;
				if (b || (null == h || !h.len) && l.len) {
					let e = this.getAppendedFrag(v.start, wg);
					if (null === e || (E || (E = !!e.gap || !!b && 0 === h.len), b && !E || E && l.nextStart && l.nextStart < e.end)) return
				}
				this.loadFragment(v, n, g)
			}

			getMaxBufferLength(e) {
				let t = super.getMaxBufferLength();
				return e ? Math.min(Math.max(t, e), this.config.maxMaxBufferLength) : t
			}

			onMediaDetaching() {
				this.videoBuffer = null, this.bufferFlushed = this.flushing = !1, super.onMediaDetaching()
			}

			onAudioTracksUpdated(e, {audioTracks: t}) {
				this.resetTransmuxer(), this.levels = t.map((e => new Zg(e)))
			}

			onAudioTrackSwitching(e, t) {
				let i = !!t.url;
				this.trackId = t.id;
				let {fragCurrent: a} = this;
				a && (a.abortRequests(), this.removeUnbufferedFrags(a.start)), this.resetLoadingState(), i ? this.setInterval(100) : this.resetTransmuxer(), i ? (this.switchingTrack = t, this.state = rE, this.flushAudioIfNeeded(t)) : (this.switchingTrack = null, this.bufferedTrack = t, this.state = aE), this.tick()
			}

			onManifestLoading() {
				this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = this.flushing = !1, this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null, this.startFragRequested = !1, this.trackId = this.videoTrackCC = this.waitingVideoCC = -1
			}

			onLevelLoaded(e, t) {
				this.mainDetails = t.details, null !== this.cachedTrackLoadedData && (this.hls.trigger(Tf.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData), this.cachedTrackLoadedData = null)
			}

			onAudioTrackLoaded(e, t) {
				var i;
				if (null == this.mainDetails) return void (this.cachedTrackLoadedData = t);
				let {levels: a} = this, {details: r, id: n} = t;
				if (!a) return void this.warn(`Audio tracks were reset while loading level ${n}`);
				this.log(`Audio track ${n} loaded [${r.startSN},${r.endSN}]${r.lastPartSn ? `[part-${r.lastPartSn}-${r.lastPartIndex}]` : ""},duration:${r.totalduration}`);
				let s = a[n], o = 0;
				if (r.live || null != (i = s.details) && i.live) {
					this.checkLiveUpdate(r);
					let e = this.mainDetails;
					if (r.deltaUpdateFailed || !e) return;
					var l;
					if (!s.details && r.hasProgramDateTime && e.hasProgramDateTime) Xv(r, e), o = r.fragments[0].start; else o = this.alignPlaylists(r, s.details, null == (l = this.levelLastLoaded) ? void 0 : l.details)
				}
				s.details = r, this.levelLastLoaded = s, !this.startFragRequested && (this.mainDetails || !r.live) && this.setStartPosition(this.mainDetails || r, o), this.state === lE && !this.waitForCdnTuneIn(r) && (this.state = rE), this.tick()
			}

			_handleFragmentLoadProgress(e) {
				var t;
				let {frag: i, part: a, payload: r} = e, {config: n, trackId: s, levels: o} = this;
				if (!o) return void this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`);
				let l = o[s];
				if (!l) return void this.warn("Audio track is undefined on fragment load progress");
				let d = l.details;
				if (!d) return this.warn("Audio track details undefined on fragment load progress"), void this.removeUnbufferedFrags(i.start);
				let u = n.defaultAudioCodec || l.audioCodec || "mp4a.40.2", h = this.transmuxer;
				h || (h = this.transmuxer = new vb(this.hls, Lg, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
				let c = this.initPTS[i.cc], m = null == (t = i.initSegment) ? void 0 : t.data;
				if (void 0 !== c) {
					let e = a ? a.index : -1, t = -1 !== e,
						n = new Kv(i.level, i.sn, i.stats.chunkCount, r.byteLength, e, t);
					h.push(r, m, u, "", i, a, d.totalduration, !1, n, c)
				} else {
					this.log(`Unknown video PTS for cc ${i.cc}, waiting for video PTS before demuxing audio frag ${i.sn} of [${d.startSN} ,${d.endSN}],track ${s}`);
					let {cache: e} = this.waitingData = this.waitingData || {
						frag: i,
						part: a,
						cache: new gE,
						complete: !1
					};
					e.push(new Uint8Array(r)), this.waitingVideoCC = this.videoTrackCC, this.state = mE
				}
			}

			_handleFragmentLoadComplete(e) {
				this.waitingData ? this.waitingData.complete = !0 : super._handleFragmentLoadComplete(e)
			}

			onBufferReset() {
				this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1
			}

			onBufferCreated(e, t) {
				let i = t.tracks.audio;
				i && (this.mediaBuffer = i.buffer || null), t.tracks.video && (this.videoBuffer = t.tracks.video.buffer || null)
			}

			onFragBuffered(e, t) {
				let {frag: i, part: a} = t;
				if (i.type === Lg) if (this.fragContextChanged(i)) this.warn(`Fragment ${i.sn}${a ? " p: " + a.index : ""} of level ${i.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`); else {
					if ("initSegment" !== i.sn) {
						this.fragPrevious = i;
						let e = this.switchingTrack;
						e && (this.bufferedTrack = e, this.switchingTrack = null, this.hls.trigger(Tf.AUDIO_TRACK_SWITCHED, ff({}, e)))
					}
					this.fragBufferedComplete(i, a)
				} else if (!this.loadedmetadata && i.type === wg) {
					let e = this.videoBuffer || this.media;
					e && Vv.getBuffered(e).length && (this.loadedmetadata = !0)
				}
			}

			onError(e, t) {
				var i;
				if (t.fatal) this.state = cE; else switch (t.details) {
					case _f.FRAG_GAP:
					case _f.FRAG_PARSING_ERROR:
					case _f.FRAG_DECRYPT_ERROR:
					case _f.FRAG_LOAD_ERROR:
					case _f.FRAG_LOAD_TIMEOUT:
					case _f.KEY_LOAD_ERROR:
					case _f.KEY_LOAD_TIMEOUT:
						this.onFragmentOrKeyLoadError(Lg, t);
						break;
					case _f.AUDIO_TRACK_LOAD_ERROR:
					case _f.AUDIO_TRACK_LOAD_TIMEOUT:
					case _f.LEVEL_PARSING_ERROR:
						!t.levelRetry && this.state === lE && (null == (i = t.context) ? void 0 : i.type) === kg && (this.state = rE);
						break;
					case _f.BUFFER_APPEND_ERROR:
					case _f.BUFFER_FULL_ERROR:
						if (!t.parent || "audio" !== t.parent) return;
						if (t.details === _f.BUFFER_APPEND_ERROR) return void this.resetLoadingState();
						this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
						break;
					case _f.INTERNAL_EXCEPTION:
						this.recoverWorkerError(t)
				}
			}

			onBufferFlushing(e, {type: t}) {
				t !== Uf && (this.flushing = !0)
			}

			onBufferFlushed(e, {type: t}) {
				if (t !== Uf) {
					this.flushing = !1, this.bufferFlushed = !0, this.state === hE && (this.state = rE);
					let e = this.mediaBuffer || this.media;
					e && (this.afterBufferFlushed(e, t, Lg), this.tick())
				}
			}

			_handleTransmuxComplete(e) {
				var t;
				let i = "audio", {hls: a} = this, {remuxResult: r, chunkMeta: n} = e, s = this.getCurrentContext(n);
				if (!s) return void this.resetWhenMissingContext(n);
				let {frag: o, part: l, level: d} = s, {details: u} = d, {audio: h, text: c, id3: m, initSegment: f} = r;
				if (!this.fragContextChanged(o) && u) {
					if (this.state = dE, this.switchingTrack && h && this.completeAudioSwitch(this.switchingTrack), null != f && f.tracks) {
						let e = o.initSegment || o;
						this._bufferInitSegment(d, f.tracks, e, n), a.trigger(Tf.FRAG_PARSING_INIT_SEGMENT, {
							frag: e,
							id: i,
							tracks: f.tracks
						})
					}
					if (h) {
						let {startPTS: e, endPTS: t, startDTS: i, endDTS: a} = h;
						l && (l.elementaryStreams[Nf] = {
							startPTS: e,
							endPTS: t,
							startDTS: i,
							endDTS: a
						}), o.setElementaryStreamInfo(Nf, e, t, i, a), this.bufferFragmentData(h, o, l, n)
					}
					if (null != m && null != (t = m.samples) && t.length) {
						let e = vf({id: i, frag: o, details: u}, m);
						a.trigger(Tf.FRAG_PARSING_METADATA, e)
					}
					if (c) {
						let e = vf({id: i, frag: o, details: u}, c);
						a.trigger(Tf.FRAG_PARSING_USERDATA, e)
					}
				} else this.fragmentTracker.removeFragment(o)
			}

			_bufferInitSegment(e, t, i, a) {
				if (this.state !== dE) return;
				t.video && delete t.video;
				let r = t.audio;
				if (!r) return;
				r.id = "audio";
				let n = e.audioCodec;
				this.log(`Init audio buffer, container:${r.container}, codecs[level/parsed]=[${n}/${r.codec}]`), n && 1 === n.split(",").length && (r.levelCodec = n), this.hls.trigger(Tf.BUFFER_CODECS, t);
				let s = r.initSegment;
				if (null != s && s.byteLength) {
					let e = {type: "audio", frag: i, part: null, chunkMeta: a, parent: i.type, data: s};
					this.hls.trigger(Tf.BUFFER_APPENDING, e)
				}
				this.tickImmediate()
			}

			loadFragment(e, t, i) {
				let a = this.fragmentTracker.getState(e);
				var r;
				if (this.fragCurrent = e, this.switchingTrack || a === Uv || a === Bv) if ("initSegment" === e.sn) this._loadInitSegment(e, t); else if (null != (r = t.details) && r.live && !this.initPTS[e.cc]) {
					this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = mE;
					let i = this.mainDetails;
					i && i.fragments[0].start !== t.details.fragments[0].start && Xv(t.details, i)
				} else this.startFragRequested = !0, super.loadFragment(e, t, i); else this.clearTrackerIfNeeded(e)
			}

			flushAudioIfNeeded(e) {
				let {media: t, bufferedTrack: i} = this, a = null == i ? void 0 : i.attrs, r = e.attrs;
				t && a && (a.CHANNELS !== r.CHANNELS || i.name !== e.name || i.lang !== e.lang) && (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"), this.bufferedTrack = null)
			}

			completeAudioSwitch(e) {
				let {hls: t} = this;
				this.flushAudioIfNeeded(e), this.bufferedTrack = e, this.switchingTrack = null, t.trigger(Tf.AUDIO_TRACK_SWITCHED, ff({}, e))
			}
		}, audioTrackController: class extends kv {
			constructor(e) {
				super(e, "[audio-track-controller]"), this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners()
			}

			get allAudioTracks() {
				return this.tracks
			}

			get audioTracks() {
				return this.tracksInGroup
			}

			get audioTrack() {
				return this.trackId
			}

			set audioTrack(e) {
				this.selectDefaultTrack = !1, this.setAudioTrack(e)
			}

			registerListeners() {
				let {hls: e} = this;
				e.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.on(Tf.MANIFEST_PARSED, this.onManifestParsed, this), e.on(Tf.LEVEL_LOADING, this.onLevelLoading, this), e.on(Tf.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(Tf.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(Tf.ERROR, this.onError, this)
			}

			unregisterListeners() {
				let {hls: e} = this;
				e.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.off(Tf.MANIFEST_PARSED, this.onManifestParsed, this), e.off(Tf.LEVEL_LOADING, this.onLevelLoading, this), e.off(Tf.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(Tf.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(Tf.ERROR, this.onError, this)
			}

			destroy() {
				this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy()
			}

			onManifestLoading() {
				this.tracks = [], this.tracksInGroup = [], this.groupIds = null, this.currentTrack = null, this.trackId = -1, this.selectDefaultTrack = !0
			}

			onManifestParsed(e, t) {
				this.tracks = t.audioTracks || []
			}

			onAudioTrackLoaded(e, t) {
				let {id: i, groupId: a, details: r} = t, n = this.tracksInGroup[i];
				if (!n || n.groupId !== a) return void this.warn(`Audio track with id:${i} and group:${a} not found in active group ${null == n ? void 0 : n.groupId}`);
				let s = n.details;
				n.details = t.details, this.log(`Audio track ${i} "${n.name}" lang:${n.lang} group:${a} loaded [${r.startSN}-${r.endSN}]`), i === this.trackId && this.playlistLoaded(i, t, s)
			}

			onLevelLoading(e, t) {
				this.switchLevel(t.level)
			}

			onLevelSwitching(e, t) {
				this.switchLevel(t.level)
			}

			switchLevel(e) {
				let t = this.hls.levels[e];
				if (!t) return;
				let i = t.audioGroups || null, a = this.groupIds, r = this.currentTrack;
				if (!i || (null == a ? void 0 : a.length) !== (null == i ? void 0 : i.length) || null != i && i.some((e => -1 === (null == a ? void 0 : a.indexOf(e))))) {
					this.groupIds = i, this.trackId = -1, this.currentTrack = null;
					let e = this.tracks.filter((e => !i || -1 !== i.indexOf(e.groupId)));
					if (e.length) this.selectDefaultTrack && !e.some((e => e.default)) && (this.selectDefaultTrack = !1), e.forEach(((e, t) => {
						e.id = t
					})); else if (!r && !this.tracksInGroup.length) return;
					this.tracksInGroup = e;
					let t = this.hls.config.audioPreference;
					if (!r && t) {
						let i = xv(t, e, Ov);
						if (i > -1) r = e[i]; else {
							let e = xv(t, this.tracks);
							r = this.tracks[e]
						}
					}
					let a = this.findTrackId(r);
					-1 === a && r && (a = this.findTrackId(null));
					let s = {audioTracks: e};
					this.log(`Updating audio tracks, ${e.length} track(s) found in group(s): ${null == i ? void 0 : i.join(",")}`), this.hls.trigger(Tf.AUDIO_TRACKS_UPDATED, s);
					let o = this.trackId;
					if (-1 !== a && -1 === o) this.setAudioTrack(a); else if (e.length && -1 === o) {
						var n;
						let t = new Error(`No audio track selected for current audio group-ID(s): ${null == (n = this.groupIds) ? void 0 : n.join(",")} track count: ${e.length}`);
						this.warn(t.message), this.hls.trigger(Tf.ERROR, {
							type: Af.MEDIA_ERROR,
							details: _f.AUDIO_TRACK_LOAD_ERROR,
							fatal: !0,
							error: t
						})
					}
				} else this.shouldReloadPlaylist(r) && this.setAudioTrack(this.trackId)
			}

			onError(e, t) {
				t.fatal || !t.context || t.context.type === kg && t.context.id === this.trackId && (!this.groupIds || -1 !== this.groupIds.indexOf(t.context.groupId)) && (this.requestScheduled = -1, this.checkRetry(t))
			}

			setAudioOption(e) {
				let t = this.hls;
				if (t.config.audioPreference = e, e) {
					let i = this.allAudioTracks;
					if (this.selectDefaultTrack = !1, i.length) {
						let a = this.currentTrack;
						if (a && Mv(e, a, Ov)) return a;
						let r = xv(e, this.tracksInGroup, Ov);
						if (r > -1) {
							let e = this.tracksInGroup[r];
							return this.setAudioTrack(r), e
						}
						if (a) {
							let a = t.loadLevel;
							-1 === a && (a = t.firstAutoLevel);
							let r = function (e, t, i, a, r) {
								let n = t[a], s = t.reduce(((e, t, i) => {
									let a = t.uri;
									return (e[a] || (e[a] = [])).push(i), e
								}), {})[n.uri];
								s.length > 1 && (a = Math.max.apply(Math, s));
								let o = n.videoRange, l = n.frameRate, d = n.codecSet.substring(0, 4),
									u = Pv(t, a, (t => {
										if (t.videoRange !== o || t.frameRate !== l || t.codecSet.substring(0, 4) !== d) return !1;
										let a = t.audioGroups, n = i.filter((e => !a || -1 !== a.indexOf(e.groupId)));
										return xv(e, n, r) > -1
									}));
								return u > -1 ? u : Pv(t, a, (t => {
									let a = t.audioGroups, n = i.filter((e => !a || -1 !== a.indexOf(e.groupId)));
									return xv(e, n, r) > -1
								}))
							}(e, t.levels, i, a, Ov);
							if (-1 === r) return null;
							t.nextLoadLevel = r
						}
						if (e.channels || e.audioCodec) {
							let t = xv(e, i);
							if (t > -1) return i[t]
						}
					}
				}
				return null
			}

			setAudioTrack(e) {
				let t = this.tracksInGroup;
				if (e < 0 || e >= t.length) return void this.warn(`Invalid audio track id: ${e}`);
				this.clearTimer(), this.selectDefaultTrack = !1;
				let i = this.currentTrack, a = t[e], r = a.details && !a.details.live;
				if (e === this.trackId && a === i && r || (this.log(`Switching to audio-track ${e} "${a.name}" lang:${a.lang} group:${a.groupId} channels:${a.channels}`), this.trackId = e, this.currentTrack = a, this.hls.trigger(Tf.AUDIO_TRACK_SWITCHING, ff({}, a)), r)) return;
				let n = this.switchParams(a.url, null == i ? void 0 : i.details, a.details);
				this.loadPlaylist(n)
			}

			findTrackId(e) {
				let t = this.tracksInGroup;
				for (let i = 0; i < t.length; i++) {
					let a = t[i];
					if ((!this.selectDefaultTrack || a.default) && (!e || Mv(e, a, Ov))) return i
				}
				if (e) {
					let {name: i, lang: a, assocLang: r, characteristics: n, audioCodec: s, channels: o} = e;
					for (let e = 0; e < t.length; e++) {
						if (Mv({
							name: i,
							lang: a,
							assocLang: r,
							characteristics: n,
							audioCodec: s,
							channels: o
						}, t[e], Ov)) return e
					}
					for (let i = 0; i < t.length; i++) {
						let a = t[i];
						if (bb(e.attrs, a.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) return i
					}
					for (let i = 0; i < t.length; i++) {
						let a = t[i];
						if (bb(e.attrs, a.attrs, ["LANGUAGE"])) return i
					}
				}
				return -1
			}

			loadPlaylist(e) {
				let t = this.currentTrack;
				if (this.shouldLoadPlaylist(t) && t) {
					super.loadPlaylist();
					let i = t.id, a = t.groupId, r = t.url;
					if (e) try {
						r = e.addDirectives(r)
					} catch (e) {
						this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`)
					}
					this.log(`loading audio-track playlist ${i} "${t.name}" lang:${t.lang} group:${a}`), this.clearTimer(), this.hls.trigger(Tf.AUDIO_TRACK_LOADING, {
						url: r,
						id: i,
						groupId: a,
						deliveryDirectives: e || null
					})
				}
			}
		}, emeController: gy, cmcdController: class {
			constructor(e) {
				this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.includeKeys = void 0, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => {
					this.initialized && (this.starved = !0), this.buffering = !0
				}, this.onPlaying = () => {
					this.initialized || (this.initialized = !0), this.buffering = !1
				}, this.applyPlaylistData = e => {
					try {
						this.apply(e, {ot: vy.MANIFEST, su: !this.initialized})
					} catch (e) {
						Rf.warn("Could not generate manifest CMCD data.", e)
					}
				}, this.applyFragmentData = e => {
					try {
						let t = e.frag, i = this.hls.levels[t.level], a = this.getObjectType(t),
							r = {d: 1e3 * t.duration, ot: a};
						(a === vy.VIDEO || a === vy.AUDIO || a == vy.MUXED) && (r.br = i.bitrate / 1e3, r.tb = this.getTopBandwidth(a) / 1e3, r.bl = this.getBufferLength(a)), this.apply(e, r)
					} catch (e) {
						Rf.warn("Could not generate segment CMCD data.", e)
					}
				}, this.hls = e;
				let t = this.config = e.config, {cmcd: i} = t;
				null != i && (t.pLoader = this.createPlaylistLoader(), t.fLoader = this.createFragmentLoader(), this.sid = i.sessionId || function () {
					try {
						return crypto.randomUUID()
					} catch {
						try {
							let e = URL.createObjectURL(new Blob), t = e.toString();
							return URL.revokeObjectURL(e), t.slice(t.lastIndexOf("/") + 1)
						} catch {
							let e = (new Date).getTime();
							return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t => {
								let i = (e + 16 * Math.random()) % 16 | 0;
								return e = Math.floor(e / 16), ("x" == t ? i : 3 & i | 8).toString(16)
							}))
						}
					}
				}(), this.cid = i.contentId, this.useHeaders = !0 === i.useHeaders, this.includeKeys = i.includeKeys, this.registerListeners())
			}

			registerListeners() {
				let e = this.hls;
				e.on(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(Tf.MEDIA_DETACHED, this.onMediaDetached, this), e.on(Tf.BUFFER_CREATED, this.onBufferCreated, this)
			}

			unregisterListeners() {
				let e = this.hls;
				e.off(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(Tf.MEDIA_DETACHED, this.onMediaDetached, this), e.off(Tf.BUFFER_CREATED, this.onBufferCreated, this)
			}

			destroy() {
				this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null, this.onWaiting = this.onPlaying = null
			}

			onMediaAttached(e, t) {
				this.media = t.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying)
			}

			onMediaDetached() {
				this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null)
			}

			onBufferCreated(e, t) {
				var i, a;
				this.audioBuffer = null == (i = t.tracks.audio) ? void 0 : i.buffer, this.videoBuffer = null == (a = t.tracks.video) ? void 0 : a.buffer
			}

			createData() {
				var e;
				return {
					v: 1,
					sf: Ey.HLS,
					sid: this.sid,
					cid: this.cid,
					pr: null == (e = this.media) ? void 0 : e.playbackRate,
					mtp: this.hls.bandwidthEstimate / 1e3
				}
			}

			apply(e, t = {}) {
				vf(t, this.createData());
				let i = t.ot === vy.INIT || t.ot === vy.VIDEO || t.ot === vy.MUXED;
				this.starved && i && (t.bs = !0, t.su = !0, this.starved = !1), null == t.su && (t.su = this.buffering);
				let {includeKeys: a} = this;
				a && (t = Object.keys(t).reduce(((e, i) => (a.includes(i) && (e[i] = t[i]), e)), {})), this.useHeaders ? (e.headers || (e.headers = {}), Zy(e.headers, t)) : e.url = tT(e.url, t)
			}

			getObjectType(e) {
				let {type: t} = e;
				return "subtitle" === t ? vy.TIMED_TEXT : "initSegment" === e.sn ? vy.INIT : "audio" === t ? vy.AUDIO : "main" === t ? this.hls.audioTracks.length ? vy.VIDEO : vy.MUXED : void 0
			}

			getTopBandwidth(e) {
				let t, i = 0, a = this.hls;
				if (e === vy.AUDIO) t = a.audioTracks; else {
					let e = a.maxAutoLevel, i = e > -1 ? e + 1 : a.levels.length;
					t = a.levels.slice(0, i)
				}
				for (let e of t) e.bitrate > i && (i = e.bitrate);
				return i > 0 ? i : NaN
			}

			getBufferLength(e) {
				let t = this.hls.media, i = e === vy.AUDIO ? this.audioBuffer : this.videoBuffer;
				return i && t ? 1e3 * Vv.bufferInfo(i, t.currentTime, this.config.maxBufferHole).len : NaN
			}

			createPlaylistLoader() {
				let {pLoader: e} = this.config, t = this.applyPlaylistData, i = e || this.config.loader;
				return class {
					constructor(e) {
						this.loader = void 0, this.loader = new i(e)
					}

					get stats() {
						return this.loader.stats
					}

					get context() {
						return this.loader.context
					}

					destroy() {
						this.loader.destroy()
					}

					abort() {
						this.loader.abort()
					}

					load(e, i, a) {
						t(e), this.loader.load(e, i, a)
					}
				}
			}

			createFragmentLoader() {
				let {fLoader: e} = this.config, t = this.applyFragmentData, i = e || this.config.loader;
				return class {
					constructor(e) {
						this.loader = void 0, this.loader = new i(e)
					}

					get stats() {
						return this.loader.stats
					}

					get context() {
						return this.loader.context
					}

					destroy() {
						this.loader.destroy()
					}

					abort() {
						this.loader.abort()
					}

					load(e, i, a) {
						t(e), this.loader.load(e, i, a)
					}
				}
			}
		}, contentSteeringController: class {
			constructor(e) {
				this.hls = void 0, this.log = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this.pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.log = Rf.log.bind(Rf, "[content-steering]:"), this.registerListeners()
			}

			registerListeners() {
				let e = this.hls;
				e.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.on(Tf.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(Tf.MANIFEST_PARSED, this.onManifestParsed, this), e.on(Tf.ERROR, this.onError, this)
			}

			unregisterListeners() {
				let e = this.hls;
				e && (e.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.off(Tf.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(Tf.MANIFEST_PARSED, this.onManifestParsed, this), e.off(Tf.ERROR, this.onError, this))
			}

			startLoad() {
				if (this.started = !0, this.clearTimeout(), this.enabled && this.uri) {
					if (this.updated) {
						let e = 1e3 * this.timeToLoad - (performance.now() - this.updated);
						if (e > 0) return void this.scheduleRefresh(this.uri, e)
					}
					this.loadSteeringManifest(this.uri)
				}
			}

			stopLoad() {
				this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), this.clearTimeout()
			}

			clearTimeout() {
				-1 !== this.reloadTimer && (self.clearTimeout(this.reloadTimer), this.reloadTimer = -1)
			}

			destroy() {
				this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null
			}

			removeLevel(e) {
				let t = this.levels;
				t && (this.levels = t.filter((t => t !== e)))
			}

			onManifestLoading() {
				this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null
			}

			onManifestLoaded(e, t) {
				let {contentSteering: i} = t;
				null !== i && (this.pathwayId = i.pathwayId, this.uri = i.uri, this.started && this.startLoad())
			}

			onManifestParsed(e, t) {
				this.audioTracks = t.audioTracks, this.subtitleTracks = t.subtitleTracks
			}

			onError(e, t) {
				let {errorAction: i} = t;
				if ((null == i ? void 0 : i.action) === Ev && i.flags === Av) {
					let e = this.levels, a = this.pathwayPriority, r = this.pathwayId;
					if (t.context) {
						let {groupId: i, pathwayId: a, type: n} = t.context;
						i && e ? r = this.getPathwayForGroupId(i, n, r) : a && (r = a)
					}
					r in this.penalizedPathways || (this.penalizedPathways[r] = performance.now()), !a && e && (a = e.reduce(((e, t) => (-1 === e.indexOf(t.pathwayId) && e.push(t.pathwayId), e)), [])), a && a.length > 1 && (this.updatePathwayPriority(a), i.resolved = this.pathwayId !== r), i.resolved || Rf.warn(`Could not resolve ${t.details} ("${t.error.message}") with content-steering for Pathway: ${r} levels: ${e && e.length} priorities: ${JSON.stringify(a)} penalized: ${JSON.stringify(this.penalizedPathways)}`)
				}
			}

			filterParsedLevels(e) {
				this.levels = e;
				let t = this.getLevelsForPathway(this.pathwayId);
				if (0 === t.length) {
					let i = e[0].pathwayId;
					this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${i}"`), t = this.getLevelsForPathway(i), this.pathwayId = i
				}
				return t.length !== e.length ? (this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`), t) : e
			}

			getLevelsForPathway(e) {
				return null === this.levels ? [] : this.levels.filter((t => e === t.pathwayId))
			}

			updatePathwayPriority(e) {
				this.pathwayPriority = e;
				let t, i = this.penalizedPathways, a = performance.now();
				Object.keys(i).forEach((e => {
					a - i[e] > 3e5 && delete i[e]
				}));
				for (let a = 0; a < e.length; a++) {
					let r = e[a];
					if (r in i) continue;
					if (r === this.pathwayId) return;
					let n = this.hls.nextLoadLevel, s = this.hls.levels[n];
					if (t = this.getLevelsForPathway(r), t.length > 0) {
						this.log(`Setting Pathway to "${r}"`), this.pathwayId = r, ov(t), this.hls.trigger(Tf.LEVELS_UPDATED, {levels: t});
						let e = this.hls.levels[n];
						s && e && this.levels && (e.attrs["STABLE-VARIANT-ID"] !== s.attrs["STABLE-VARIANT-ID"] && e.bitrate !== s.bitrate && this.log(`Unstable Pathways change from bitrate ${s.bitrate} to ${e.bitrate}`), this.hls.nextLoadLevel = n);
						break
					}
				}
			}

			getPathwayForGroupId(e, t, i) {
				let a = this.getLevelsForPathway(i).concat(this.levels || []);
				for (let i = 0; i < a.length; i++) if (t === kg && a[i].hasAudioGroup(e) || t === Sg && a[i].hasSubtitleGroup(e)) return a[i].pathwayId;
				return i
			}

			clonePathways(e) {
				let t = this.levels;
				if (!t) return;
				let i = {}, a = {};
				e.forEach((e => {
					let {ID: r, "BASE-ID": n, "URI-REPLACEMENT": s} = e;
					if (t.some((e => e.pathwayId === r))) return;
					let o = this.getLevelsForPathway(n).map((e => {
						let t = new Cf(e.attrs);
						t["PATHWAY-ID"] = r;
						let n = t.AUDIO && `${t.AUDIO}_clone_${r}`, o = t.SUBTITLES && `${t.SUBTITLES}_clone_${r}`;
						n && (i[t.AUDIO] = n, t.AUDIO = n), o && (a[t.SUBTITLES] = o, t.SUBTITLES = o);
						let l = aT(e.uri, t["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", s), d = new Zg({
							attrs: t,
							audioCodec: e.audioCodec,
							bitrate: e.bitrate,
							height: e.height,
							name: e.name,
							url: l,
							videoCodec: e.videoCodec,
							width: e.width
						});
						if (e.audioGroups) for (let t = 1; t < e.audioGroups.length; t++) d.addGroupId("audio", `${e.audioGroups[t]}_clone_${r}`);
						if (e.subtitleGroups) for (let t = 1; t < e.subtitleGroups.length; t++) d.addGroupId("text", `${e.subtitleGroups[t]}_clone_${r}`);
						return d
					}));
					t.push(...o), iT(this.audioTracks, i, s, r), iT(this.subtitleTracks, a, s, r)
				}))
			}

			loadSteeringManifest(e) {
				let t, i = this.hls.config, a = i.loader;
				this.loader && this.loader.destroy(), this.loader = new a(i);
				try {
					t = new self.URL(e)
				} catch {
					return this.enabled = !1, void this.log(`Failed to parse Steering Manifest URI: ${e}`)
				}
				if ("data:" !== t.protocol) {
					let e = 0 | (this.hls.bandwidthEstimate || i.abrEwmaDefaultEstimate);
					t.searchParams.set("_HLS_pathway", this.pathwayId), t.searchParams.set("_HLS_throughput", "" + e)
				}
				let r = {responseType: "json", url: t.href}, n = i.steeringManifestLoadPolicy.default,
					s = n.errorRetry || n.timeoutRetry || {}, o = {
						loadPolicy: n,
						timeout: n.maxLoadTimeMs,
						maxRetry: s.maxNumRetry || 0,
						retryDelay: s.retryDelayMs || 0,
						maxRetryDelay: s.maxRetryDelayMs || 0
					}, l = {
						onSuccess: (e, i, a, r) => {
							this.log(`Loaded steering manifest: "${t}"`);
							let n = e.data;
							if (1 !== n.VERSION) return void this.log(`Steering VERSION ${n.VERSION} not supported!`);
							this.updated = performance.now(), this.timeToLoad = n.TTL;
							let {"RELOAD-URI": s, "PATHWAY-CLONES": o, "PATHWAY-PRIORITY": l} = n;
							if (s) try {
								this.uri = new self.URL(s, t).href
							} catch {
								return this.enabled = !1, void this.log(`Failed to parse Steering Manifest RELOAD-URI: ${s}`)
							}
							this.scheduleRefresh(this.uri || a.url), o && this.clonePathways(o);
							let d = {steeringManifest: n, url: t.toString()};
							this.hls.trigger(Tf.STEERING_MANIFEST_LOADED, d), l && this.updatePathwayPriority(l)
						}, onError: (e, t, i, a) => {
							if (this.log(`Error loading steering manifest: ${e.code} ${e.text} (${t.url})`), this.stopLoad(), 410 === e.code) return this.enabled = !1, void this.log(`Steering manifest ${t.url} no longer available`);
							let r = 1e3 * this.timeToLoad;
							if (429 !== e.code) this.scheduleRefresh(this.uri || t.url, r); else {
								let e = this.loader;
								if ("function" == typeof (null == e ? void 0 : e.getResponseHeader)) {
									let t = e.getResponseHeader("Retry-After");
									t && (r = 1e3 * parseFloat(t))
								}
								this.log(`Steering manifest ${t.url} rate limited`)
							}
						}, onTimeout: (e, t, i) => {
							this.log(`Timeout loading steering manifest (${t.url})`), this.scheduleRefresh(this.uri || t.url)
						}
					};
				this.log(`Requesting steering manifest: ${t}`), this.loader.load(r, o, l)
			}

			scheduleRefresh(e, t = 1e3 * this.timeToLoad) {
				this.clearTimeout(), this.reloadTimer = self.setTimeout((() => {
					var t;
					let i = null == (t = this.hls) ? void 0 : t.media;
					!i || i.ended ? this.scheduleRefresh(e, 1e3 * this.timeToLoad) : this.loadSteeringManifest(e)
				}), t)
			}
		}
	});

	function mT(e) {
		return e && "object" == typeof e ? Array.isArray(e) ? e.map(mT) : Object.keys(e).reduce(((t, i) => (t[i] = mT(e[i]), t)), {}) : e
	}

	function fT(e) {
		let t = e.loader;
		t !== oT && t !== nT ? (Rf.log("[config]: Custom loader detected, cannot enable progressive streaming"), e.progressive = !1) : function () {
			if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try {
				return new self.ReadableStream({}), !0
			} catch {
			}
			return !1
		}() && (e.loader = oT, e.progressive = !0, e.enableSoftwareAES = !0, Rf.log("[config]: Progressive streaming enabled, using FetchLoader"))
	}

	var pT, gT = class extends kv {
		constructor(e, t) {
			super(e, "[level-controller]"), this._levels = [], this._firstLevel = -1, this._maxAutoLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = t, this._registerListeners()
		}

		get levels() {
			return 0 === this._levels.length ? null : this._levels
		}

		get level() {
			return this.currentLevelIndex
		}

		set level(e) {
			let t = this._levels;
			if (0 === t.length) return;
			if (e < 0 || e >= t.length) {
				let i = new Error("invalid level idx"), a = e < 0;
				if (this.hls.trigger(Tf.ERROR, {
					type: Af.OTHER_ERROR,
					details: _f.LEVEL_SWITCH_ERROR,
					level: e,
					fatal: a,
					error: i,
					reason: i.message
				}), a) return;
				e = Math.min(e, t.length - 1)
			}
			let i = this.currentLevelIndex, a = this.currentLevel, r = a ? a.attrs["PATHWAY-ID"] : void 0, n = t[e],
				s = n.attrs["PATHWAY-ID"];
			if (this.currentLevelIndex = e, this.currentLevel = n, i === e && n.details && a && r === s) return;
			this.log(`Switching to level ${e} (${n.height ? n.height + "p " : ""}${n.videoRange ? n.videoRange + " " : ""}${n.codecSet ? n.codecSet + " " : ""}@${n.bitrate})${s ? " with Pathway " + s : ""} from level ${i}${r ? " with Pathway " + r : ""}`);
			let o = {
				level: e,
				attrs: n.attrs,
				details: n.details,
				bitrate: n.bitrate,
				averageBitrate: n.averageBitrate,
				maxBitrate: n.maxBitrate,
				realBitrate: n.realBitrate,
				width: n.width,
				height: n.height,
				codecSet: n.codecSet,
				audioCodec: n.audioCodec,
				videoCodec: n.videoCodec,
				audioGroups: n.audioGroups,
				subtitleGroups: n.subtitleGroups,
				loaded: n.loaded,
				loadError: n.loadError,
				fragmentError: n.fragmentError,
				name: n.name,
				id: n.id,
				uri: n.uri,
				url: n.url,
				urlId: 0,
				audioGroupIds: n.audioGroupIds,
				textGroupIds: n.textGroupIds
			};
			this.hls.trigger(Tf.LEVEL_SWITCHING, o);
			let l = n.details;
			if (!l || l.live) {
				let e = this.switchParams(n.uri, null == a ? void 0 : a.details, l);
				this.loadPlaylist(e)
			}
		}

		get manualLevel() {
			return this.manualLevelIndex
		}

		set manualLevel(e) {
			this.manualLevelIndex = e, void 0 === this._startLevel && (this._startLevel = e), -1 !== e && (this.level = e)
		}

		get firstLevel() {
			return this._firstLevel
		}

		set firstLevel(e) {
			this._firstLevel = e
		}

		get startLevel() {
			if (void 0 === this._startLevel) {
				let e = this.hls.config.startLevel;
				return void 0 !== e ? e : this.hls.firstAutoLevel
			}
			return this._startLevel
		}

		set startLevel(e) {
			this._startLevel = e
		}

		get nextLoadLevel() {
			return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel
		}

		set nextLoadLevel(e) {
			this.level = e, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e)
		}

		_registerListeners() {
			let {hls: e} = this;
			e.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.on(Tf.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(Tf.LEVEL_LOADED, this.onLevelLoaded, this), e.on(Tf.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(Tf.FRAG_BUFFERED, this.onFragBuffered, this), e.on(Tf.ERROR, this.onError, this)
		}

		_unregisterListeners() {
			let {hls: e} = this;
			e.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.off(Tf.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(Tf.LEVEL_LOADED, this.onLevelLoaded, this), e.off(Tf.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(Tf.FRAG_BUFFERED, this.onFragBuffered, this), e.off(Tf.ERROR, this.onError, this)
		}

		destroy() {
			this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy()
		}

		stopLoad() {
			this._levels.forEach((e => {
				e.loadError = 0, e.fragmentError = 0
			})), super.stopLoad()
		}

		resetLevels() {
			this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [], this._maxAutoLevel = -1
		}

		onManifestLoading(e, t) {
			this.resetLevels()
		}

		onManifestLoaded(e, t) {
			let i = this.hls.config.preferManagedMediaSource, a = [], r = {}, n = {}, s = !1, o = !1, l = !1;
			t.levels.forEach((e => {
				var t, d;
				let u = e.attrs, {audioCodec: h, videoCodec: c} = e;
				-1 !== (null == (t = h) ? void 0 : t.indexOf("mp4a.40.34")) && (pT || (pT = /chrome|firefox/i.test(navigator.userAgent)), pT && (e.audioCodec = h = void 0)), h && (e.audioCodec = h = og(h, i)), 0 === (null == (d = c) ? void 0 : d.indexOf("avc1")) && (c = e.videoCodec = function (e) {
					let t = e.split(".");
					if (t.length > 2) {
						let e = t.shift() + ".";
						return e += parseInt(t.shift()).toString(16), e += ("000" + parseInt(t.shift()).toString(16)).slice(-4), e
					}
					return e
				}(c));
				let {width: m, height: f, unknownCodecs: p} = e;
				if (s || (s = !(!m || !f)), o || (o = !!c), l || (l = !!h), null != p && p.length || h && !eg(h, "audio", i) || c && !eg(c, "video", i)) return;
				let {CODECS: g, "FRAME-RATE": v, "HDCP-LEVEL": E, "PATHWAY-ID": b, RESOLUTION: y, "VIDEO-RANGE": T} = u,
					A = `${b || "."}-${e.bitrate}-${y}-${v}-${g}-${T}-${E}`;
				if (r[A]) if (r[A].uri === e.url || e.attrs["PATHWAY-ID"]) r[A].addGroupId("audio", u.AUDIO), r[A].addGroupId("text", u.SUBTITLES); else {
					let t = n[A] += 1;
					e.attrs["PATHWAY-ID"] = new Array(t + 1).join(".");
					let i = new Zg(e);
					r[A] = i, a.push(i)
				} else {
					let t = new Zg(e);
					r[A] = t, n[A] = 1, a.push(t)
				}
			})), this.filterAndSortMediaOptions(a, t, s, o, l)
		}

		filterAndSortMediaOptions(e, t, i, a, r) {
			let n = [], s = [], o = e;
			if ((i || a) && r && (o = o.filter((({
				                                     videoCodec: e,
				                                     videoRange: t,
				                                     width: i,
				                                     height: a
			                                     }) => (!!e || !(!i || !a)) && function (e) {
				return !!e && qg.indexOf(e) > -1
			}(t)))), 0 === o.length) return void Promise.resolve().then((() => {
				if (this.hls) {
					t.levels.length && this.warn(`One or more CODECS in variant not supported: ${JSON.stringify(t.levels[0].attrs)}`);
					let e = new Error("no level with compatible codecs found in manifest");
					this.hls.trigger(Tf.ERROR, {
						type: Af.MEDIA_ERROR,
						details: _f.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
						fatal: !0,
						url: t.url,
						error: e,
						reason: e.message
					})
				}
			}));
			if (t.audioTracks) {
				let {preferManagedMediaSource: e} = this.hls.config;
				n = t.audioTracks.filter((t => !t.audioCodec || eg(t.audioCodec, "audio", e))), vT(n)
			}
			t.subtitles && (s = t.subtitles, vT(s));
			let l = o.slice(0);
			o.sort(((e, t) => {
				if (e.attrs["HDCP-LEVEL"] !== t.attrs["HDCP-LEVEL"]) return (e.attrs["HDCP-LEVEL"] || "") > (t.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
				if (i && e.height !== t.height) return e.height - t.height;
				if (e.frameRate !== t.frameRate) return e.frameRate - t.frameRate;
				if (e.videoRange !== t.videoRange) return qg.indexOf(e.videoRange) - qg.indexOf(t.videoRange);
				if (e.videoCodec !== t.videoCodec) {
					let i = ag(e.videoCodec), a = ag(t.videoCodec);
					if (i !== a) return a - i
				}
				if (e.uri === t.uri && e.codecSet !== t.codecSet) {
					let i = rg(e.codecSet), a = rg(t.codecSet);
					if (i !== a) return a - i
				}
				return e.averageBitrate !== t.averageBitrate ? e.averageBitrate - t.averageBitrate : 0
			}));
			let d = l[0];
			if (this.steering && (o = this.steering.filterParsedLevels(o), o.length !== l.length)) for (let e = 0; e < l.length; e++) if (l[e].pathwayId === o[0].pathwayId) {
				d = l[e];
				break
			}
			this._levels = o;
			for (let e = 0; e < o.length; e++) if (o[e] === d) {
				var u;
				this._firstLevel = e;
				let t = d.bitrate, i = this.hls.bandwidthEstimate;
				if (this.log(`manifest loaded, ${o.length} level(s) found, first bitrate: ${t}`), void 0 === (null == (u = this.hls.userConfig) ? void 0 : u.abrEwmaDefaultEstimate)) {
					let e = Math.min(t, this.hls.config.abrEwmaDefaultEstimateMax);
					e > i && i === cT.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = e)
				}
				break
			}
			let h = r && !a, c = {
				levels: o,
				audioTracks: n,
				subtitleTracks: s,
				sessionData: t.sessionData,
				sessionKeys: t.sessionKeys,
				firstLevel: this._firstLevel,
				stats: t.stats,
				audio: r,
				video: a,
				altAudio: !h && n.some((e => !!e.url))
			};
			this.hls.trigger(Tf.MANIFEST_PARSED, c), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition)
		}

		onError(e, t) {
			t.fatal || !t.context || t.context.type === _g && t.context.level === this.level && this.checkRetry(t)
		}

		onFragBuffered(e, {frag: t}) {
			if (void 0 !== t && t.type === wg) {
				let e = t.elementaryStreams;
				if (!Object.keys(e).some((t => !!e[t]))) return;
				let i = this._levels[t.level];
				null != i && i.loadError && (this.log(`Resetting level error count of ${i.loadError} on frag buffered`), i.loadError = 0)
			}
		}

		onLevelLoaded(e, t) {
			var i;
			let {level: a, details: r} = t, n = this._levels[a];
			var s;
			if (!n) return this.warn(`Invalid level index ${a}`), void (null != (s = t.deliveryDirectives) && s.skip && (r.deltaUpdateFailed = !0));
			a === this.currentLevelIndex ? (0 === n.fragmentError && (n.loadError = 0), this.playlistLoaded(a, t, n.details)) : null != (i = t.deliveryDirectives) && i.skip && (r.deltaUpdateFailed = !0)
		}

		loadPlaylist(e) {
			super.loadPlaylist();
			let t = this.currentLevelIndex, i = this.currentLevel;
			if (i && this.shouldLoadPlaylist(i)) {
				let a = i.uri;
				if (e) try {
					a = e.addDirectives(a)
				} catch (e) {
					this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`)
				}
				let r = i.attrs["PATHWAY-ID"];
				this.log(`Loading level index ${t}${void 0 !== (null == e ? void 0 : e.msn) ? " at sn " + e.msn + " part " + e.part : ""} with${r ? " Pathway " + r : ""} ${a}`), this.clearTimer(), this.hls.trigger(Tf.LEVEL_LOADING, {
					url: a,
					level: t,
					pathwayId: i.attrs["PATHWAY-ID"],
					id: 0,
					deliveryDirectives: e || null
				})
			}
		}

		removeLevel(e) {
			var t;
			let i = this._levels.filter(((t, i) => i !== e || (this.steering && this.steering.removeLevel(t), t === this.currentLevel && (this.currentLevel = null, this.currentLevelIndex = -1, t.details && t.details.fragments.forEach((e => e.level = -1))), !1)));
			ov(i), this._levels = i, this.currentLevelIndex > -1 && null != (t = this.currentLevel) && t.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level), this.hls.trigger(Tf.LEVELS_UPDATED, {levels: i})
		}

		onLevelsUpdated(e, {levels: t}) {
			this._levels = t
		}

		checkMaxAutoUpdated() {
			let {autoLevelCapping: e, maxAutoLevel: t, maxHdcpLevel: i} = this.hls;
			this._maxAutoLevel !== t && (this._maxAutoLevel = t, this.hls.trigger(Tf.MAX_AUTO_LEVEL_UPDATED, {
				autoLevelCapping: e,
				levels: this.levels,
				maxAutoLevel: t,
				minAutoLevel: this.hls.minAutoLevel,
				maxHdcpLevel: i
			}))
		}
	};

	function vT(e) {
		let t = {};
		e.forEach((e => {
			let i = e.groupId || "";
			e.id = t[i] = t[i] || 0, t[i]++
		}))
	}

	function ET() {
		return self.SourceBuffer || self.WebKitSourceBuffer
	}

	function bT() {
		if (!Zp()) return !1;
		let e = ET();
		return !e || e.prototype && "function" == typeof e.prototype.appendBuffer && "function" == typeof e.prototype.remove
	}

	var yT = class extends pE {
		constructor(e, t, i) {
			super(e, t, i, "[stream-controller]", wg), this.audioCodecSwap = !1, this.gapController = null, this.level = -1, this._forceStartLoad = !1, this.altAudio = !1, this.audioOnly = !1, this.fragPlaying = null, this.onvplaying = null, this.onvseeked = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this._registerListeners()
		}

		get nextLevel() {
			let e = this.nextBufferedFrag;
			return e ? e.level : -1
		}

		get currentFrag() {
			let e = this.media;
			return e ? this.fragPlaying || this.getAppendedFrag(e.currentTime) : null
		}

		get currentProgramDateTime() {
			let e = this.media;
			if (e) {
				let t = e.currentTime, i = this.currentFrag;
				if (i && Ef(t) && Ef(i.programDateTime)) {
					let e = i.programDateTime + 1e3 * (t - i.start);
					return new Date(e)
				}
			}
			return null
		}

		get currentLevel() {
			let e = this.currentFrag;
			return e ? e.level : -1
		}

		get nextBufferedFrag() {
			let e = this.currentFrag;
			return e ? this.followingBufferedFrag(e) : null
		}

		get forceStartLoad() {
			return this._forceStartLoad
		}

		_registerListeners() {
			let {hls: e} = this;
			e.on(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.on(Tf.MANIFEST_PARSED, this.onManifestParsed, this), e.on(Tf.LEVEL_LOADING, this.onLevelLoading, this), e.on(Tf.LEVEL_LOADED, this.onLevelLoaded, this), e.on(Tf.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(Tf.ERROR, this.onError, this), e.on(Tf.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(Tf.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(Tf.BUFFER_CREATED, this.onBufferCreated, this), e.on(Tf.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(Tf.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(Tf.FRAG_BUFFERED, this.onFragBuffered, this)
		}

		_unregisterListeners() {
			let {hls: e} = this;
			e.off(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.off(Tf.MANIFEST_PARSED, this.onManifestParsed, this), e.off(Tf.LEVEL_LOADED, this.onLevelLoaded, this), e.off(Tf.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(Tf.ERROR, this.onError, this), e.off(Tf.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(Tf.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(Tf.BUFFER_CREATED, this.onBufferCreated, this), e.off(Tf.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(Tf.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(Tf.FRAG_BUFFERED, this.onFragBuffered, this)
		}

		onHandlerDestroying() {
			this._unregisterListeners(), super.onHandlerDestroying()
		}

		startLoad(e) {
			if (this.levels) {
				let {lastCurrentTime: t, hls: i} = this;
				if (this.stopLoad(), this.setInterval(100), this.level = -1, !this.startFragRequested) {
					let e = i.startLevel;
					-1 === e && (i.config.testBandwidth && this.levels.length > 1 ? (e = 0, this.bitrateTest = !0) : e = i.firstAutoLevel), i.nextLoadLevel = e, this.level = i.loadLevel, this.loadedmetadata = !1
				}
				t > 0 && -1 === e && (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t), this.state = rE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
			} else this._forceStartLoad = !0, this.state = aE
		}

		stopLoad() {
			this._forceStartLoad = !1, super.stopLoad()
		}

		doTick() {
			switch (this.state) {
				case fE: {
					let {levels: e, level: t} = this, i = null == e ? void 0 : e[t], a = null == i ? void 0 : i.details;
					if (a && (!a.live || this.levelLastLoaded === i)) {
						if (this.waitForCdnTuneIn(a)) break;
						this.state = rE;
						break
					}
					if (this.hls.nextLoadLevel !== this.level) {
						this.state = rE;
						break
					}
					break
				}
				case oE: {
					var e;
					let t = self.performance.now(), i = this.retryDate;
					if (!i || t >= i || null != (e = this.media) && e.seeking) {
						let {levels: e, level: t} = this, i = null == e ? void 0 : e[t];
						this.resetStartWhenNotLoaded(i || null), this.state = rE
					}
				}
			}
			this.state === rE && this.doTickIdle(), this.onTickEnd()
		}

		onTickEnd() {
			super.onTickEnd(), this.checkBuffer(), this.checkFragmentChanged()
		}

		doTickIdle() {
			let {hls: e, levelLastLoaded: t, levels: i, media: a} = this;
			if (null === t || !a && (this.startFragRequested || !e.config.startFragPrefetch) || this.altAudio && this.audioOnly) return;
			let r = e.nextLoadLevel;
			if (null == i || !i[r]) return;
			let n = i[r], s = this.getMainFwdBufferInfo();
			if (null === s) return;
			let o = this.getLevelDetails();
			if (o && this._streamEnded(s, o)) {
				let e = {};
				return this.altAudio && (e.type = "video"), this.hls.trigger(Tf.BUFFER_EOS, e), void (this.state = hE)
			}
			e.loadLevel !== r && -1 === e.manualLevel && this.log(`Adapting to level ${r} from level ${this.level}`), this.level = e.nextLoadLevel = r;
			let l = n.details;
			if (!l || this.state === fE || l.live && this.levelLastLoaded !== n) return this.level = r, void (this.state = fE);
			let d = s.len, u = this.getMaxBufferLength(n.maxBitrate);
			if (d >= u) return;
			this.backtrackFragment && this.backtrackFragment.start > s.end && (this.backtrackFragment = null);
			let h = this.backtrackFragment ? this.backtrackFragment.start : s.end, c = this.getNextFragment(h, l);
			if (this.couldBacktrack && !this.fragPrevious && c && "initSegment" !== c.sn && this.fragmentTracker.getState(c) !== $v) {
				var m;
				let e = (null != (m = this.backtrackFragment) ? m : c).sn - l.startSN, t = l.fragments[e - 1];
				t && c.cc === t.cc && (c = t, this.fragmentTracker.removeFragment(t))
			} else this.backtrackFragment && s.len && (this.backtrackFragment = null);
			if (c && this.isLoopLoading(c, h)) {
				if (!c.gap) {
					let e = this.audioOnly && !this.altAudio ? Nf : Uf,
						t = (e === Uf ? this.videoBuffer : this.mediaBuffer) || this.media;
					t && this.afterBufferFlushed(t, e, wg)
				}
				c = this.getNextFragmentLoopLoading(c, l, s, wg, u)
			}
			c && (c.initSegment && !c.initSegment.data && !this.bitrateTest && (c = c.initSegment), this.loadFragment(c, n, h))
		}

		loadFragment(e, t, i) {
			let a = this.fragmentTracker.getState(e);
			this.fragCurrent = e, a === Uv || a === Bv ? "initSegment" === e.sn ? this._loadInitSegment(e, t) : this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, t)) : (this.startFragRequested = !0, super.loadFragment(e, t, i)) : this.clearTrackerIfNeeded(e)
		}

		getBufferedFrag(e) {
			return this.fragmentTracker.getBufferedFrag(e, wg)
		}

		followingBufferedFrag(e) {
			return e ? this.getBufferedFrag(e.end + .5) : null
		}

		immediateLevelSwitch() {
			this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
		}

		nextLevelSwitch() {
			let {levels: e, media: t} = this;
			if (null != t && t.readyState) {
				let i, a = this.getAppendedFrag(t.currentTime);
				a && a.start > 1 && this.flushMainBuffer(0, a.start - 1);
				let r = this.getLevelDetails();
				if (null != r && r.live) {
					let e = this.getMainFwdBufferInfo();
					if (!e || e.len < 2 * r.targetduration) return
				}
				if (!t.paused && e) {
					let t = e[this.hls.nextLoadLevel], a = this.fragLastKbps;
					i = a && this.fragCurrent ? this.fragCurrent.duration * t.maxBitrate / (1e3 * a) + 1 : 0
				} else i = 0;
				let n = this.getBufferedFrag(t.currentTime + i);
				if (n) {
					let e = this.followingBufferedFrag(n);
					if (e) {
						this.abortCurrentFrag();
						let t = e.maxStartPTS ? e.maxStartPTS : e.start, i = e.duration,
							a = Math.max(n.end, t + Math.min(Math.max(i - this.config.maxFragLookUpTolerance, i * (this.couldBacktrack ? .5 : .125)), i * (this.couldBacktrack ? .75 : .25)));
						this.flushMainBuffer(a, Number.POSITIVE_INFINITY)
					}
				}
			}
		}

		abortCurrentFrag() {
			let e = this.fragCurrent;
			switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) {
				case nE:
				case sE:
				case oE:
				case dE:
				case uE:
					this.state = rE
			}
			this.nextLoadPosition = this.getLoadPosition()
		}

		flushMainBuffer(e, t) {
			super.flushMainBuffer(e, t, this.altAudio ? "video" : null)
		}

		onMediaAttached(e, t) {
			super.onMediaAttached(e, t);
			let i = t.media;
			this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), i.addEventListener("playing", this.onvplaying), i.addEventListener("seeked", this.onvseeked), this.gapController = new class {
				constructor(e, t, i, a) {
					this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = e, this.media = t, this.fragmentTracker = i, this.hls = a
				}

				destroy() {
					this.media = null, this.hls = this.fragmentTracker = null
				}

				poll(e, t) {
					let {config: i, media: a, stalled: r} = this;
					if (null === a) return;
					let {currentTime: n, seeking: s} = a, o = this.seeking && !s, l = !this.seeking && s;
					if (this.seeking = s, n !== e) {
						if (this.moved = !0, s || (this.nudgeRetry = 0), null !== r) {
							if (this.stallReported) {
								let e = self.performance.now() - r;
								Rf.warn(`playback not stuck anymore @${n}, after ${Math.round(e)}ms`), this.stallReported = !1
							}
							this.stalled = null
						}
						return
					}
					if (l || o) return void (this.stalled = null);
					if (a.paused && !s || a.ended || 0 === a.playbackRate || !Vv.getBuffered(a).length) return void (this.nudgeRetry = 0);
					let d = Vv.bufferInfo(a, n, 0), u = d.nextStart || 0;
					if (s) {
						let e = d.len > 2,
							i = !u || t && t.start <= n || u - n > 2 && !this.fragmentTracker.getPartialFragment(n);
						if (e || i) return;
						this.moved = !1
					}
					if (!this.moved && null !== this.stalled) {
						var h;
						if (!(d.len > 0 || u)) return;
						let e = Math.max(u, d.start || 0) - n,
							t = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null,
							i = (null == t || null == (h = t.details) ? void 0 : h.live) ? 2 * t.details.targetduration : 2,
							r = this.fragmentTracker.getPartialFragment(n);
						if (e > 0 && (e <= i || r)) return void (a.paused || this._trySkipBufferHole(r))
					}
					let c = self.performance.now();
					if (null === r) return void (this.stalled = c);
					let m = c - r;
					if (!s && m >= 250 && (this._reportStall(d), !this.media)) return;
					let f = Vv.bufferInfo(a, n, i.maxBufferHole);
					this._tryFixBufferStall(f, m)
				}

				_tryFixBufferStall(e, t) {
					let {config: i, fragmentTracker: a, media: r} = this;
					if (null === r) return;
					let n = r.currentTime, s = a.getPartialFragment(n);
					s && (this._trySkipBufferHole(s) || !this.media) || (e.len > i.maxBufferHole || e.nextStart && e.nextStart - n < i.maxBufferHole) && t > 1e3 * i.highBufferWatchdogPeriod && (Rf.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer())
				}

				_reportStall(e) {
					let {hls: t, media: i, stallReported: a} = this;
					if (!a && i) {
						this.stallReported = !0;
						let a = new Error(`Playback stalling at @${i.currentTime} due to low buffer (${JSON.stringify(e)})`);
						Rf.warn(a.message), t.trigger(Tf.ERROR, {
							type: Af.MEDIA_ERROR,
							details: _f.BUFFER_STALLED_ERROR,
							fatal: !1,
							error: a,
							buffer: e.len
						})
					}
				}

				_trySkipBufferHole(e) {
					let {config: t, hls: i, media: a} = this;
					if (null === a) return 0;
					let r = a.currentTime, n = Vv.bufferInfo(a, r, 0), s = r < n.start ? n.start : n.nextStart;
					if (s) {
						let o = n.len <= t.maxBufferHole, l = n.len > 0 && n.len < 1 && a.readyState < 3, d = s - r;
						if (d > 0 && (o || l)) {
							if (d > t.maxBufferHole) {
								let {fragmentTracker: t} = this, i = !1;
								if (0 === r) {
									let e = t.getAppendedFrag(0, wg);
									e && s < e.end && (i = !0)
								}
								if (!i) {
									let i = e || t.getAppendedFrag(r, wg);
									if (i) {
										let e = !1, a = i.end;
										for (; a < s;) {
											let i = t.getPartialFragment(a);
											if (!i) {
												e = !0;
												break
											}
											a += i.duration
										}
										if (e) return 0
									}
								}
							}
							let n = Math.max(s + .05, r + .1);
							if (Rf.warn(`skipping hole, adjusting currentTime from ${r} to ${n}`), this.moved = !0, this.stalled = null, a.currentTime = n, e && !e.gap) {
								let t = new Error(`fragment loaded with buffer holes, seeking from ${r} to ${n}`);
								i.trigger(Tf.ERROR, {
									type: Af.MEDIA_ERROR,
									details: _f.BUFFER_SEEK_OVER_HOLE,
									fatal: !1,
									error: t,
									reason: t.message,
									frag: e
								})
							}
							return n
						}
					}
					return 0
				}

				_tryNudgeBuffer() {
					let {config: e, hls: t, media: i, nudgeRetry: a} = this;
					if (null === i) return;
					let r = i.currentTime;
					if (this.nudgeRetry++, a < e.nudgeMaxRetry) {
						let n = r + (a + 1) * e.nudgeOffset, s = new Error(`Nudging 'currentTime' from ${r} to ${n}`);
						Rf.warn(s.message), i.currentTime = n, t.trigger(Tf.ERROR, {
							type: Af.MEDIA_ERROR,
							details: _f.BUFFER_NUDGE_ON_STALL,
							error: s,
							fatal: !1
						})
					} else {
						let i = new Error(`Playhead still not moving while enough data buffered @${r} after ${e.nudgeMaxRetry} nudges`);
						Rf.error(i.message), t.trigger(Tf.ERROR, {
							type: Af.MEDIA_ERROR,
							details: _f.BUFFER_STALLED_ERROR,
							error: i,
							fatal: !0
						})
					}
				}
			}(this.config, i, this.fragmentTracker, this.hls)
		}

		onMediaDetaching() {
			let {media: e} = this;
			e && this.onvplaying && this.onvseeked && (e.removeEventListener("playing", this.onvplaying), e.removeEventListener("seeked", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), super.onMediaDetaching()
		}

		onMediaPlaying() {
			this.tick()
		}

		onMediaSeeked() {
			let e = this.media, t = e ? e.currentTime : null;
			Ef(t) && this.log(`Media seeked to ${t.toFixed(3)}`);
			let i = this.getMainFwdBufferInfo();
			null !== i && 0 !== i.len ? this.tick() : this.warn(`Main forward buffer length on "seeked" event ${i ? i.len : "empty"})`)
		}

		onManifestLoading() {
			this.log("Trigger BUFFER_RESET"), this.hls.trigger(Tf.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = !1, this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0, this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null, this.altAudio = this.audioOnly = this.startFragRequested = !1
		}

		onManifestParsed(e, t) {
			let i = !1, a = !1;
			t.levels.forEach((e => {
				let t = e.audioCodec;
				t && (i = i || -1 !== t.indexOf("mp4a.40.2"), a = a || -1 !== t.indexOf("mp4a.40.5"))
			})), this.audioCodecSwitch = i && a && !function () {
				var e;
				let t = ET();
				return "function" == typeof (null == t || null == (e = t.prototype) ? void 0 : e.changeType)
			}(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = t.levels, this.startFragRequested = !1
		}

		onLevelLoading(e, t) {
			let {levels: i} = this;
			if (!i || this.state !== rE) return;
			let a = i[t.level];
			(!a.details || a.details.live && this.levelLastLoaded !== a || this.waitForCdnTuneIn(a.details)) && (this.state = fE)
		}

		onLevelLoaded(e, t) {
			var i;
			let {levels: a} = this, r = t.level, n = t.details, s = n.totalduration;
			if (!a) return void this.warn(`Levels were reset while loading level ${r}`);
			this.log(`Level ${r} loaded [${n.startSN},${n.endSN}]${n.lastPartSn ? `[part-${n.lastPartSn}-${n.lastPartIndex}]` : ""}, cc [${n.startCC}, ${n.endCC}] duration:${s}`);
			let o = a[r], l = this.fragCurrent;
			l && (this.state === sE || this.state === oE) && l.level !== t.level && l.loader && this.abortCurrentFrag();
			let d = 0;
			if (n.live || null != (i = o.details) && i.live) {
				var u;
				if (this.checkLiveUpdate(n), n.deltaUpdateFailed) return;
				d = this.alignPlaylists(n, o.details, null == (u = this.levelLastLoaded) ? void 0 : u.details)
			}
			if (o.details = n, this.levelLastLoaded = o, this.hls.trigger(Tf.LEVEL_UPDATED, {
				details: n,
				level: r
			}), this.state === fE) {
				if (this.waitForCdnTuneIn(n)) return;
				this.state = rE
			}
			this.startFragRequested ? n.live && this.synchronizeToLiveEdge(n) : this.setStartPosition(n, d), this.tick()
		}

		_handleFragmentLoadProgress(e) {
			var t;
			let {frag: i, part: a, payload: r} = e, {levels: n} = this;
			if (!n) return void this.warn(`Levels were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`);
			let s = n[i.level], o = s.details;
			if (!o) return this.warn(`Dropping fragment ${i.sn} of level ${i.level} after level details were reset`), void this.fragmentTracker.removeFragment(i);
			let l = s.videoCodec, d = o.PTSKnown || !o.live, u = null == (t = i.initSegment) ? void 0 : t.data,
				h = this._getAudioCodec(s),
				c = this.transmuxer = this.transmuxer || new vb(this.hls, wg, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)),
				m = a ? a.index : -1, f = -1 !== m, p = new Kv(i.level, i.sn, i.stats.chunkCount, r.byteLength, m, f),
				g = this.initPTS[i.cc];
			c.push(r, u, h, l, i, a, o.totalduration, d, p, g)
		}

		onAudioTrackSwitching(e, t) {
			let i = this.altAudio;
			if (!t.url) {
				if (this.mediaBuffer !== this.media) {
					this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
					let e = this.fragCurrent;
					e && (this.log("Switching to main audio track, cancel main fragment load"), e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.resetLoadingState()
				} else this.audioOnly && this.resetTransmuxer();
				let e = this.hls;
				i && (e.trigger(Tf.BUFFER_FLUSHING, {
					startOffset: 0,
					endOffset: Number.POSITIVE_INFINITY,
					type: null
				}), this.fragmentTracker.removeAllFragments()), e.trigger(Tf.AUDIO_TRACK_SWITCHED, t)
			}
		}

		onAudioTrackSwitched(e, t) {
			let i = t.id, a = !!this.hls.audioTracks[i].url;
			if (a) {
				let e = this.videoBuffer;
				e && this.mediaBuffer !== e && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = e)
			}
			this.altAudio = a, this.tick()
		}

		onBufferCreated(e, t) {
			let i, a, r = t.tracks, n = !1;
			for (let e in r) {
				let t = r[e];
				if ("main" === t.id) {
					if (a = e, i = t, "video" === e) {
						let t = r[e];
						t && (this.videoBuffer = t.buffer)
					}
				} else n = !0
			}
			n && i ? (this.log(`Alternate track found, use ${a}.buffered to schedule main fragment loading`), this.mediaBuffer = i.buffer) : this.mediaBuffer = this.media
		}

		onFragBuffered(e, t) {
			let {frag: i, part: a} = t;
			if (i && i.type !== wg) return;
			if (this.fragContextChanged(i)) return this.warn(`Fragment ${i.sn}${a ? " p: " + a.index : ""} of level ${i.level} finished buffering, but was aborted. state: ${this.state}`), void (this.state === uE && (this.state = rE));
			let r = a ? a.stats : i.stats;
			this.fragLastKbps = Math.round(8 * r.total / (r.buffering.end - r.loading.first)), "initSegment" !== i.sn && (this.fragPrevious = i), this.fragBufferedComplete(i, a)
		}

		onError(e, t) {
			var i;
			if (t.fatal) this.state = cE; else switch (t.details) {
				case _f.FRAG_GAP:
				case _f.FRAG_PARSING_ERROR:
				case _f.FRAG_DECRYPT_ERROR:
				case _f.FRAG_LOAD_ERROR:
				case _f.FRAG_LOAD_TIMEOUT:
				case _f.KEY_LOAD_ERROR:
				case _f.KEY_LOAD_TIMEOUT:
					this.onFragmentOrKeyLoadError(wg, t);
					break;
				case _f.LEVEL_LOAD_ERROR:
				case _f.LEVEL_LOAD_TIMEOUT:
				case _f.LEVEL_PARSING_ERROR:
					!t.levelRetry && this.state === fE && (null == (i = t.context) ? void 0 : i.type) === _g && (this.state = rE);
					break;
				case _f.BUFFER_APPEND_ERROR:
				case _f.BUFFER_FULL_ERROR:
					if (!t.parent || "main" !== t.parent) return;
					if (t.details === _f.BUFFER_APPEND_ERROR) return void this.resetLoadingState();
					this.reduceLengthAndFlushBuffer(t) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
					break;
				case _f.INTERNAL_EXCEPTION:
					this.recoverWorkerError(t)
			}
		}

		checkBuffer() {
			let {media: e, gapController: t} = this;
			if (e && t && e.readyState) {
				if (this.loadedmetadata || !Vv.getBuffered(e).length) {
					let e = this.state !== rE ? this.fragCurrent : null;
					t.poll(this.lastCurrentTime, e)
				}
				this.lastCurrentTime = e.currentTime
			}
		}

		onFragLoadEmergencyAborted() {
			this.state = rE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate()
		}

		onBufferFlushed(e, {type: t}) {
			if (t !== Nf || this.audioOnly && !this.altAudio) {
				let e = (t === Uf ? this.videoBuffer : this.mediaBuffer) || this.media;
				this.afterBufferFlushed(e, t, wg), this.tick()
			}
		}

		onLevelsUpdated(e, t) {
			this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level), this.levels = t.levels
		}

		swapAudioCodec() {
			this.audioCodecSwap = !this.audioCodecSwap
		}

		seekToStartPos() {
			let {media: e} = this;
			if (!e) return;
			let t = e.currentTime, i = this.startPosition;
			if (i >= 0 && t < i) {
				if (e.seeking) return void this.log(`could not seek to ${i}, already seeking at ${t}`);
				let a = Vv.getBuffered(e), r = (a.length ? a.start(0) : 0) - i;
				r > 0 && (r < this.config.maxBufferHole || r < this.config.maxFragLookUpTolerance) && (this.log(`adjusting start position by ${r} to match buffer start`), i += r, this.startPosition = i), this.log(`seek to target start position ${i} from current time ${t}`), e.currentTime = i
			}
		}

		_getAudioCodec(e) {
			let t = this.config.defaultAudioCodec || e.audioCodec;
			return this.audioCodecSwap && t && (this.log("Swapping audio codec"), t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), t
		}

		_loadBitrateTestFrag(e, t) {
			e.bitrateTest = !0, this._doFragLoad(e, t).then((i => {
				let {hls: a} = this;
				if (!i || this.fragContextChanged(e)) return;
				t.fragmentError = 0, this.state = rE, this.startFragRequested = !1, this.bitrateTest = !1;
				let r = e.stats;
				r.parsing.start = r.parsing.end = r.buffering.start = r.buffering.end = self.performance.now(), a.trigger(Tf.FRAG_LOADED, i), e.bitrateTest = !1
			}))
		}

		_handleTransmuxComplete(e) {
			var t;
			let i = "main", {hls: a} = this, {remuxResult: r, chunkMeta: n} = e, s = this.getCurrentContext(n);
			if (!s) return void this.resetWhenMissingContext(n);
			let {frag: o, part: l, level: d} = s, {video: u, text: h, id3: c, initSegment: m} = r, {details: f} = d,
				p = this.altAudio ? void 0 : r.audio;
			if (this.fragContextChanged(o)) this.fragmentTracker.removeFragment(o); else {
				if (this.state = dE, m) {
					if (null != m && m.tracks) {
						let e = o.initSegment || o;
						this._bufferInitSegment(d, m.tracks, e, n), a.trigger(Tf.FRAG_PARSING_INIT_SEGMENT, {
							frag: e,
							id: i,
							tracks: m.tracks
						})
					}
					let e = m.initPTS, t = m.timescale;
					Ef(e) && (this.initPTS[o.cc] = {baseTime: e, timescale: t}, a.trigger(Tf.INIT_PTS_FOUND, {
						frag: o,
						id: i,
						initPTS: e,
						timescale: t
					}))
				}
				if (u && f && "initSegment" !== o.sn) {
					let e = f.fragments[o.sn - 1 - f.startSN], t = o.sn === f.startSN, i = !e || o.cc > e.cc;
					if (!1 !== r.independent) {
						let {startPTS: e, endPTS: a, startDTS: r, endDTS: s} = u;
						if (l) l.elementaryStreams[u.type] = {
							startPTS: e,
							endPTS: a,
							startDTS: r,
							endDTS: s
						}; else if (u.firstKeyFrame && u.independent && 1 === n.id && !i && (this.couldBacktrack = !0), u.dropped && u.independent) {
							let r = this.getMainFwdBufferInfo(),
								n = (r ? r.end : this.getLoadPosition()) + this.config.maxBufferHole,
								l = u.firstKeyFramePTS ? u.firstKeyFramePTS : e;
							if (!t && n < l - this.config.maxBufferHole && !i) return void this.backtrack(o);
							i && (o.gap = !0), o.setElementaryStreamInfo(u.type, o.start, a, o.start, s, !0)
						} else t && e > 2 && (o.gap = !0);
						o.setElementaryStreamInfo(u.type, e, a, r, s), this.backtrackFragment && (this.backtrackFragment = o), this.bufferFragmentData(u, o, l, n, t || i)
					} else {
						if (!t && !i) return void this.backtrack(o);
						o.gap = !0
					}
				}
				if (p) {
					let {startPTS: e, endPTS: t, startDTS: i, endDTS: a} = p;
					l && (l.elementaryStreams[Nf] = {
						startPTS: e,
						endPTS: t,
						startDTS: i,
						endDTS: a
					}), o.setElementaryStreamInfo(Nf, e, t, i, a), this.bufferFragmentData(p, o, l, n)
				}
				if (f && null != c && null != (t = c.samples) && t.length) {
					let e = {id: i, frag: o, details: f, samples: c.samples};
					a.trigger(Tf.FRAG_PARSING_METADATA, e)
				}
				if (f && h) {
					let e = {id: i, frag: o, details: f, samples: h.samples};
					a.trigger(Tf.FRAG_PARSING_USERDATA, e)
				}
			}
		}

		_bufferInitSegment(e, t, i, a) {
			if (this.state !== dE) return;
			this.audioOnly = !!t.audio && !t.video, this.altAudio && !this.audioOnly && delete t.audio;
			let {audio: r, video: n, audiovideo: s} = t;
			if (r) {
				let t = e.audioCodec, i = navigator.userAgent.toLowerCase();
				this.audioCodecSwitch && (t && (t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), 1 !== r.metadata.channelCount && -1 === i.indexOf("firefox") && (t = "mp4a.40.5")), t && -1 !== t.indexOf("mp4a.40.5") && -1 !== i.indexOf("android") && "audio/mpeg" !== r.container && (t = "mp4a.40.2", this.log(`Android: force audio codec to ${t}`)), e.audioCodec && e.audioCodec !== t && this.log(`Swapping manifest audio codec "${e.audioCodec}" for "${t}"`), r.levelCodec = t, r.id = "main", this.log(`Init audio buffer, container:${r.container}, codecs[selected/level/parsed]=[${t || ""}/${e.audioCodec || ""}/${r.codec}]`)
			}
			n && (n.levelCodec = e.videoCodec, n.id = "main", this.log(`Init video buffer, container:${n.container}, codecs[level/parsed]=[${e.videoCodec || ""}/${n.codec}]`)), s && this.log(`Init audiovideo buffer, container:${s.container}, codecs[level/parsed]=[${e.codecs}/${s.codec}]`), this.hls.trigger(Tf.BUFFER_CODECS, t), Object.keys(t).forEach((e => {
				let r = t[e].initSegment;
				null != r && r.byteLength && this.hls.trigger(Tf.BUFFER_APPENDING, {
					type: e,
					data: r,
					frag: i,
					part: null,
					chunkMeta: a,
					parent: i.type
				})
			})), this.tickImmediate()
		}

		getMainFwdBufferInfo() {
			return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, wg)
		}

		backtrack(e) {
			this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = rE
		}

		checkFragmentChanged() {
			let e = this.media, t = null;
			if (e && e.readyState > 1 && !1 === e.seeking) {
				let i = e.currentTime;
				if (Vv.isBuffered(e, i) ? t = this.getAppendedFrag(i) : Vv.isBuffered(e, i + .1) && (t = this.getAppendedFrag(i + .1)), t) {
					this.backtrackFragment = null;
					let e = this.fragPlaying, i = t.level;
					(!e || t.sn !== e.sn || e.level !== i) && (this.fragPlaying = t, this.hls.trigger(Tf.FRAG_CHANGED, {frag: t}), (!e || e.level !== i) && this.hls.trigger(Tf.LEVEL_SWITCHED, {level: i}))
				}
			}
		}
	}, TT = class e {
		constructor(t = {}) {
			this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this.started = !1, this._emitter = new gb, this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null, this.triggeringException = void 0, function (e, t) {
				if ("object" == typeof console && !0 === e || "object" == typeof e) {
					Lf(e, "debug", "log", "info", "warn", "error");
					try {
						wf.log(`Debug logs enabled for "${t}" in hls.js version 1.5.8`)
					} catch {
						wf = Sf
					}
				} else wf = Sf
			}(t.debug || !1, "Hls instance");
			let i = this.config = function (e, t) {
				if ((t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) && (t.liveSyncDuration || t.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
				if (void 0 !== t.liveMaxLatencyDurationCount && (void 0 === t.liveSyncDurationCount || t.liveMaxLatencyDurationCount <= t.liveSyncDurationCount)) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
				if (void 0 !== t.liveMaxLatencyDuration && (void 0 === t.liveSyncDuration || t.liveMaxLatencyDuration <= t.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
				let i = mT(e), a = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
				return ["manifest", "level", "frag"].forEach((e => {
					let r = `${"level" === e ? "playlist" : e}LoadPolicy`, n = void 0 === t[r], s = [];
					a.forEach((a => {
						let o = `${e}Loading${a}`, l = t[o];
						if (void 0 !== l && n) {
							s.push(o);
							let e = i[r].default;
							switch (t[r] = {default: e}, a) {
								case"TimeOut":
									e.maxLoadTimeMs = l, e.maxTimeToFirstByteMs = l;
									break;
								case"MaxRetry":
									e.errorRetry.maxNumRetry = l, e.timeoutRetry.maxNumRetry = l;
									break;
								case"RetryDelay":
									e.errorRetry.retryDelayMs = l, e.timeoutRetry.retryDelayMs = l;
									break;
								case"MaxRetryTimeout":
									e.errorRetry.maxRetryDelayMs = l, e.timeoutRetry.maxRetryDelayMs = l
							}
						}
					})), s.length && Rf.warn(`hls.js config: "${s.join('", "')}" setting(s) are deprecated, use "${r}": ${JSON.stringify(t[r])}`)
				})), ff(ff({}, i), t)
			}(e.DefaultConfig, t);
			this.userConfig = t, i.progressive && fT(i);
			let {
					abrController: a,
					bufferController: r,
					capLevelController: n,
					errorController: s,
					fpsController: o
				} = i, l = new s(this), d = this.abrController = new a(this), u = this.bufferController = new r(this),
				h = this.capLevelController = new n(this), c = new o(this), m = new class {
					constructor(e) {
						this.hls = void 0, this.loaders = Object.create(null), this.variableList = null, this.hls = e, this.registerListeners()
					}

					startLoad(e) {
					}

					stopLoad() {
						this.destroyInternalLoaders()
					}

					registerListeners() {
						let {hls: e} = this;
						e.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.on(Tf.LEVEL_LOADING, this.onLevelLoading, this), e.on(Tf.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(Tf.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
					}

					unregisterListeners() {
						let {hls: e} = this;
						e.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.off(Tf.LEVEL_LOADING, this.onLevelLoading, this), e.off(Tf.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(Tf.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
					}

					createInternalLoader(e) {
						let t = this.hls.config, i = t.pLoader, a = t.loader, r = new (i || a)(t);
						return this.loaders[e.type] = r, r
					}

					getInternalLoader(e) {
						return this.loaders[e.type]
					}

					resetInternalLoader(e) {
						this.loaders[e] && delete this.loaders[e]
					}

					destroyInternalLoaders() {
						for (let e in this.loaders) {
							let t = this.loaders[e];
							t && t.destroy(), this.resetInternalLoader(e)
						}
					}

					destroy() {
						this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders()
					}

					onManifestLoading(e, t) {
						let {url: i} = t;
						this.variableList = null, this.load({
							id: null,
							level: 0,
							responseType: "text",
							type: Ag,
							url: i,
							deliveryDirectives: null
						})
					}

					onLevelLoading(e, t) {
						let {id: i, level: a, pathwayId: r, url: n, deliveryDirectives: s} = t;
						this.load({
							id: i,
							level: a,
							pathwayId: r,
							responseType: "text",
							type: _g,
							url: n,
							deliveryDirectives: s
						})
					}

					onAudioTrackLoading(e, t) {
						let {id: i, groupId: a, url: r, deliveryDirectives: n} = t;
						this.load({
							id: i,
							groupId: a,
							level: null,
							responseType: "text",
							type: kg,
							url: r,
							deliveryDirectives: n
						})
					}

					onSubtitleTrackLoading(e, t) {
						let {id: i, groupId: a, url: r, deliveryDirectives: n} = t;
						this.load({
							id: i,
							groupId: a,
							level: null,
							responseType: "text",
							type: Sg,
							url: r,
							deliveryDirectives: n
						})
					}

					load(e) {
						var t;
						let i, a = this.hls.config, r = this.getInternalLoader(e);
						if (r) {
							let t = r.context;
							if (t && t.url === e.url && t.level === e.level) return void Rf.trace("[playlist-loader]: playlist request ongoing");
							Rf.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), r.abort()
						}
						if (i = e.type === Ag ? a.manifestLoadPolicy.default : vf({}, a.playlistLoadPolicy.default, {
							timeoutRetry: null,
							errorRetry: null
						}), r = this.createInternalLoader(e), Ef(null == (t = e.deliveryDirectives) ? void 0 : t.part)) {
							let t;
							if (e.type === _g && null !== e.level ? t = this.hls.levels[e.level].details : e.type === kg && null !== e.id ? t = this.hls.audioTracks[e.id].details : e.type === Sg && null !== e.id && (t = this.hls.subtitleTracks[e.id].details), t) {
								let e = t.partTarget, a = t.targetduration;
								if (e && a) {
									let t = 1e3 * Math.max(3 * e, .8 * a);
									i = vf({}, i, {
										maxTimeToFirstByteMs: Math.min(t, i.maxTimeToFirstByteMs),
										maxLoadTimeMs: Math.min(t, i.maxTimeToFirstByteMs)
									})
								}
							}
						}
						let n = i.errorRetry || i.timeoutRetry || {}, s = {
							loadPolicy: i,
							timeout: i.maxLoadTimeMs,
							maxRetry: n.maxNumRetry || 0,
							retryDelay: n.retryDelayMs || 0,
							maxRetryDelay: n.maxRetryDelayMs || 0
						}, o = {
							onSuccess: (e, t, i, a) => {
								let r = this.getInternalLoader(i);
								this.resetInternalLoader(i.type);
								let n = e.data;
								0 === n.indexOf("#EXTM3U") ? (t.parsing.start = performance.now(), fg.isMediaPlaylist(n) ? this.handleTrackOrLevelPlaylist(e, t, i, a || null, r) : this.handleMasterPlaylist(e, t, i, a)) : this.handleManifestParsingError(e, i, new Error("no EXTM3U delimiter"), a || null, t)
							}, onError: (e, t, i, a) => {
								this.handleNetworkError(t, i, !1, e, a)
							}, onTimeout: (e, t, i) => {
								this.handleNetworkError(t, i, !0, void 0, e)
							}
						};
						r.load(e, s, o)
					}

					handleMasterPlaylist(e, t, i, a) {
						let r = this.hls, n = e.data, s = Dg(e, i), o = fg.parseMasterPlaylist(n, s);
						if (o.playlistParsingError) return void this.handleManifestParsingError(e, i, o.playlistParsingError, a, t);
						let {
							contentSteering: l,
							levels: d,
							sessionData: u,
							sessionKeys: h,
							startTimeOffset: c,
							variableList: m
						} = o;
						this.variableList = m;
						let {AUDIO: f = [], SUBTITLES: p, "CLOSED-CAPTIONS": g} = fg.parseMasterPlaylistMedia(n, s, o);
						f.length && !f.some((e => !e.url)) && d[0].audioCodec && !d[0].attrs.AUDIO && (Rf.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), f.unshift({
							type: "main",
							name: "main",
							groupId: "main",
							default: !1,
							autoselect: !1,
							forced: !1,
							id: -1,
							attrs: new Cf({}),
							bitrate: 0,
							url: ""
						})), r.trigger(Tf.MANIFEST_LOADED, {
							levels: d,
							audioTracks: f,
							subtitles: p,
							captions: g,
							contentSteering: l,
							url: s,
							stats: t,
							networkDetails: a,
							sessionData: u,
							sessionKeys: h,
							startTimeOffset: c,
							variableList: m
						})
					}

					handleTrackOrLevelPlaylist(e, t, i, a, r) {
						let n = this.hls, {id: s, level: o, type: l} = i, d = Dg(e, i), u = Ef(o) ? o : Ef(s) ? s : 0,
							h = Ig(i), c = fg.parseLevelPlaylist(e.data, d, u, h, 0, this.variableList);
						if (l === Ag) {
							let e = {attrs: new Cf({}), bitrate: 0, details: c, name: "", url: d};
							n.trigger(Tf.MANIFEST_LOADED, {
								levels: [e],
								audioTracks: [],
								url: d,
								stats: t,
								networkDetails: a,
								sessionData: null,
								sessionKeys: null,
								contentSteering: null,
								startTimeOffset: null,
								variableList: null
							})
						}
						t.parsing.end = performance.now(), i.levelDetails = c, this.handlePlaylistLoaded(c, e, t, i, a, r)
					}

					handleManifestParsingError(e, t, i, a, r) {
						this.hls.trigger(Tf.ERROR, {
							type: Af.NETWORK_ERROR,
							details: _f.MANIFEST_PARSING_ERROR,
							fatal: t.type === Ag,
							url: e.url,
							err: i,
							error: i,
							reason: i.message,
							response: e,
							context: t,
							networkDetails: a,
							stats: r
						})
					}

					handleNetworkError(e, t, i = !1, a, r) {
						let n = `A network ${i ? "timeout" : "error" + (a ? " (status " + a.code + ")" : "")} occurred while loading ${e.type}`;
						e.type === _g ? n += `: ${e.level} id: ${e.id}` : (e.type === kg || e.type === Sg) && (n += ` id: ${e.id} group-id: "${e.groupId}"`);
						let s = new Error(n);
						Rf.warn(`[playlist-loader]: ${n}`);
						let o = _f.UNKNOWN, l = !1, d = this.getInternalLoader(e);
						switch (e.type) {
							case Ag:
								o = i ? _f.MANIFEST_LOAD_TIMEOUT : _f.MANIFEST_LOAD_ERROR, l = !0;
								break;
							case _g:
								o = i ? _f.LEVEL_LOAD_TIMEOUT : _f.LEVEL_LOAD_ERROR, l = !1;
								break;
							case kg:
								o = i ? _f.AUDIO_TRACK_LOAD_TIMEOUT : _f.AUDIO_TRACK_LOAD_ERROR, l = !1;
								break;
							case Sg:
								o = i ? _f.SUBTITLE_TRACK_LOAD_TIMEOUT : _f.SUBTITLE_LOAD_ERROR, l = !1
						}
						d && this.resetInternalLoader(e.type);
						let u = {
							type: Af.NETWORK_ERROR,
							details: o,
							fatal: l,
							url: e.url,
							loader: d,
							context: e,
							error: s,
							networkDetails: t,
							stats: r
						};
						if (a) {
							let i = (null == t ? void 0 : t.url) || e.url;
							u.response = ff({url: i, data: void 0}, a)
						}
						this.hls.trigger(Tf.ERROR, u)
					}

					handlePlaylistLoaded(e, t, i, a, r, n) {
						let s = this.hls, {type: o, level: l, id: d, groupId: u, deliveryDirectives: h} = a, c = Dg(t, a),
							m = Ig(a), f = "number" == typeof a.level && m === wg ? l : void 0;
						if (!e.fragments.length) {
							let e = new Error("No Segments found in Playlist");
							return void s.trigger(Tf.ERROR, {
								type: Af.NETWORK_ERROR,
								details: _f.LEVEL_EMPTY_ERROR,
								fatal: !1,
								url: c,
								error: e,
								reason: e.message,
								response: t,
								context: a,
								level: f,
								parent: m,
								networkDetails: r,
								stats: i
							})
						}
						e.targetduration || (e.playlistParsingError = new Error("Missing Target Duration"));
						let p = e.playlistParsingError;
						if (p) s.trigger(Tf.ERROR, {
							type: Af.NETWORK_ERROR,
							details: _f.LEVEL_PARSING_ERROR,
							fatal: !1,
							url: c,
							error: p,
							reason: p.message,
							response: t,
							context: a,
							level: f,
							parent: m,
							networkDetails: r,
							stats: i
						}); else switch (e.live && n && (n.getCacheAge && (e.ageHeader = n.getCacheAge() || 0), (!n.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)), o) {
							case Ag:
							case _g:
								s.trigger(Tf.LEVEL_LOADED, {
									details: e,
									level: f || 0,
									id: d || 0,
									stats: i,
									networkDetails: r,
									deliveryDirectives: h
								});
								break;
							case kg:
								s.trigger(Tf.AUDIO_TRACK_LOADED, {
									details: e,
									id: d || 0,
									groupId: u || "",
									stats: i,
									networkDetails: r,
									deliveryDirectives: h
								});
								break;
							case Sg:
								s.trigger(Tf.SUBTITLE_TRACK_LOADED, {
									details: e,
									id: d || 0,
									groupId: u || "",
									stats: i,
									networkDetails: r,
									deliveryDirectives: h
								})
						}
					}
				}(this), f = new class {
					constructor(e) {
						this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = e, this._registerListeners()
					}

					destroy() {
						this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null
					}

					_registerListeners() {
						let {hls: e} = this;
						e.on(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.on(Tf.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(Tf.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(Tf.LEVEL_UPDATED, this.onLevelUpdated, this)
					}

					_unregisterListeners() {
						let {hls: e} = this;
						e.off(Tf.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(Tf.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(Tf.MANIFEST_LOADING, this.onManifestLoading, this), e.off(Tf.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(Tf.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(Tf.LEVEL_UPDATED, this.onLevelUpdated, this)
					}

					onMediaAttached(e, t) {
						this.media = t.media
					}

					onMediaDetaching() {
						this.id3Track && (Mg(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {})
					}

					onManifestLoading() {
						this.dateRangeCuesAppended = {}
					}

					createTrack(e) {
						let t = this.getID3Track(e.textTracks);
						return t.mode = "hidden", t
					}

					getID3Track(e) {
						if (this.media) {
							for (let t = 0; t < e.length; t++) {
								let i = e[t];
								if ("metadata" === i.kind && "id3" === i.label) return Cg(i, this.media), i
							}
							return this.media.addTextTrack("metadata", "id3")
						}
					}

					onFragParsingMetadata(e, t) {
						if (!this.media) return;
						let {hls: {config: {enableEmsgMetadataCues: i, enableID3MetadataCues: a}}} = this;
						if (!i && !a) return;
						let {samples: r} = t;
						this.id3Track || (this.id3Track = this.createTrack(this.media));
						let n = Bg();
						if (n) for (let e = 0; e < r.length; e++) {
							let t = r[e].type;
							if (t === Fg && !i || !a) continue;
							let s = cp(r[e].data);
							if (s) {
								let i = r[e].pts, a = i + r[e].duration;
								a > Hg && (a = Hg), a - i <= 0 && (a = i + .25);
								for (let e = 0; e < s.length; e++) {
									let r = s[e];
									if (!up(r)) {
										this.updateId3CueEnds(i, t);
										let e = $g(n, i, a, r, t);
										e && this.id3Track.addCue(e)
									}
								}
							}
						}
					}

					updateId3CueEnds(e, t) {
						var i;
						let a = null == (i = this.id3Track) ? void 0 : i.cues;
						if (a) for (let i = a.length; i--;) {
							let r = a[i];
							r.type === t && r.startTime < e && r.endTime === Hg && (r.endTime = e)
						}
					}

					onBufferFlushing(e, {startOffset: t, endOffset: i, type: a}) {
						let {id3Track: r, hls: n} = this;
						if (!n) return;
						let {config: {enableEmsgMetadataCues: s, enableID3MetadataCues: o}} = n;
						if (r && (s || o)) {
							let e;
							e = "audio" === a ? e => e.type === Ng && o : "video" === a ? e => e.type === Fg && s : e => e.type === Ng && o || e.type === Fg && s, Og(r, t, i, e)
						}
					}

					onLevelUpdated(e, {details: t}) {
						if (!this.media || !t.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) return;
						let {dateRangeCuesAppended: i, id3Track: a} = this, {dateRanges: r} = t, n = Object.keys(r);
						if (a) {
							let e = Object.keys(i).filter((e => !n.includes(e)));
							for (let t = e.length; t--;) {
								let r = e[t];
								Object.keys(i[r].cues).forEach((e => {
									a.removeCue(i[r].cues[e])
								})), delete i[r]
							}
						}
						let s = t.fragments[t.fragments.length - 1];
						if (0 === n.length || !Ef(null == s ? void 0 : s.programDateTime)) return;
						this.id3Track || (this.id3Track = this.createTrack(this.media));
						let o = s.programDateTime / 1e3 - s.start, l = Bg();
						for (let e = 0; e < n.length; e++) {
							let t = n[e], a = r[t], s = Wg(a.startDate, o), d = i[t],
								u = (null == d ? void 0 : d.cues) || {}, h = (null == d ? void 0 : d.durationKnown) || !1,
								c = Hg, m = a.endDate;
							if (m) c = Wg(m, o), h = !0; else if (a.endOnNext && !h) {
								let e = n.reduce(((e, t) => {
									if (t !== a.id) {
										let i = r[t];
										if (i.class === a.class && i.startDate > a.startDate && (!e || a.startDate < e.startDate)) return i
									}
									return e
								}), null);
								e && (c = Wg(e.startDate, o), h = !0)
							}
							let f = Object.keys(a.attr);
							for (let e = 0; e < f.length; e++) {
								let i = f[e];
								if (!xf(i)) continue;
								let r = u[i];
								if (r) h && !d.durationKnown && (r.endTime = c); else if (l) {
									let e = a.attr[i];
									Mf(i) && (e = Gg(e));
									let r = $g(l, s, c, {key: i, data: e}, Ug);
									r && (r.id = t, this.id3Track.addCue(r), u[i] = r)
								}
							}
							i[t] = {cues: u, dateRange: a, durationKnown: h}
						}
					}
				}(this), p = i.contentSteeringController, g = p ? new p(this) : null,
				v = this.levelController = new gT(this, g), E = new class {
					constructor(e) {
						this.activePartLists = Object.create(null), this.endListFragments = Object.create(null), this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners()
					}

					_registerListeners() {
						let {hls: e} = this;
						e.on(Tf.BUFFER_APPENDED, this.onBufferAppended, this), e.on(Tf.FRAG_BUFFERED, this.onFragBuffered, this), e.on(Tf.FRAG_LOADED, this.onFragLoaded, this)
					}

					_unregisterListeners() {
						let {hls: e} = this;
						e.off(Tf.BUFFER_APPENDED, this.onBufferAppended, this), e.off(Tf.FRAG_BUFFERED, this.onFragBuffered, this), e.off(Tf.FRAG_LOADED, this.onFragLoaded, this)
					}

					destroy() {
						this._unregisterListeners(), this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null
					}

					getAppendedFrag(e, t) {
						let i = this.activePartLists[t];
						if (i) for (let t = i.length; t--;) {
							let a = i[t];
							if (!a) break;
							let r = a.end;
							if (a.start <= e && null !== r && e <= r) return a
						}
						return this.getBufferedFrag(e, t)
					}

					getBufferedFrag(e, t) {
						let {fragments: i} = this, a = Object.keys(i);
						for (let r = a.length; r--;) {
							let n = i[a[r]];
							if ((null == n ? void 0 : n.body.type) === t && n.buffered) {
								let t = n.body;
								if (t.start <= e && e <= t.end) return t
							}
						}
						return null
					}

					detectEvictedFragments(e, t, i, a) {
						this.timeRanges && (this.timeRanges[e] = t);
						let r = (null == a ? void 0 : a.fragment.sn) || -1;
						Object.keys(this.fragments).forEach((a => {
							let n = this.fragments[a];
							if (!n || r >= n.body.sn) return;
							if (!n.buffered && !n.loaded) return void (n.body.type === i && this.removeFragment(n.body));
							let s = n.range[e];
							s && s.time.some((e => {
								let i = !this.isTimeBuffered(e.startPTS, e.endPTS, t);
								return i && this.removeFragment(n.body), i
							}))
						}))
					}

					detectPartialFragments(e) {
						let t = this.timeRanges, {frag: i, part: a} = e;
						if (!t || "initSegment" === i.sn) return;
						let r = Wv(i), n = this.fragments[r];
						if (!n || n.buffered && i.gap) return;
						let s = !i.relurl;
						Object.keys(t).forEach((e => {
							let r = i.elementaryStreams[e];
							if (!r) return;
							let o = t[e], l = s || !0 === r.partial;
							n.range[e] = this.getBufferedTimes(i, a, l, o)
						})), n.loaded = null, Object.keys(n.range).length ? (n.buffered = !0, (n.body.endList = i.endList || n.body.endList) && (this.endListFragments[n.body.type] = n), Hv(n) || this.removeParts(i.sn - 1, i.type)) : this.removeFragment(n.body)
					}

					removeParts(e, t) {
						let i = this.activePartLists[t];
						i && (this.activePartLists[t] = i.filter((t => t.fragment.sn >= e)))
					}

					fragBuffered(e, t) {
						let i = Wv(e), a = this.fragments[i];
						!a && t && (a = this.fragments[i] = {
							body: e,
							appendedPTS: null,
							loaded: null,
							buffered: !1,
							range: Object.create(null)
						}, e.gap && (this.hasGaps = !0)), a && (a.loaded = null, a.buffered = !0)
					}

					getBufferedTimes(e, t, i, a) {
						let r = {time: [], partial: i}, n = e.start, s = e.end, o = e.minEndPTS || s,
							l = e.maxStartPTS || n;
						for (let e = 0; e < a.length; e++) {
							let t = a.start(e) - this.bufferPadding, i = a.end(e) + this.bufferPadding;
							if (l >= t && o <= i) {
								r.time.push({startPTS: Math.max(n, a.start(e)), endPTS: Math.min(s, a.end(e))});
								break
							}
							if (n < i && s > t) {
								let t = Math.max(n, a.start(e)), i = Math.min(s, a.end(e));
								i > t && (r.partial = !0, r.time.push({startPTS: t, endPTS: i}))
							} else if (s <= t) break
						}
						return r
					}

					getPartialFragment(e) {
						let t, i, a, r = null, n = 0, {bufferPadding: s, fragments: o} = this;
						return Object.keys(o).forEach((l => {
							let d = o[l];
							d && Hv(d) && (i = d.body.start - s, a = d.body.end + s, e >= i && e <= a && (t = Math.min(e - i, a - e), n <= t && (r = d.body, n = t)))
						})), r
					}

					isEndListAppended(e) {
						let t = this.endListFragments[e];
						return void 0 !== t && (t.buffered || Hv(t))
					}

					getState(e) {
						let t = Wv(e), i = this.fragments[t];
						return i ? i.buffered ? Hv(i) ? Bv : $v : Fv : Uv
					}

					isTimeBuffered(e, t, i) {
						let a, r;
						for (let n = 0; n < i.length; n++) {
							if (a = i.start(n) - this.bufferPadding, r = i.end(n) + this.bufferPadding, e >= a && t <= r) return !0;
							if (t <= a) return !1
						}
						return !1
					}

					onFragLoaded(e, t) {
						let {frag: i, part: a} = t;
						if ("initSegment" === i.sn || i.bitrateTest) return;
						let r = a ? null : t, n = Wv(i);
						this.fragments[n] = {
							body: i,
							appendedPTS: null,
							loaded: r,
							buffered: !1,
							range: Object.create(null)
						}
					}

					onBufferAppended(e, t) {
						let {frag: i, part: a, timeRanges: r} = t;
						if ("initSegment" === i.sn) return;
						let n = i.type;
						if (a) {
							let e = this.activePartLists[n];
							e || (this.activePartLists[n] = e = []), e.push(a)
						}
						this.timeRanges = r, Object.keys(r).forEach((e => {
							let t = r[e];
							this.detectEvictedFragments(e, t, n, a)
						}))
					}

					onFragBuffered(e, t) {
						this.detectPartialFragments(t)
					}

					hasFragment(e) {
						let t = Wv(e);
						return !!this.fragments[t]
					}

					hasParts(e) {
						var t;
						return !(null == (t = this.activePartLists[e]) || !t.length)
					}

					removeFragmentsInRange(e, t, i, a, r) {
						a && !this.hasGaps || Object.keys(this.fragments).forEach((n => {
							let s = this.fragments[n];
							if (!s) return;
							let o = s.body;
							o.type !== i || a && !o.gap || o.start < t && o.end > e && (s.buffered || r) && this.removeFragment(o)
						}))
					}

					removeFragment(e) {
						let t = Wv(e);
						e.stats.loaded = 0, e.clearElementaryStreamInfo();
						let i = this.activePartLists[e.type];
						if (i) {
							let t = e.sn;
							this.activePartLists[e.type] = i.filter((e => e.fragment.sn !== t))
						}
						delete this.fragments[t], e.endList && delete this.endListFragments[e.type]
					}

					removeAllFragments() {
						this.fragments = Object.create(null), this.endListFragments = Object.create(null), this.activePartLists = Object.create(null), this.hasGaps = !1
					}
				}(this), b = new class {
					constructor(e) {
						this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = e
					}

					abort(e) {
						for (let i in this.keyUriToKeyInfo) {
							let a = this.keyUriToKeyInfo[i].loader;
							if (a) {
								var t;
								if (e && e !== (null == (t = a.context) ? void 0 : t.frag.type)) return;
								a.abort()
							}
						}
					}

					detach() {
						for (let e in this.keyUriToKeyInfo) {
							let t = this.keyUriToKeyInfo[e];
							(t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[e]
						}
					}

					destroy() {
						this.detach();
						for (let e in this.keyUriToKeyInfo) {
							let t = this.keyUriToKeyInfo[e].loader;
							t && t.destroy()
						}
						this.keyUriToKeyInfo = {}
					}

					createKeyLoadError(e, t = _f.KEY_LOAD_ERROR, i, a, r) {
						return new eE({
							type: Af.NETWORK_ERROR,
							details: t,
							fatal: !1,
							frag: e,
							response: r,
							error: i,
							networkDetails: a
						})
					}

					loadClear(e, t) {
						if (this.emeController && this.config.emeEnabled) {
							let {sn: i, cc: a} = e;
							for (let e = 0; e < t.length; e++) {
								let r = t[e];
								if (a <= r.cc && ("initSegment" === i || "initSegment" === r.sn || i < r.sn)) {
									this.emeController.selectKeySystemFormat(r).then((e => {
										r.setKeyFormat(e)
									}));
									break
								}
							}
						}
					}

					load(e) {
						return !e.decryptdata && e.encrypted && this.emeController ? this.emeController.selectKeySystemFormat(e).then((t => this.loadInternal(e, t))) : this.loadInternal(e)
					}

					loadInternal(e, t) {
						var i, a;
						t && e.setKeyFormat(t);
						let r = e.decryptdata;
						if (!r) {
							let i = new Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : "Missing decryption data on fragment in onKeyLoading");
							return Promise.reject(this.createKeyLoadError(e, _f.KEY_LOAD_ERROR, i))
						}
						let n = r.uri;
						if (!n) return Promise.reject(this.createKeyLoadError(e, _f.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${n}"`)));
						let s = this.keyUriToKeyInfo[n];
						if (null != (i = s) && i.decryptdata.key) return r.key = s.decryptdata.key, Promise.resolve({
							frag: e,
							keyInfo: s
						});
						var o;
						if (null != (a = s) && a.keyLoadPromise) switch (null == (o = s.mediaKeySessionContext) ? void 0 : o.keyStatus) {
							case void 0:
							case"status-pending":
							case"usable":
							case"usable-in-future":
								return s.keyLoadPromise.then((t => (r.key = t.keyInfo.decryptdata.key, {
									frag: e,
									keyInfo: s
								})))
						}
						switch (s = this.keyUriToKeyInfo[n] = {
							decryptdata: r,
							keyLoadPromise: null,
							loader: null,
							mediaKeySessionContext: null
						}, r.method) {
							case"ISO-23001-7":
							case"SAMPLE-AES":
							case"SAMPLE-AES-CENC":
							case"SAMPLE-AES-CTR":
								return "identity" === r.keyFormat ? this.loadKeyHTTP(s, e) : this.loadKeyEME(s, e);
							case"AES-128":
								return this.loadKeyHTTP(s, e);
							default:
								return Promise.reject(this.createKeyLoadError(e, _f.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${r.method}"`)))
						}
					}

					loadKeyEME(e, t) {
						let i = {frag: t, keyInfo: e};
						if (this.emeController && this.config.emeEnabled) {
							let t = this.emeController.loadKey(i);
							if (t) return (e.keyLoadPromise = t.then((t => (e.mediaKeySessionContext = t, i)))).catch((t => {
								throw e.keyLoadPromise = null, t
							}))
						}
						return Promise.resolve(i)
					}

					loadKeyHTTP(e, t) {
						let i = this.config, a = new (0, i.loader)(i);
						return t.keyLoader = e.loader = a, e.keyLoadPromise = new Promise(((r, n) => {
							let s = {keyInfo: e, frag: t, responseType: "arraybuffer", url: e.decryptdata.uri},
								o = i.keyLoadPolicy.default,
								l = {loadPolicy: o, timeout: o.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0},
								d = {
									onSuccess: (e, t, i, a) => {
										let {frag: s, keyInfo: o, url: l} = i;
										if (!s.decryptdata || o !== this.keyUriToKeyInfo[l]) return n(this.createKeyLoadError(s, _f.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), a));
										o.decryptdata.key = s.decryptdata.key = new Uint8Array(e.data), s.keyLoader = null, o.loader = null, r({
											frag: s,
											keyInfo: o
										})
									}, onError: (e, i, a, r) => {
										this.resetLoader(i), n(this.createKeyLoadError(t, _f.KEY_LOAD_ERROR, new Error(`HTTP Error ${e.code} loading key ${e.text}`), a, ff({
											url: s.url,
											data: void 0
										}, e)))
									}, onTimeout: (e, i, a) => {
										this.resetLoader(i), n(this.createKeyLoadError(t, _f.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), a))
									}, onAbort: (e, i, a) => {
										this.resetLoader(i), n(this.createKeyLoadError(t, _f.INTERNAL_ABORTED, new Error("key loading aborted"), a))
									}
								};
							a.load(s, l, d)
						}))
					}

					resetLoader(e) {
						let {frag: t, keyInfo: i, url: a} = e, r = i.loader;
						t.keyLoader === r && (t.keyLoader = null, i.loader = null), delete this.keyUriToKeyInfo[a], r && r.destroy()
					}
				}(this.config), y = this.streamController = new yT(this, E, b);
			h.setStreamController(y), c.setStreamController(y);
			let T = [m, v, y];
			g && T.splice(1, 0, g), this.networkControllers = T;
			let A = [d, u, h, c, f, E];
			this.audioTrackController = this.createController(i.audioTrackController, T);
			let _ = i.audioStreamController;
			_ && T.push(new _(this, E, b)), this.subtitleTrackController = this.createController(i.subtitleTrackController, T);
			let k = i.subtitleStreamController;
			k && T.push(new k(this, E, b)), this.createController(i.timelineController, A), b.emeController = this.emeController = this.createController(i.emeController, A), this.cmcdController = this.createController(i.cmcdController, A), this.latencyController = this.createController(Vg, A), this.coreComponents = A, T.push(l);
			let S = l.onErrorOut;
			"function" == typeof S && this.on(Tf.ERROR, S, l)
		}

		static get version() {
			return "1.5.8"
		}

		static get Events() {
			return Tf
		}

		static get ErrorTypes() {
			return Af
		}

		static get ErrorDetails() {
			return _f
		}

		static get DefaultConfig() {
			return e.defaultConfig ? e.defaultConfig : cT
		}

		static set DefaultConfig(t) {
			e.defaultConfig = t
		}

		get levels() {
			return this.levelController.levels || []
		}

		get currentLevel() {
			return this.streamController.currentLevel
		}

		set currentLevel(e) {
			Rf.log(`set currentLevel:${e}`), this.levelController.manualLevel = e, this.streamController.immediateLevelSwitch()
		}

		get nextLevel() {
			return this.streamController.nextLevel
		}

		set nextLevel(e) {
			Rf.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch()
		}

		get loadLevel() {
			return this.levelController.level
		}

		set loadLevel(e) {
			Rf.log(`set loadLevel:${e}`), this.levelController.manualLevel = e
		}

		get nextLoadLevel() {
			return this.levelController.nextLoadLevel
		}

		set nextLoadLevel(e) {
			this.levelController.nextLoadLevel = e
		}

		get firstLevel() {
			return Math.max(this.levelController.firstLevel, this.minAutoLevel)
		}

		set firstLevel(e) {
			Rf.log(`set firstLevel:${e}`), this.levelController.firstLevel = e
		}

		get startLevel() {
			let e = this.levelController.startLevel;
			return -1 === e && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : e
		}

		set startLevel(e) {
			Rf.log(`set startLevel:${e}`), -1 !== e && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e
		}

		get capLevelToPlayerSize() {
			return this.config.capLevelToPlayerSize
		}

		set capLevelToPlayerSize(e) {
			let t = !!e;
			t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t)
		}

		get autoLevelCapping() {
			return this._autoLevelCapping
		}

		set autoLevelCapping(e) {
			this._autoLevelCapping !== e && (Rf.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e, this.levelController.checkMaxAutoUpdated())
		}

		get bandwidthEstimate() {
			let {bwEstimator: e} = this.abrController;
			return e ? e.getEstimate() : NaN
		}

		set bandwidthEstimate(e) {
			this.abrController.resetEstimator(e)
		}

		get ttfbEstimate() {
			let {bwEstimator: e} = this.abrController;
			return e ? e.getEstimateTTFB() : NaN
		}

		get maxHdcpLevel() {
			return this._maxHdcpLevel
		}

		set maxHdcpLevel(e) {
			(function (e) {
				return Kg.indexOf(e) > -1
			})(e) && this._maxHdcpLevel !== e && (this._maxHdcpLevel = e, this.levelController.checkMaxAutoUpdated())
		}

		get autoLevelEnabled() {
			return -1 === this.levelController.manualLevel
		}

		get manualLevel() {
			return this.levelController.manualLevel
		}

		get minAutoLevel() {
			let {levels: e, config: {minAutoBitrate: t}} = this;
			if (!e) return 0;
			let i = e.length;
			for (let a = 0; a < i; a++) if (e[a].maxBitrate >= t) return a;
			return 0
		}

		get maxAutoLevel() {
			let e, {levels: t, autoLevelCapping: i, maxHdcpLevel: a} = this;
			if (e = -1 === i && null != t && t.length ? t.length - 1 : i, a) for (let i = e; i--;) {
				let e = t[i].attrs["HDCP-LEVEL"];
				if (e && e <= a) return i
			}
			return e
		}

		get firstAutoLevel() {
			return this.abrController.firstAutoLevel
		}

		get nextAutoLevel() {
			return this.abrController.nextAutoLevel
		}

		set nextAutoLevel(e) {
			this.abrController.nextAutoLevel = e
		}

		get playingDate() {
			return this.streamController.currentProgramDateTime
		}

		get mainForwardBufferInfo() {
			return this.streamController.getMainFwdBufferInfo()
		}

		get allAudioTracks() {
			let e = this.audioTrackController;
			return e ? e.allAudioTracks : []
		}

		get audioTracks() {
			let e = this.audioTrackController;
			return e ? e.audioTracks : []
		}

		get audioTrack() {
			let e = this.audioTrackController;
			return e ? e.audioTrack : -1
		}

		set audioTrack(e) {
			let t = this.audioTrackController;
			t && (t.audioTrack = e)
		}

		get allSubtitleTracks() {
			let e = this.subtitleTrackController;
			return e ? e.allSubtitleTracks : []
		}

		get subtitleTracks() {
			let e = this.subtitleTrackController;
			return e ? e.subtitleTracks : []
		}

		get subtitleTrack() {
			let e = this.subtitleTrackController;
			return e ? e.subtitleTrack : -1
		}

		set subtitleTrack(e) {
			let t = this.subtitleTrackController;
			t && (t.subtitleTrack = e)
		}

		get media() {
			return this._media
		}

		get subtitleDisplay() {
			let e = this.subtitleTrackController;
			return !!e && e.subtitleDisplay
		}

		set subtitleDisplay(e) {
			let t = this.subtitleTrackController;
			t && (t.subtitleDisplay = e)
		}

		get lowLatencyMode() {
			return this.config.lowLatencyMode
		}

		set lowLatencyMode(e) {
			this.config.lowLatencyMode = e
		}

		get liveSyncPosition() {
			return this.latencyController.liveSyncPosition
		}

		get latency() {
			return this.latencyController.latency
		}

		get maxLatency() {
			return this.latencyController.maxLatency
		}

		get targetLatency() {
			return this.latencyController.targetLatency
		}

		get drift() {
			return this.latencyController.drift
		}

		get forceStartLoad() {
			return this.streamController.forceStartLoad
		}

		static isMSESupported() {
			return bT()
		}

		static isSupported() {
			return function () {
				if (!bT()) return !1;
				let e = Zp();
				return "function" == typeof (null == e ? void 0 : e.isTypeSupported) && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some((t => e.isTypeSupported(ig(t, "video")))) || ["mp4a.40.2", "fLaC"].some((t => e.isTypeSupported(ig(t, "audio")))))
			}()
		}

		static getMediaSource() {
			return Zp()
		}

		createController(e, t) {
			if (e) {
				let i = new e(this);
				return t && t.push(i), i
			}
			return null
		}

		on(e, t, i = this) {
			this._emitter.on(e, t, i)
		}

		once(e, t, i = this) {
			this._emitter.once(e, t, i)
		}

		removeAllListeners(e) {
			this._emitter.removeAllListeners(e)
		}

		off(e, t, i = this, a) {
			this._emitter.off(e, t, i, a)
		}

		listeners(e) {
			return this._emitter.listeners(e)
		}

		emit(e, t, i) {
			return this._emitter.emit(e, t, i)
		}

		trigger(e, t) {
			if (this.config.debug) return this.emit(e, e, t);
			try {
				return this.emit(e, e, t)
			} catch (t) {
				if (Rf.error("An internal error happened while handling event " + e + '. Error message: "' + t.message + '". Here is a stacktrace:', t), !this.triggeringException) {
					this.triggeringException = !0;
					let i = e === Tf.ERROR;
					this.trigger(Tf.ERROR, {
						type: Af.OTHER_ERROR,
						details: _f.INTERNAL_EXCEPTION,
						fatal: i,
						event: e,
						error: t
					}), this.triggeringException = !1
				}
			}
			return !1
		}

		listenerCount(e) {
			return this._emitter.listenerCount(e)
		}

		destroy() {
			Rf.log("destroy"), this.trigger(Tf.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach((e => e.destroy())), this.networkControllers.length = 0, this.coreComponents.forEach((e => e.destroy())), this.coreComponents.length = 0;
			let e = this.config;
			e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null
		}

		attachMedia(e) {
			Rf.log("attachMedia"), this._media = e, this.trigger(Tf.MEDIA_ATTACHING, {media: e})
		}

		detachMedia() {
			Rf.log("detachMedia"), this.trigger(Tf.MEDIA_DETACHING, void 0), this._media = null
		}

		loadSource(e) {
			this.stopLoad();
			let t = this.media, i = this.url,
				a = this.url = cf.buildAbsoluteURL(self.location.href, e, {alwaysNormalize: !0});
			this._autoLevelCapping = -1, this._maxHdcpLevel = null, Rf.log(`loadSource:${a}`), t && i && (i !== a || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(t)), this.trigger(Tf.MANIFEST_LOADING, {url: e})
		}

		startLoad(e = -1) {
			Rf.log(`startLoad(${e})`), this.started = !0, this.networkControllers.forEach((t => {
				t.startLoad(e)
			}))
		}

		stopLoad() {
			Rf.log("stopLoad"), this.started = !1, this.networkControllers.forEach((e => {
				e.stopLoad()
			}))
		}

		resumeBuffering() {
			this.started && this.networkControllers.forEach((e => {
				"fragmentLoader" in e && e.startLoad(-1)
			}))
		}

		pauseBuffering() {
			this.networkControllers.forEach((e => {
				"fragmentLoader" in e && e.stopLoad()
			}))
		}

		swapAudioCodec() {
			Rf.log("swapAudioCodec"), this.streamController.swapAudioCodec()
		}

		recoverMediaError() {
			Rf.log("recoverMediaError");
			let e = this._media;
			this.detachMedia(), e && this.attachMedia(e)
		}

		removeLevel(e) {
			this.levelController.removeLevel(e)
		}

		setAudioOption(e) {
			var t;
			return null == (t = this.audioTrackController) ? void 0 : t.setAudioOption(e)
		}

		setSubtitleOption(e) {
			var t;
			return null == (t = this.subtitleTrackController) || t.setSubtitleOption(e), null
		}
	};
	TT.defaultConfig = void 0;
	var AT = TT, _T = class e extends Error {
		constructor(t, i = e.MEDIA_ERR_CUSTOM, a, r) {
			var n;
			super(t), this.name = "MediaError", this.code = i, this.context = r, this.fatal = null != a ? a : i >= e.MEDIA_ERR_NETWORK && i <= e.MEDIA_ERR_ENCRYPTED, this.message || (this.message = null != (n = e.defaultMessages[this.code]) ? n : "")
		}
	};
	_T.MEDIA_ERR_ABORTED = 1, _T.MEDIA_ERR_NETWORK = 2, _T.MEDIA_ERR_DECODE = 3, _T.MEDIA_ERR_SRC_NOT_SUPPORTED = 4, _T.MEDIA_ERR_ENCRYPTED = 5, _T.MEDIA_ERR_CUSTOM = 100, _T.defaultMessages = {
		1: "You aborted the media playback",
		2: "A network error caused the media download to fail.",
		3: "A media error caused playback to be aborted. The media could be corrupt or your browser does not support this format.",
		4: "An unsupported error occurred. The server or network failed, or your browser does not support this format.",
		5: "The media is encrypted and there are no keys to decrypt it."
	};
	var kT = _T, ST = (e, t) => !(e => null == e)(t) && e in t, wT = {ANY: "any", MUTED: "muted"},
		LT = {ON_DEMAND: "on-demand", LIVE: "live", UNKNOWN: "unknown"}, RT = "mse", IT = "native",
		DT = {HEADER: "header", QUERY: "query", NONE: "none"}, CT = Object.values(DT),
		xT = {M3U8: "application/vnd.apple.mpegurl", MP4: "video/mp4"}, MT = {HLS: xT.M3U8},
		OT = (Object.keys(MT), Object.values(xT), (e, t, i, a, r = e) => {
			r.addEventListener(t, i, a), e.addEventListener("teardown", (() => {
				r.removeEventListener(t, i)
			}), {once: !0})
		});
	var PT = e => {
			let t = e.type;
			if (t) {
				let e = t.toUpperCase();
				return ST(e, MT) ? MT[e] : t
			}
			let {src: i} = e;
			return i ? FT(i) : ""
		}, NT = e => "VOD" === e ? LT.ON_DEMAND : LT.LIVE,
		UT = e => "EVENT" === e ? Number.POSITIVE_INFINITY : "VOD" === e ? Number.NaN : 0, FT = e => {
			let t = "";
			try {
				t = new URL(e).pathname
			} catch {
				console.error("invalid url")
			}
			let i = t.lastIndexOf(".");
			if (i < 0) return "";
			let a = t.slice(i + 1).toUpperCase();
			return ST(a, xT) ? xT[a] : ""
		}, BT = Object.values(wT), $T = e => "boolean" == typeof e || "string" == typeof e && BT.includes(e),
		HT = (e, t) => {
			if (!t) return;
			let i = e.muted, a = () => e.muted = i;
			switch (t) {
				case wT.ANY:
					e.play().catch((() => {
						e.muted = !0, e.play().catch(a)
					}));
					break;
				case wT.MUTED:
					e.muted = !0, e.play().catch(a);
					break;
				default:
					e.play().catch((() => {
					}))
			}
		};

	function WT(e, t) {
		var i;
		if (!("videoTracks" in e)) return;
		let a = new WeakMap;
		t.on(AT.Events.MANIFEST_PARSED, (function (t, i) {
			s();
			let r = e.addVideoTrack("main");
			r.selected = !0;
			for (let [e, t] of i.levels.entries()) {
				let i = r.addRendition(t.url[0], t.width, t.height, t.videoCodec, t.bitrate);
				a.set(t, `${e}`), i.id = `${e}`
			}
		})), t.on(AT.Events.AUDIO_TRACKS_UPDATED, (function (t, i) {
			n();
			for (let t of i.audioTracks) {
				let i = t.default ? "main" : "alternative", a = e.addAudioTrack(i, t.name, t.lang);
				a.id = `${t.id}`, t.default && (a.enabled = !0)
			}
		})), e.audioTracks.addEventListener("change", (() => {
			var i;
			let a = +(null == (i = [...e.audioTracks].find((e => e.enabled))) ? void 0 : i.id),
				r = t.audioTracks.map((e => e.id));
			a != t.audioTrack && r.includes(a) && (t.audioTrack = a)
		})), t.on(AT.Events.LEVELS_UPDATED, (function (t, i) {
			var r;
			let n = e.videoTracks[null != (r = e.videoTracks.selectedIndex) ? r : 0];
			if (!n) return;
			let s = i.levels.map((e => a.get(e)));
			for (let t of e.videoRenditions) t.id && !s.includes(t.id) && n.removeRendition(t)
		}));
		let r = i => {
			let a = e.currentTime, r = !1, n = (e, t) => {
				r || (r = !Number.isFinite(t.endOffset))
			};
			t.on(AT.Events.BUFFER_FLUSHING, n), t.nextLevel = i, t.off(AT.Events.BUFFER_FLUSHING, n), r || t.trigger(AT.Events.BUFFER_FLUSHING, {
				startOffset: a + 10,
				endOffset: 1 / 0,
				type: "video"
			})
		};
		null == (i = e.videoRenditions) || i.addEventListener("change", (e => {
			let i = e.target.selectedIndex;
			i != t.nextLevel && r(i)
		}));
		let n = () => {
			for (let t of e.audioTracks) e.removeAudioTrack(t)
		}, s = () => {
			(() => {
				for (let t of e.videoTracks) e.removeVideoTrack(t)
			})(), n()
		};
		t.once(AT.Events.DESTROYING, s)
	}

	function GT(e, t, i, a, r) {
		let n = document.createElement("track");
		return n.kind = t, n.label = i, a && (n.srclang = a), r && (n.id = r), n.track.mode = ["subtitles", "captions"].includes(t) ? "disabled" : "hidden", n.setAttribute("data-removeondestroy", ""), e.append(n), n.track
	}

	var VT = "cuepoints", KT = Object.freeze({label: VT}), qT = (e, {label: t = VT} = KT) => {
		var i;
		return null == (i = Array.from(e.querySelectorAll("track")).find((e => e.track.label === t && "metadata" === e.track.kind))) ? void 0 : i.track
	};

	async function YT(e, t, i = KT) {
		let a = qT(e, i);
		if (!a) {
			let {label: t = VT} = i;
			a = GT(e, "metadata", t), a.mode = "hidden", await new Promise((e => setTimeout((() => e(void 0)), 0)))
		}
		return "hidden" !== a.mode && (a.mode = "hidden"), [...t].sort((({time: e}, {time: t}) => t - e)).forEach((({
			                                                                                                            time: t,
			                                                                                                            value: i
		                                                                                                            }) => {
			var r, n;
			let s = Array.prototype.findIndex.call(null == a ? void 0 : a.cues, (e => e.startTime >= t)),
				o = null == (r = null == a ? void 0 : a.cues) ? void 0 : r[s],
				l = o ? o.startTime : Number.isFinite(e.duration) ? e.duration : Number.MAX_SAFE_INTEGER,
				d = null == (n = null == a ? void 0 : a.cues) ? void 0 : n[s - 1];
			d && (d.endTime = t);
			let u = new VTTCue(t, l, JSON.stringify(null != i ? i : null));
			a.addCue(u)
		})), a
	}

	var jT = e => ({time: e.startTime, value: JSON.parse(e.text)});

	function zT(e, t = {label: VT}) {
		var i, a;
		let r = qT(e, t);
		if (null == (i = null == r ? void 0 : r.activeCues) || !i.length) return;
		let {currentTime: n} = e, s = Array.prototype.find.call(null != (a = r.activeCues) ? a : [], (({
			                                                                                               startTime: e,
			                                                                                               endTime: t
		                                                                                               }) => e <= n && t > n));
		return jT(s)
	}

	var XT, QT, ZT, JT, eA = async (e, t) => {
			if (t === xT.MP4) return {streamType: LT.ON_DEMAND, targetLiveWindow: Number.NaN, liveEdgeStartOffset: void 0};
			if (t === xT.M3U8) {
				let t = await (async e => fetch(e).then((e => e.text())).then((e => {
					let t = e.split("\n").find(((e, t, i) => t && i[t - 1].startsWith("#EXT-X-STREAM-INF")));
					return fetch(t).then((e => e.text())).then((e => e.split("\n")))
				})))(e);
				return (e => {
					var t, i, a;
					let r,
						n = null == (i = (null != (t = e.find((e => e.startsWith("#EXT-X-PLAYLIST-TYPE")))) ? t : "").split(":")[1]) ? void 0 : i.trim(),
						s = NT(n), o = UT(n);
					if (s === LT.LIVE) {
						let t = e.find((e => e.startsWith("#EXT-X-PART-INF")));
						if (t) r = 2 * +t.split(":")[1].split("=")[1]; else {
							let t = e.find((e => e.startsWith("#EXT-X-TARGETDURATION"))),
								i = null == (a = null == t ? void 0 : t.split(":")) ? void 0 : a[1];
							r = 3 * +(null != i ? i : 6)
						}
					}
					return {streamType: s, targetLiveWindow: o, liveEdgeStartOffset: r}
				})(t)
			}
			return console.error(`Media type ${t} is an unrecognized or unsupported type for src ${e}.`), {
				streamType: void 0,
				targetLiveWindow: void 0,
				liveEdgeStartOffset: void 0
			}
		}, tA = async (e, t, i = PT({src: e})) => {
			var a, r, n;
			let {streamType: s, targetLiveWindow: o, liveEdgeStartOffset: l} = await eA(e, i);
			(null != (a = rA.get(t)) ? a : {}).liveEdgeStartOffset = l, (null != (r = rA.get(t)) ? r : {}).targetLiveWindow = o, t.dispatchEvent(new CustomEvent("targetlivewindowchange", {
				composed: !0,
				bubbles: !0
			})), (null != (n = rA.get(t)) ? n : {}).streamType = s, t.dispatchEvent(new CustomEvent("streamtypechange", {
				composed: !0,
				bubbles: !0
			}))
		}, iA = (e, t, i) => {
			var a, r, n, s, o, l, d, u;
			let {streamType: h, targetLiveWindow: c, liveEdgeStartOffset: m, lowLatency: f} = (e => {
				var t;
				let i, a = e.type, r = NT(a), n = UT(a), s = !(null == (t = e.partList) || !t.length);
				return r === LT.LIVE && (i = s ? 2 * e.partTarget : 3 * e.targetduration), {
					streamType: r,
					targetLiveWindow: n,
					liveEdgeStartOffset: i,
					lowLatency: s
				}
			})(e);
			if (h === LT.LIVE) {
				f ? (i.config.backBufferLength = null != (a = i.userConfig.backBufferLength) ? a : 4, i.config.maxFragLookUpTolerance = null != (r = i.userConfig.maxFragLookUpTolerance) ? r : .001, i.config.abrBandWidthUpFactor = null != (n = i.userConfig.abrBandWidthUpFactor) ? n : i.config.abrBandWidthFactor) : i.config.backBufferLength = null != (s = i.userConfig.backBufferLength) ? s : 8;
				let e = Object.freeze({
					get length() {
						return t.seekable.length
					}, start: e => t.seekable.start(e), end(e) {
						var a;
						return e > this.length || e < 0 || Number.isFinite(t.duration) ? t.seekable.end(e) : null != (a = i.liveSyncPosition) ? a : t.seekable.end(e)
					}
				});
				(null != (o = rA.get(t)) ? o : {}).seekable = e
			}
			(null != (l = rA.get(t)) ? l : {}).liveEdgeStartOffset = m, (null != (d = rA.get(t)) ? d : {}).targetLiveWindow = c, t.dispatchEvent(new CustomEvent("targetlivewindowchange", {
				composed: !0,
				bubbles: !0
			})), (null != (u = rA.get(t)) ? u : {}).streamType = h, t.dispatchEvent(new CustomEvent("streamtypechange", {
				composed: !0,
				bubbles: !0
			}))
		},
		aA = -1 !== (null != (QT = null == (XT = null == globalThis ? void 0 : globalThis.navigator) ? void 0 : XT.userAgent) ? QT : "").toLowerCase().indexOf("android"),
		rA = new WeakMap, nA = "mux.com", sA = null == (JT = (ZT = AT).isSupported) ? void 0 : JT.call(ZT), oA = aA,
		lA = uf.utils.generateUUID, dA = ({
			                                  playbackId: e,
			                                  customDomain: t = nA,
			                                  maxResolution: i,
			                                  minResolution: a,
			                                  renditionOrder: r,
			                                  tokens: {playback: n} = {},
			                                  extraSourceParams: s = {}
		                                  } = {}) => {
			if (!e) return;
			let [o, l = ""] = (e => {
				let t = e.indexOf("?");
				return t < 0 ? [e] : [e.slice(0, t), e.slice(t)]
			})(e), d = new URL(`https://stream.${t}/${o}.m3u8${l}`);
			return n || d.searchParams.has("token") ? (d.searchParams.forEach(((e, t) => {
				"token" != t && d.searchParams.delete(t)
			})), n && d.searchParams.set("token", n)) : (i && d.searchParams.set("max_resolution", i), a && (d.searchParams.set("min_resolution", a), i && +i.slice(0, -1) < +a.slice(0, -1) && console.error("minResolution must be <= maxResolution", "minResolution", a, "maxResolution", i)), r && d.searchParams.set("rendition_order", r), Object.entries(s).forEach((([e, t]) => {
				null != t && d.searchParams.set(e, t)
			}))), d.toString()
		}, uA = e => {
			var t, i, a;
			return null != (t = null == e ? void 0 : e.metadata) && t.video_id ? e.metadata.video_id : AA(e) && null != (a = null != (i = (e => {
				if (!e) return;
				let [t] = e.split("?");
				return t || void 0
			})(e.playbackId)) ? i : (e => {
				if (!e || !e.startsWith("https://stream.")) return;
				let [t] = new URL(e).pathname.slice(1).split(".m3u8");
				return t || void 0
			})(e.src)) ? a : e.src
		}, hA = e => {
			var t, i;
			return null != (i = null == (t = rA.get(e)) ? void 0 : t.streamType) ? i : LT.UNKNOWN
		}, cA = e => {
			var t, i;
			return null != (i = null == (t = rA.get(e)) ? void 0 : t.seekable) ? i : e.seekable
		}, mA = .034, fA = (e, t, i = mA) => e > t || ((e, t, i = mA) => Math.abs(e - t) <= i)(e, t, i), pA = (e, t) => {
			var i, a, r;
			if (!t) return;
			if (e.readyState > 2) return !1;
			let n = t.currentLevel >= 0 ? null == (a = null == (i = t.levels) ? void 0 : i[t.currentLevel]) ? void 0 : a.details : null == (r = t.levels.find((e => !!e.details))) ? void 0 : r.details;
			if (!n || n.live) return;
			let {fragments: s} = n;
			if (null == s || !s.length) return;
			if (e.currentTime < e.duration - (n.targetduration + .5)) return !1;
			let o = s[s.length - 1];
			if (e.currentTime <= o.start) return !1;
			let l = o.start + o.duration / 2, d = e.buffered.start(e.buffered.length - 1),
				u = e.buffered.end(e.buffered.length - 1);
			return l > d && l < u
		},
		gA = (e, t) => e.ended || e.loop ? e.ended : !(!t || !pA(e, t)) || ((e, t = mA) => e.paused && fA(e.currentTime, e.duration, t))(e),
		vA = (e, t, i) => {
			EA(t, i);
			let {metadata: a = {}} = e, {view_session_id: r = lA()} = a, n = uA(e);
			a.view_session_id = r, a.video_id = n, e.metadata = a, rA.set(t, {});
			let s = yA(e, t);
			_A(e, t, s), kA(e, t, s), async function (e, t = KT) {
				new Promise((i => {
					OT(e, "loadstart", (async () => {
						let a = await YT(e, [], t);
						OT(e, "cuechange", (() => {
							let t = zT(e);
							if (t) {
								let i = new CustomEvent("cuepointchange", {composed: !0, bubbles: !0, detail: t});
								e.dispatchEvent(i)
							}
						}), {}, a), i(a)
					}))
				}))
			}(t);
			let o = ((e, t, i) => {
				let {autoplay: a} = e, r = !1, n = !1, s = $T(a) ? a : !!a, o = () => {
					r || OT(t, "playing", (() => {
						r = !0
					}), {once: !0})
				};
				if (o(), OT(t, "loadstart", (() => {
					r = !1, o(), HT(t, s)
				}), {once: !0}), OT(t, "loadstart", (() => {
					i || (n = e.streamType && e.streamType !== LT.UNKNOWN ? e.streamType === LT.LIVE : !Number.isFinite(t.duration)), HT(t, s)
				}), {once: !0}), i && i.once(AT.Events.LEVEL_LOADED, ((t, i) => {
					var a;
					n = e.streamType && e.streamType !== LT.UNKNOWN ? e.streamType === LT.LIVE : null != (a = i.details.live) && a
				})), !s) {
					let a = () => {
						!n || Number.isFinite(e.startTime) || (null != i && i.liveSyncPosition ? t.currentTime = i.liveSyncPosition : Number.isFinite(t.seekable.end(0)) && (t.currentTime = t.seekable.end(0)))
					};
					i && OT(t, "play", (() => {
						"metadata" === t.preload ? i.once(AT.Events.LEVEL_UPDATED, a) : a()
					}), {once: !0})
				}
				return e => {
					r || (s = $T(e) ? e : !!e, HT(t, s))
				}
			})(e, t, s), l = (({preload: e, src: t}, i, a) => {
				let r = e => {
					null != e && ["", "none", "metadata", "auto"].includes(e) ? i.setAttribute("preload", e) : i.removeAttribute("preload")
				};
				if (!a) return r(e), r;
				let n = !1, s = !1, o = a.config.maxBufferLength, l = a.config.maxBufferSize, d = e => {
					r(e);
					let t = null != e ? e : i.preload;
					s || "none" === t || ("metadata" === t ? (a.config.maxBufferLength = 1, a.config.maxBufferSize = 1) : (a.config.maxBufferLength = o, a.config.maxBufferSize = l), u())
				}, u = () => {
					!n && t && (n = !0, a.loadSource(t))
				};
				return OT(i, "play", (() => {
					s = !0, a.config.maxBufferLength = o, a.config.maxBufferSize = l, u()
				}), {once: !0}), d(e), d
			})(e, t, s);
			return {engine: s, setAutoplay: o, setPreload: l}
		}, EA = (e, t) => {
			let i = null == t ? void 0 : t.engine;
			i && (i.detachMedia(), i.destroy()), null != e && e.mux && !e.mux.deleted && (e.mux.destroy(), delete e.mux), e && (e.removeAttribute("src"), e.load(), e.removeEventListener("error", wA), e.removeEventListener("error", LA), e.removeEventListener("durationchange", SA), rA.delete(e), e.dispatchEvent(new Event("teardown")))
		};

	function bA(e, t) {
		var i;
		let a = PT(e);
		if (a !== xT.M3U8) return !0;
		let r = !a || null == (i = t.canPlayType(a)) || i, {preferPlayback: n} = e;
		return r && (n === IT || !(sA && (n === RT || oA)))
	}

	var yA = (e, t) => {
		let {debug: i, streamType: a, startTime: r = -1, metadata: n, preferCmcd: s, _hlsConfig: o = {}} = e,
			l = PT(e) === xT.M3U8, d = bA(e, t);
		if (l && !d && sA) {
			let e = {
				backBufferLength: 30,
				renderTextTracksNatively: !1,
				liveDurationInfinity: !0,
				capLevelToPlayerSize: !0,
				capLevelOnFPSDrop: !0
			}, t = TA(a), l = s !== DT.NONE ? {
				useHeaders: s === DT.HEADER,
				sessionId: null == n ? void 0 : n.view_session_id,
				contentId: null == n ? void 0 : n.video_id
			} : void 0;
			return new AT({
				debug: i, startPosition: r, cmcd: l, xhrSetup: (e, t) => {
					var i, a;
					if (s && s !== DT.QUERY) return;
					let r = new URL(t);
					if (!r.searchParams.has("CMCD")) return;
					let n = (null != (a = null == (i = r.searchParams.get("CMCD")) ? void 0 : i.split(",")) ? a : []).filter((e => e.startsWith("sid") || e.startsWith("cid"))).join(",");
					r.searchParams.set("CMCD", n), e.open("GET", r)
				}, ...e, ...t, ...o
			})
		}
	}, TA = e => e === LT.LIVE ? {backBufferLength: 8} : {}, AA = ({playbackId: e, src: t, customDomain: i}) => {
		if (e) return !0;
		if ("string" != typeof t) return !1;
		let a = null == window ? void 0 : window.location.href, r = new URL(t, a).hostname.toLocaleLowerCase();
		return r.includes(nA) || !!i && r.includes(i.toLocaleLowerCase())
	}, _A = (e, t, i) => {
		var a;
		let {envKey: r, disableTracking: n} = e, s = AA(e);
		if (!n && (r || s)) {
			let {
					playerInitTime: n,
					playerSoftwareName: s,
					playerSoftwareVersion: o,
					beaconCollectionDomain: l,
					debug: d,
					disableCookies: u
				} = e, h = {
					...e.metadata,
					video_title: (null == (a = null == e ? void 0 : e.metadata) ? void 0 : a.video_title) || void 0
				},
				c = t => "string" != typeof t.player_error_code && ("function" == typeof e.errorTranslator ? e.errorTranslator(t) : t);
			uf.monitor(t, {
				debug: d,
				beaconCollectionDomain: l,
				hlsjs: i,
				Hls: i ? AT : void 0,
				automaticErrorTracking: !1,
				errorTranslator: c,
				disableCookies: u,
				data: {
					...r ? {env_key: r} : {},
					player_software_name: s,
					player_software: s,
					player_software_version: o,
					player_init_time: n, ...h
				}
			})
		}
	}, kA = (e, t, i) => {
		var a;
		let r, n, s = bA(e, t), {src: o} = e, l = () => {
			t.ended || !gA(t, i) || (pA(t, i) ? t.currentTime = t.buffered.end(t.buffered.length - 1) : t.dispatchEvent(new Event("ended")))
		}, d = () => {
			var e, i;
			let a = null == (e = cA(t)) ? void 0 : e.start(0), s = null == (i = cA(t)) ? void 0 : i.end(0);
			(n !== s || r !== a) && t.dispatchEvent(new CustomEvent("seekablechange", {composed: !0})), r = a, n = s
		};
		if (OT(t, "durationchange", d), t && s) {
			let i = PT(e);
			if ("string" == typeof o) {
				let r = () => {
					if (hA(t) !== LT.LIVE || Number.isFinite(t.duration)) return;
					let e = setInterval(d, 1e3);
					t.addEventListener("teardown", (() => {
						clearInterval(e)
					}), {once: !0}), OT(t, "durationchange", (() => {
						Number.isFinite(t.duration) && clearInterval(e)
					}))
				};
				"none" === t.preload ? OT(t, "loadstart", (() => {
					tA(o, t, i).then(r)
				})) : tA(o, t, i).then(r), t.setAttribute("src", o), e.startTime && ((null != (a = rA.get(t)) ? a : {}).startTime = e.startTime, t.addEventListener("durationchange", SA, {once: !0}))
			} else t.removeAttribute("src");
			t.addEventListener("error", wA), t.addEventListener("error", LA), t.addEventListener("emptied", (() => {
				t.querySelectorAll("track[data-removeondestroy]").forEach((e => {
					e.remove()
				}))
			}), {once: !0}), OT(t, "pause", l), OT(t, "seeked", l), OT(t, "play", (() => {
				t.ended || fA(t.currentTime, t.duration) && (t.currentTime = t.seekable.start(0))
			}))
		} else i && o ? (i.once(AT.Events.LEVEL_LOADED, ((e, a) => {
			iA(a.details, t, i), d(), hA(t) === LT.LIVE && !Number.isFinite(t.duration) && (i.on(AT.Events.LEVEL_UPDATED, d), OT(t, "durationchange", (() => {
				Number.isFinite(t.duration) && i.off(AT.Events.LEVELS_UPDATED, d)
			})))
		})), i.on(AT.Events.ERROR, ((e, i) => {
			let a = {
				[AT.ErrorTypes.NETWORK_ERROR]: kT.MEDIA_ERR_NETWORK,
				[AT.ErrorTypes.MEDIA_ERROR]: kT.MEDIA_ERR_DECODE
			}, r = new kT("", a[i.type]);
			r.fatal = i.fatal, r.data = i, t.dispatchEvent(new CustomEvent("error", {detail: r}))
		})), t.addEventListener("error", LA), OT(t, "waiting", l), WT(e, i), function (e, t) {
			t.on(AT.Events.NON_NATIVE_TEXT_TRACKS_FOUND, ((i, {tracks: a}) => {
				a.forEach((i => {
					var a;
					let r = null != (a = i.subtitleTrack) ? a : i.closedCaptions, n = t.subtitleTracks.findIndex((({
						                                                                                               lang: e,
						                                                                                               name: t,
						                                                                                               type: a
					                                                                                               }) => e == (null == r ? void 0 : r.lang) && t === i.label && a.toLowerCase() === i.kind));
					GT(e, i.kind, i.label, null == r ? void 0 : r.lang, `${i.kind}${n}`)
				}))
			}));
			let i = () => {
				var i;
				if (!t.subtitleTracks.length) return;
				let a = Array.from(e.textTracks).find((e => e.id && "showing" === e.mode && ["subtitles", "captions"].includes(e.kind))),
					r = `${null == (i = t.subtitleTracks[t.subtitleTrack]) ? void 0 : i.type.toLowerCase()}${t.subtitleTrack}`;
				if (a && (t.subtitleTrack < 0 || (null == a ? void 0 : a.id) !== r)) {
					let e = t.subtitleTracks.findIndex((({
						                                     lang: e,
						                                     name: t,
						                                     type: i
					                                     }) => e == a.language && t === a.label && i.toLowerCase() === a.kind));
					t.subtitleTrack = e
				}
				a && (null == a ? void 0 : a.id) === r && a.cues && Array.from(a.cues).forEach((e => {
					a.addCue(e)
				}))
			};
			e.textTracks.addEventListener("change", i), t.on(AT.Events.CUES_PARSED, ((t, {track: i, cues: a}) => {
				let r = e.textTracks.getTrackById(i);
				if (!r) return;
				let n = "disabled" === r.mode;
				n && (r.mode = "hidden"), a.forEach((e => {
					var t;
					null != (t = r.cues) && t.getCueById(e.id) || r.addCue(e)
				})), n && (r.mode = "disabled")
			})), t.once(AT.Events.DESTROYING, (() => {
				e.textTracks.removeEventListener("change", i), e.querySelectorAll("track[data-removeondestroy]").forEach((e => {
					e.remove()
				}))
			}));
			let a = () => {
				Array.from(e.textTracks).forEach((t => {
					var i, a;
					if (!["subtitles", "caption"].includes(t.kind) && "thumbnails" === t.label) {
						if (null == (i = t.cues) || !i.length) {
							let t = e.querySelector('track[label="thumbnails"]'),
								i = null != (a = null == t ? void 0 : t.getAttribute("src")) ? a : "";
							null == t || t.removeAttribute("src"), setTimeout((() => {
								null == t || t.setAttribute("src", i)
							}), 0)
						}
						"hidden" !== t.mode && (t.mode = "hidden")
					}
				}))
			};
			t.once(AT.Events.MANIFEST_LOADED, a), t.once(AT.Events.MEDIA_ATTACHED, a)
		}(t, i), i.attachMedia(t)) : console.error("It looks like the video you're trying to play will not work on this system! If possible, try upgrading to the newest versions of your browser or software.")
	};

	function SA(e) {
		var t;
		let i = e.target, a = null == (t = rA.get(i)) ? void 0 : t.startTime;
		if (a && function (e, t, i) {
			t && i > t && (i = t);
			for (let t = 0; t < e.length; t++) if (e.start(t) <= i && e.end(t) >= i) return !0;
			return !1
		}(i.seekable, i.duration, a)) {
			let e = "auto" === i.preload;
			e && (i.preload = "none"), i.currentTime = a, e && (i.preload = "auto")
		}
	}

	async function wA(e) {
		if (!e.isTrusted) return;
		e.stopImmediatePropagation();
		let t = e.target;
		if (null == t || !t.error) return;
		let {message: i, code: a} = t.error, r = new kT(i, a);
		if (t.src && (a !== kT.MEDIA_ERR_DECODE || void 0 !== a)) try {
			let {status: e} = await fetch(t.src);
			r.data = {response: {code: e}}
		} catch {
		}
		t.dispatchEvent(new CustomEvent("error", {detail: r}))
	}

	function LA(e) {
		var t, i;
		if (!(e instanceof CustomEvent && e.detail instanceof kT)) return;
		let a = e.target, r = e.detail;
		!r || !r.fatal || ((null != (t = rA.get(a)) ? t : {}).error = r, null == (i = a.mux) || i.emit("error", {
			player_error_code: r.code,
			player_error_message: r.message,
			player_error_context: r.context
		}))
	}

	var RA = Object.defineProperty, IA = Object.getPrototypeOf, DA = Reflect.get, CA = (e, t, i) => (((e, t, i) => {
			t in e ? RA(e, t, {enumerable: !0, configurable: !0, writable: !0, value: i}) : e[t] = i
		})(e, "symbol" != typeof t ? t + "" : t, i), i), xA = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, MA = (e, t, i) => (xA(e, t, "read from private field"), i ? i.call(e) : t.get(e)), OA = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, PA = (e, t, i, a) => (xA(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		NA = (e, t, i) => (xA(e, t, "access private method"), i), UA = (e, t, i) => DA(IA(e), i, t), FA = class {
			addEventListener() {
			}

			removeEventListener() {
			}

			dispatchEvent(e) {
				return !0
			}
		};
	if ("undefined" == typeof DocumentFragment) {
		class e extends FA {
		}

		globalThis.DocumentFragment = e
	}
	var BA, $A = class extends FA {
	}, HA = {
		get(e) {
		}, define(e, t, i) {
		}, upgrade(e) {
		}, whenDefined: e => Promise.resolve($A)
	};
	BA = new WeakMap;
	var WA, GA = {
			document: {
				createElement: function (e, t) {
					return new $A
				}
			}, DocumentFragment: DocumentFragment, customElements: HA, CustomEvent: class {
				constructor(e, t = {}) {
					OA(this, BA, void 0), PA(this, BA, null == t ? void 0 : t.detail)
				}

				get detail() {
					return MA(this, BA)
				}

				initCustomEvent() {
				}
			}, EventTarget: FA, HTMLElement: $A, HTMLVideoElement: class extends FA {
			}
		}, VA = "undefined" == typeof window || void 0 === globalThis.customElements, KA = VA ? GA : globalThis,
		qA = (VA || globalThis.document, (() => {
			try {
				return "0.18.0"
			} catch {
			}
			return "UNKNOWN"
		})()),
		YA = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting", "waitingforkey", "resize", "enterpictureinpicture", "leavepictureinpicture", "webkitbeginfullscreen", "webkitendfullscreen", "webkitpresentationmodechanged"],
		jA = null == (WA = globalThis.document) ? void 0 : WA.createElement("template");
	jA && (jA.innerHTML = '\n    <style>\n      :host {\n        display: inline-flex;\n        line-height: 0;\n        flex-direction: column;\n        justify-content: end;\n      }\n\n      audio {\n        width: 100%;\n      }\n    </style>\n    <slot name="media"></slot>\n    <slot></slot>\n  ');
	var zA, XA = null == (zA = globalThis.document) ? void 0 : zA.createElement("template");
	XA && (XA.innerHTML = '\n    <style>\n      :host {\n        display: inline-block;\n        line-height: 0;\n      }\n\n      video {\n        max-width: 100%;\n        max-height: 100%;\n        min-width: 100%;\n        min-height: 100%;\n        object-fit: var(--media-object-fit, contain);\n        object-position: var(--media-object-position, 50% 50%);\n      }\n\n      video::-webkit-media-text-track-container {\n        transform: var(--media-webkit-text-track-transform);\n        transition: var(--media-webkit-text-track-transition);\n      }\n    </style>\n    <slot name="media"></slot>\n    <slot></slot>\n  ');
	var QA = (e, {tag: t, is: i}) => {
		var a, r, n, s, o, l, d, u, h, c, m, f, p, g, v, E;
		let b = null == (a = globalThis.document) ? void 0 : a.createElement(t, {is: i}), y = b ? function (e) {
			let t = [];
			for (let i = Object.getPrototypeOf(e); i && i !== HTMLElement.prototype; i = Object.getPrototypeOf(i)) t.push(...Object.getOwnPropertyNames(i));
			return t
		}(b) : [];
		return r = class extends e {
			constructor() {
				super(), OA(this, h), OA(this, m), OA(this, p), OA(this, v), OA(this, l, void 0), OA(this, d, void 0), OA(this, u, new Map), this.shadowRoot || (this.attachShadow({mode: "open"}), this.shadowRoot.append(this.constructor.template.content.cloneNode(!0)))
			}

			static get observedAttributes() {
				var e, t, i;
				return NA(e = r, s, o).call(e), [...null != (i = null == (t = null == b ? void 0 : b.constructor) ? void 0 : t.observedAttributes) ? i : [], "autopictureinpicture", "disablepictureinpicture", "disableremoteplayback", "autoplay", "controls", "controlslist", "crossorigin", "loop", "muted", "playsinline", "poster", "preload", "src"]
			}

			get nativeEl() {
				var e, i, a;
				return null != (a = null != (i = null != (e = MA(this, d)) ? e : this.shadowRoot.querySelector(t)) ? i : this.querySelector(":scope > [slot=media]")) ? a : this.querySelector(t)
			}

			set nativeEl(e) {
				PA(this, d, e)
			}

			get defaultMuted() {
				return this.hasAttribute("muted")
			}

			set defaultMuted(e) {
				this.toggleAttribute("muted", !!e)
			}

			get src() {
				return this.getAttribute("src")
			}

			set src(e) {
				this.setAttribute("src", `${e}`)
			}

			get preload() {
				var e, t;
				return null != (t = this.getAttribute("preload")) ? t : null == (e = this.nativeEl) ? void 0 : e.preload
			}

			set preload(e) {
				this.setAttribute("preload", `${e}`)
			}

			init() {
				var e, a;
				if (!this.nativeEl) {
					let e = document.createElement(t, {is: i});
					e.part = t, this.shadowRoot.querySelector('slot[name="media"]').append(e)
				}
				this.nativeEl.muted = this.hasAttribute("muted");
				for (let e of y) NA(this, p, g).call(this, e);
				this.shadowRoot.addEventListener("slotchange", this);
				for (let t of this.constructor.Events) null == (a = (e = this.shadowRoot).addEventListener) || a.call(e, t, this, !0)
			}

			handleEvent(e) {
				"slotchange" !== e.type ? e.target === this.nativeEl && this.dispatchEvent(new CustomEvent(e.type, {detail: e.detail})) : NA(this, m, f).call(this)
			}

			attributeChangedCallback(e, t, i) {
				NA(this, h, c).call(this), NA(this, v, E).call(this, e, t, i)
			}

			connectedCallback() {
				NA(this, h, c).call(this)
			}
		}, n = new WeakMap, s = new WeakSet, o = function () {
			if (MA(this, n)) return;
			PA(this, n, !0);
			let e = new Set(this.observedAttributes);
			e.delete("muted");
			for (let t of y) if (!(t in this.prototype)) if ("function" == typeof b[t]) this.prototype[t] = function (...e) {
				return NA(this, h, c).call(this), this.call ? this.call(t, ...e) : this.nativeEl[t].apply(this.nativeEl, e)
			}; else {
				let i = {
					get() {
						var i, a, r;
						NA(this, h, c).call(this);
						let n = t.toLowerCase();
						if (e.has(n)) {
							let e = this.getAttribute(n);
							return null !== e && ("" === e || e)
						}
						return null != (r = null == (i = this.get) ? void 0 : i.call(this, t)) ? r : null == (a = this.nativeEl) ? void 0 : a[t]
					}
				};
				t !== t.toUpperCase() && (i.set = function (i) {
					NA(this, h, c).call(this);
					let a = t.toLowerCase();
					e.has(a) ? !0 === i || !1 === i || null == i ? this.toggleAttribute(a, !!i) : this.setAttribute(a, i) : this.set ? this.set(t, i) : this.nativeEl[t] = i
				}), Object.defineProperty(this.prototype, t, i)
			}
		}, l = new WeakMap, d = new WeakMap, u = new WeakMap, h = new WeakSet, c = function () {
			MA(this, l) || (PA(this, l, !0), this.init())
		}, m = new WeakSet, f = function () {
			let e = new Map(MA(this, u));
			this.shadowRoot.querySelector("slot:not([name])").assignedElements().filter((e => ["track", "source"].includes(e.localName))).forEach((t => {
				var i, a;
				e.delete(t);
				let r = MA(this, u).get(t);
				r || (r = t.cloneNode(), MA(this, u).set(t, r)), null == (a = (i = this.nativeEl).append) || a.call(i, r), "track" === r.localName && r.default && ("chapters" === r.kind || "metadata" === r.kind) && "disabled" === r.track.mode && (r.track.mode = "hidden")
			})), e.forEach((e => e.remove()))
		}, p = new WeakSet, g = function (e) {
			if (Object.prototype.hasOwnProperty.call(this, e)) {
				let t = this[e];
				delete this[e], this[e] = t
			}
		}, v = new WeakSet, E = function (e, t, i) {
			var a, n, s, o, l, d;
			["id", "class"].includes(e) || !r.observedAttributes.includes(e) && this.constructor.observedAttributes.includes(e) || (null === i ? null == (n = (a = this.nativeEl).removeAttribute) || n.call(a, e) : (null == (o = (s = this.nativeEl).getAttribute) ? void 0 : o.call(s, e)) != i && (null == (d = (l = this.nativeEl).setAttribute) || d.call(l, e, i)))
		}, OA(r, s), CA(r, "Events", YA), CA(r, "template", t.endsWith("audio") ? jA : XA), OA(r, n, void 0), r
	};
	var ZA = globalThis.document ? QA(HTMLElement, {tag: "video"}) : class {
	}, JA = (globalThis.document && QA(HTMLElement, {tag: "audio"}), new WeakMap), e_ = class extends Error {
	}, t_ = class extends Error {
	}, i_ = globalThis.WeakRef ? class extends Set {
		add(e) {
			super.add(new WeakRef(e))
		}

		forEach(e) {
			super.forEach((t => {
				let i = t.deref();
				i && e(i)
			}))
		}
	} : Set;

	function a_() {
		return "undefined" != typeof chrome && chrome.cast && chrome.cast.isAvailable
	}

	function r_() {
		return "undefined" != typeof cast && cast.framework
	}

	function n_() {
		if (r_()) return cast.framework.CastContext.getInstance()
	}

	function s_() {
		var e;
		return null == (e = n_()) ? void 0 : e.getCurrentSession()
	}

	function o_() {
		var e;
		return null == (e = s_()) ? void 0 : e.getSessionObj().media[0]
	}

	function l_(e) {
		return n_().setOptions({
			receiverApplicationId: "CC1AD845",
			autoJoinPolicy: "origin_scoped",
			androidReceiverCompatible: !1,
			language: "en-US",
			resumeSavedSession: !0, ...e
		})
	}

	var d_, u_ = new i_, h_ = new WeakSet;
	!function (e) {
		a_() ? r_() ? e(chrome.cast.isAvailable) : customElements.whenDefined("google-cast-button").then((() => e(chrome.cast.isAvailable))) : globalThis.__onGCastApiAvailable = () => {
			customElements.whenDefined("google-cast-button").then((() => e(chrome.cast.isAvailable)))
		}
	}((e => {
		e && !d_ && (d_ = cast.framework, n_().addEventListener(d_.CastContextEventType.CAST_STATE_CHANGED, (e => {
			u_.forEach((t => {
				var i, a;
				return null == (a = (i = JA.get(t)).onCastStateChanged) ? void 0 : a.call(i, e)
			}))
		})), n_().addEventListener(d_.CastContextEventType.SESSION_STATE_CHANGED, (e => {
			u_.forEach((t => {
				var i, a;
				return null == (a = (i = JA.get(t)).onSessionStateChanged) ? void 0 : a.call(i, e)
			}))
		})), u_.forEach((e => {
			var t, i;
			return null == (i = (t = JA.get(e)).init) ? void 0 : i.call(t)
		})))
	}));
	var c_, m_, f_, p_, g_, v_, E_, b_, y_, T_, A_, __, k_, S_, w_, L_, R_, I_, D_, C_, x_, M_, O_ = 0,
		P_ = class extends EventTarget {
			constructor(e) {
				super(), OA(this, y_), OA(this, A_), OA(this, k_), OA(this, w_), OA(this, R_), OA(this, D_), OA(this, x_), OA(this, c_, void 0), OA(this, m_, void 0), OA(this, f_, void 0), OA(this, p_, void 0), OA(this, g_, "disconnected"), OA(this, v_, !1), OA(this, E_, new Set), OA(this, b_, new WeakMap), PA(this, c_, e), u_.add(this), JA.set(this, {
					init: () => NA(this, R_, I_).call(this),
					onCastStateChanged: () => NA(this, k_, S_).call(this),
					onSessionStateChanged: () => NA(this, w_, L_).call(this),
					getCastPlayer: () => MA(this, y_, T_)
				}), NA(this, R_, I_).call(this)
			}

			get state() {
				return MA(this, g_)
			}

			async watchAvailability(e) {
				if (MA(this, c_).disableRemotePlayback) throw new e_("disableRemotePlayback attribute is present.");
				return MA(this, b_).set(e, ++O_), MA(this, E_).add(e), O_
			}

			async cancelWatchAvailability(e) {
				if (MA(this, c_).disableRemotePlayback) throw new e_("disableRemotePlayback attribute is present.");
				e ? MA(this, E_).delete(e) : MA(this, E_).clear()
			}

			async prompt() {
				var e, t;
				if (MA(this, c_).disableRemotePlayback) throw new e_("disableRemotePlayback attribute is present.");
				if (!a_()) throw new t_("The RemotePlayback API is disabled on this platform.");
				let i = h_.has(MA(this, c_));
				h_.add(MA(this, c_)), l_(MA(this, c_).castOptions), Object.entries(MA(this, p_)).forEach((([e, t]) => {
					MA(this, f_).controller.addEventListener(e, t)
				}));
				try {
					await n_().requestSession()
				} catch (e) {
					if ("cancel" === e) return void (i || h_.delete(MA(this, c_)));
					throw new Error(e)
				}
				null == (t = null == (e = JA.get(MA(this, c_))) ? void 0 : e.loadOnPrompt) || t.call(e)
			}
		};
	c_ = new WeakMap, m_ = new WeakMap, f_ = new WeakMap, p_ = new WeakMap, g_ = new WeakMap, v_ = new WeakMap, E_ = new WeakMap, b_ = new WeakMap, y_ = new WeakSet, T_ = function () {
		if (h_.has(MA(this, c_))) return MA(this, f_)
	}, A_ = new WeakSet, __ = function () {
		h_.has(MA(this, c_)) && (Object.entries(MA(this, p_)).forEach((([e, t]) => {
			MA(this, f_).controller.removeEventListener(e, t)
		})), h_.delete(MA(this, c_)), MA(this, c_).muted = MA(this, f_).isMuted, MA(this, c_).currentTime = MA(this, f_).savedPlayerState.currentTime, !1 === MA(this, f_).savedPlayerState.isPaused && MA(this, c_).play())
	}, k_ = new WeakSet, S_ = function () {
		let e = n_().getCastState();
		if (h_.has(MA(this, c_)) && "CONNECTING" === e && (PA(this, g_, "connecting"), this.dispatchEvent(new Event("connecting"))), !MA(this, v_) && null != e && e.includes("CONNECT")) {
			PA(this, v_, !0);
			for (let e of MA(this, E_)) e(!0)
		} else if (MA(this, v_) && (!e || "NO_DEVICES_AVAILABLE" === e)) {
			PA(this, v_, !1);
			for (let e of MA(this, E_)) e(!1)
		}
	}, w_ = new WeakSet, L_ = async function () {
		var e;
		let {SESSION_RESUMED: t} = d_.SessionState;
		if (n_().getSessionState() === t && MA(this, c_).castSrc === (null == (e = o_()) ? void 0 : e.media.contentId)) {
			h_.add(MA(this, c_)), Object.entries(MA(this, p_)).forEach((([e, t]) => {
				MA(this, f_).controller.addEventListener(e, t)
			}));
			try {
				await function (e) {
					return new Promise(((t, i) => {
						o_().getStatus(e, t, i)
					}))
				}(new chrome.cast.media.GetStatusRequest)
			} catch (e) {
				console.error(e)
			}
			MA(this, p_)[d_.RemotePlayerEventType.IS_PAUSED_CHANGED](), MA(this, p_)[d_.RemotePlayerEventType.PLAYER_STATE_CHANGED]()
		}
	}, R_ = new WeakSet, I_ = function () {
		!d_ || MA(this, m_) || (PA(this, m_, !0), l_(MA(this, c_).castOptions), MA(this, c_).textTracks.addEventListener("change", (() => NA(this, x_, M_).call(this))), NA(this, k_, S_).call(this), PA(this, f_, new d_.RemotePlayer), new d_.RemotePlayerController(MA(this, f_)), PA(this, p_, {
			[d_.RemotePlayerEventType.IS_CONNECTED_CHANGED]: ({value: e}) => {
				!0 === e ? (PA(this, g_, "connected"), this.dispatchEvent(new Event("connect"))) : (NA(this, A_, __).call(this), PA(this, g_, "disconnected"), this.dispatchEvent(new Event("disconnect")))
			}, [d_.RemotePlayerEventType.DURATION_CHANGED]: () => {
				MA(this, c_).dispatchEvent(new Event("durationchange"))
			}, [d_.RemotePlayerEventType.VOLUME_LEVEL_CHANGED]: () => {
				MA(this, c_).dispatchEvent(new Event("volumechange"))
			}, [d_.RemotePlayerEventType.IS_MUTED_CHANGED]: () => {
				MA(this, c_).dispatchEvent(new Event("volumechange"))
			}, [d_.RemotePlayerEventType.CURRENT_TIME_CHANGED]: () => {
				var e;
				null != (e = MA(this, y_, T_)) && e.isMediaLoaded && MA(this, c_).dispatchEvent(new Event("timeupdate"))
			}, [d_.RemotePlayerEventType.VIDEO_INFO_CHANGED]: () => {
				MA(this, c_).dispatchEvent(new Event("resize"))
			}, [d_.RemotePlayerEventType.IS_PAUSED_CHANGED]: () => {
				MA(this, c_).dispatchEvent(new Event(this.paused ? "pause" : "play"))
			}, [d_.RemotePlayerEventType.PLAYER_STATE_CHANGED]: () => {
				var e, t;
				(null == (e = MA(this, y_, T_)) ? void 0 : e.playerState) !== chrome.cast.media.PlayerState.PAUSED && MA(this, c_).dispatchEvent(new Event({
					[chrome.cast.media.PlayerState.PLAYING]: "playing",
					[chrome.cast.media.PlayerState.BUFFERING]: "waiting",
					[chrome.cast.media.PlayerState.IDLE]: "emptied"
				}[null == (t = MA(this, y_, T_)) ? void 0 : t.playerState]))
			}, [d_.RemotePlayerEventType.IS_MEDIA_LOADED_CHANGED]: async () => {
				var e;
				null != (e = MA(this, y_, T_)) && e.isMediaLoaded && (await Promise.resolve(), NA(this, D_, C_).call(this))
			}
		}))
	}, D_ = new WeakSet, C_ = function () {
		NA(this, x_, M_).call(this)
	}, x_ = new WeakSet, M_ = async function () {
		var e, t, i, a, r;
		if (!MA(this, y_, T_)) return;
		let n = (null != (t = null == (e = MA(this, f_).mediaInfo) ? void 0 : e.tracks) ? t : []).filter((({type: e}) => e === chrome.cast.media.TrackType.TEXT)),
			s = [...MA(this, c_).textTracks].filter((({kind: e}) => "subtitles" === e || "captions" === e)),
			o = n.map((({language: e, name: t, trackId: i}) => {
				var a;
				let {mode: r} = null != (a = s.find((i => i.language === e && i.label === t))) ? a : {};
				return !!r && {mode: r, trackId: i}
			})).filter(Boolean), l = o.filter((({mode: e}) => "showing" !== e)).map((({trackId: e}) => e)),
			d = o.find((({mode: e}) => "showing" === e)),
			u = null != (r = null == (a = null == (i = s_()) ? void 0 : i.getSessionObj().media[0]) ? void 0 : a.activeTrackIds) ? r : [],
			h = u;
		if (u.length && (h = h.filter((e => !l.includes(e)))), null != d && d.trackId && (h = [...h, d.trackId]), h = [...new Set(h)], m = h, (c = u).length !== m.length || !c.every((e => m.includes(e)))) try {
			let e = new chrome.cast.media.EditTracksInfoRequest(h);
			await function (e) {
				return new Promise(((t, i) => {
					o_().editTracksInfo(e, t, i)
				}))
			}(e)
		} catch (c) {
			console.error(c)
		}
		var c, m
	};
	var N_ = e => {
		var t, i, a, r, n, s, o, l, d;
		return i = class extends e {
			constructor() {
				super(...arguments), OA(this, s), OA(this, l), OA(this, a, {paused: !1}), OA(this, r, {
					receiverApplicationId: "CC1AD845",
					autoJoinPolicy: "origin_scoped",
					androidReceiverCompatible: !1,
					language: "en-US",
					resumeSavedSession: !0
				}), OA(this, n, void 0)
			}

			get remote() {
				return MA(this, n) ? MA(this, n) : globalThis.chrome ? (function () {
					let e = "https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1";
					if (globalThis.chrome.cast || document.querySelector(`script[src="${e}"]`)) return;
					let t = document.createElement("script");
					t.src = e, document.head.append(t)
				}(), JA.set(this, {loadOnPrompt: () => NA(this, l, d).call(this)}), PA(this, n, new P_(this))) : super.remote
			}

			get castOptions() {
				return MA(this, r)
			}

			get castReceiver() {
				var e;
				return null != (e = this.getAttribute("cast-receiver")) ? e : void 0
			}

			set castReceiver(e) {
				this.castReceiver != e && this.setAttribute("cast-receiver", `${e}`)
			}

			get castSrc() {
				var e, t, i;
				return null != (i = null != (t = this.getAttribute("cast-src")) ? t : null == (e = this.querySelector("source")) ? void 0 : e.src) ? i : this.currentSrc
			}

			set castSrc(e) {
				this.castSrc != e && this.setAttribute("cast-src", `${e}`)
			}

			get castContentType() {
				var e;
				return null != (e = this.getAttribute("cast-content-type")) ? e : void 0
			}

			set castContentType(e) {
				this.setAttribute("cast-content-type", `${e}`)
			}

			get castStreamType() {
				var e, t;
				return null != (t = null != (e = this.getAttribute("cast-stream-type")) ? e : this.streamType) ? t : void 0
			}

			set castStreamType(e) {
				this.setAttribute("cast-stream-type", `${e}`)
			}

			get readyState() {
				if (MA(this, s, o)) switch (MA(this, s, o).playerState) {
					case chrome.cast.media.PlayerState.IDLE:
						return 0;
					case chrome.cast.media.PlayerState.BUFFERING:
						return 2;
					default:
						return 3
				}
				return super.readyState
			}

			get paused() {
				return MA(this, s, o) ? MA(this, s, o).isPaused : super.paused
			}

			get muted() {
				var e;
				return MA(this, s, o) ? null == (e = MA(this, s, o)) ? void 0 : e.isMuted : super.muted
			}

			set muted(e) {
				var t;
				MA(this, s, o) ? (e && !MA(this, s, o).isMuted || !e && MA(this, s, o).isMuted) && (null == (t = MA(this, s, o).controller) || t.muteOrUnmute()) : super.muted = e
			}

			get volume() {
				var e, t;
				return MA(this, s, o) ? null != (t = null == (e = MA(this, s, o)) ? void 0 : e.volumeLevel) ? t : 1 : super.volume
			}

			set volume(e) {
				var t;
				if (MA(this, s, o)) return MA(this, s, o).volumeLevel = +e, void (null == (t = MA(this, s, o).controller) || t.setVolumeLevel());
				super.volume = e
			}

			get duration() {
				var e, t, i;
				return MA(this, s, o) && null != (e = MA(this, s, o)) && e.isMediaLoaded ? null != (i = null == (t = MA(this, s, o)) ? void 0 : t.duration) ? i : NaN : super.duration
			}

			get currentTime() {
				var e, t, i;
				return MA(this, s, o) && null != (e = MA(this, s, o)) && e.isMediaLoaded ? null != (i = null == (t = MA(this, s, o)) ? void 0 : t.currentTime) ? i : 0 : super.currentTime
			}

			set currentTime(e) {
				var t;
				if (MA(this, s, o)) return MA(this, s, o).currentTime = e, void (null == (t = MA(this, s, o).controller) || t.seek());
				super.currentTime = e
			}

			attributeChangedCallback(e, t, i) {
				if (super.attributeChangedCallback(e, t, i), "cast-receiver" === e && i) MA(this, r).receiverApplicationId = i; else if (MA(this, s, o)) switch (e) {
					case"cast-stream-type":
					case"cast-src":
						this.load()
				}
			}

			async load() {
				var e, t;
				if (!MA(this, s, o)) return super.load();
				let i = new chrome.cast.media.MediaInfo(this.castSrc, this.castContentType),
					r = [...this.querySelectorAll("track")].filter((({
						                                                 kind: e,
						                                                 src: t
					                                                 }) => t && ("subtitles" === e || "captions" === e))),
					n = [], l = 0;
				r.length && (i.tracks = r.map((e => {
					let t = ++l;
					0 === n.length && "showing" === e.track.mode && n.push(t);
					let i = new chrome.cast.media.Track(t, chrome.cast.media.TrackType.TEXT);
					return i.trackContentId = e.src, i.trackContentType = "text/vtt", i.subtype = "captions" === e.kind ? chrome.cast.media.TextTrackType.CAPTIONS : chrome.cast.media.TextTrackType.SUBTITLES, i.name = e.label, i.language = e.srclang, i
				}))), "live" === this.castStreamType ? i.streamType = chrome.cast.media.StreamType.LIVE : i.streamType = chrome.cast.media.StreamType.BUFFERED, i.metadata = new chrome.cast.media.GenericMediaMetadata, i.metadata.title = this.title, i.metadata.images = [{url: this.poster}];
				let d = new chrome.cast.media.LoadRequest(i);
				d.currentTime = null != (e = super.currentTime) ? e : 0, d.autoplay = !MA(this, a).paused, d.activeTrackIds = n, await (null == (t = s_()) ? void 0 : t.loadMedia(d)), this.dispatchEvent(new Event("volumechange"))
			}

			play() {
				var e;
				if (!MA(this, s, o)) return super.play();
				MA(this, s, o).isPaused && (null == (e = MA(this, s, o).controller) || e.playOrPause())
			}

			pause() {
				var e;
				MA(this, s, o) ? MA(this, s, o).isPaused || null == (e = MA(this, s, o).controller) || e.playOrPause() : super.pause()
			}
		}, a = new WeakMap, r = new WeakMap, n = new WeakMap, s = new WeakSet, o = function () {
			var e, t;
			return null == (t = null == (e = JA.get(this.remote)) ? void 0 : e.getCastPlayer) ? void 0 : t.call(e)
		}, l = new WeakSet, d = async function () {
			MA(this, a).paused = UA(i.prototype, this, "paused"), UA(i.prototype, this, "pause").call(this), this.muted = UA(i.prototype, this, "muted");
			try {
				await this.load()
			} catch (e) {
				console.error(e)
			}
		}, CA(i, "observedAttributes", [...null != (t = e.observedAttributes) ? t : [], "cast-src", "cast-content-type", "cast-stream-type", "cast-receiver"]), i
	}, U_ = class extends Event {
		constructor(e, t) {
			super(e), CA(this, "track"), this.track = t.track
		}
	}, F_ = new WeakMap;

	function B_(e) {
		var t;
		return null != (t = F_.get(e)) ? t : function (e, t) {
			let i = F_.get(e);
			return i || F_.set(e, i = {}), Object.assign(i, t)
		}(e, {})
	}

	function $_(e, t) {
		let i = e.videoTracks;
		B_(t).media = e, B_(t).renditionSet || (B_(t).renditionSet = new Set);
		let a = B_(i).trackSet;
		a.add(t);
		let r = a.size - 1;
		r in Y_.prototype || Object.defineProperty(Y_.prototype, r, {
			get() {
				return [...B_(this).trackSet][r]
			}
		}), queueMicrotask((() => {
			i.dispatchEvent(new U_("addtrack", {track: t}))
		}))
	}

	function H_(e) {
		var t;
		let i = null == (t = B_(e).media) ? void 0 : t.videoTracks;
		i && (B_(i).trackSet.delete(e), queueMicrotask((() => {
			i.dispatchEvent(new U_("removetrack", {track: e}))
		})))
	}

	var W_, G_, V_, K_, q_, Y_ = class extends EventTarget {
		constructor() {
			super(), OA(this, K_), OA(this, W_, void 0), OA(this, G_, void 0), OA(this, V_, void 0), B_(this).trackSet = new Set
		}

		get length() {
			return MA(this, K_, q_).size
		}

		get selectedIndex() {
			return [...MA(this, K_, q_)].findIndex((e => e.selected))
		}

		get onaddtrack() {
			return MA(this, W_)
		}

		set onaddtrack(e) {
			MA(this, W_) && (this.removeEventListener("addtrack", MA(this, W_)), PA(this, W_, void 0)), "function" == typeof e && (PA(this, W_, e), this.addEventListener("addtrack", e))
		}

		get onremovetrack() {
			return MA(this, G_)
		}

		set onremovetrack(e) {
			MA(this, G_) && (this.removeEventListener("removetrack", MA(this, G_)), PA(this, G_, void 0)), "function" == typeof e && (PA(this, G_, e), this.addEventListener("removetrack", e))
		}

		get onchange() {
			return MA(this, V_)
		}

		set onchange(e) {
			MA(this, V_) && (this.removeEventListener("change", MA(this, V_)), PA(this, V_, void 0)), "function" == typeof e && (PA(this, V_, e), this.addEventListener("change", e))
		}

		[Symbol.iterator]() {
			return MA(this, K_, q_).values()
		}

		getTrackById(e) {
			var t;
			return null != (t = [...MA(this, K_, q_)].find((t => t.id === e))) ? t : null
		}
	};
	W_ = new WeakMap, G_ = new WeakMap, V_ = new WeakMap, K_ = new WeakSet, q_ = function () {
		return B_(this).trackSet
	};
	var j_ = class extends Event {
		constructor(e, t) {
			super(e), CA(this, "rendition"), this.rendition = t.rendition
		}
	};

	function z_(e) {
		return [...B_(e).media.videoTracks].filter((e => e.selected)).flatMap((e => [...B_(e).renditionSet]))
	}

	var X_, Q_, Z_, J_ = class extends EventTarget {
		constructor() {
			super(...arguments), OA(this, X_, void 0), OA(this, Q_, void 0), OA(this, Z_, void 0)
		}

		get length() {
			return z_(this).length
		}

		get selectedIndex() {
			return z_(this).findIndex((e => e.selected))
		}

		set selectedIndex(e) {
			for (let [t, i] of z_(this).entries()) i.selected = t === e
		}

		get onaddrendition() {
			return MA(this, X_)
		}

		set onaddrendition(e) {
			MA(this, X_) && (this.removeEventListener("addrendition", MA(this, X_)), PA(this, X_, void 0)), "function" == typeof e && (PA(this, X_, e), this.addEventListener("addrendition", e))
		}

		get onremoverendition() {
			return MA(this, Q_)
		}

		set onremoverendition(e) {
			MA(this, Q_) && (this.removeEventListener("removerendition", MA(this, Q_)), PA(this, Q_, void 0)), "function" == typeof e && (PA(this, Q_, e), this.addEventListener("removerendition", e))
		}

		get onchange() {
			return MA(this, Z_)
		}

		set onchange(e) {
			MA(this, Z_) && (this.removeEventListener("change", MA(this, Z_)), PA(this, Z_, void 0)), "function" == typeof e && (PA(this, Z_, e), this.addEventListener("change", e))
		}

		[Symbol.iterator]() {
			return z_(this).values()
		}

		getRenditionById(e) {
			var t;
			return null != (t = z_(this).find((t => `${t.id}` == `${e}`))) ? t : null
		}
	};
	X_ = new WeakMap, Q_ = new WeakMap, Z_ = new WeakMap;
	var ek;
	ek = new WeakMap;
	var tk, ik = class {
		constructor() {
			CA(this, "id"), CA(this, "kind"), CA(this, "label", ""), CA(this, "language", ""), CA(this, "sourceBuffer"), OA(this, tk, !1)
		}

		get selected() {
			return MA(this, tk)
		}

		set selected(e) {
			MA(this, tk) !== e && (PA(this, tk, e), !0 === e && function (e) {
				var t;
				let i = null != (t = B_(e).media.videoTracks) ? t : [], a = !1;
				for (let t of i) t !== e && (t.selected = !1, a = !0);
				if (a) {
					if (B_(i).changeRequested) return;
					B_(i).changeRequested = !0, queueMicrotask((() => {
						delete B_(i).changeRequested, i.dispatchEvent(new Event("change"))
					}))
				}
			}(this))
		}

		addRendition(e, t, i, a, r, n) {
			let s = new class {
				constructor() {
					CA(this, "src"), CA(this, "id"), CA(this, "width"), CA(this, "height"), CA(this, "bitrate"), CA(this, "frameRate"), CA(this, "codec"), OA(this, ek, !1)
				}

				get selected() {
					return MA(this, ek)
				}

				set selected(e) {
					MA(this, ek) !== e && (PA(this, ek, e), function (e) {
						let t = B_(e).media.videoRenditions;
						!t || B_(t).changeRequested || (B_(t).changeRequested = !0, queueMicrotask((() => {
							delete B_(t).changeRequested, B_(e).track.selected && t.dispatchEvent(new Event("change"))
						})))
					}(this))
				}
			};
			return s.src = e, s.width = t, s.height = i, s.frameRate = n, s.bitrate = r, s.codec = a, function (e, t) {
				let i = B_(e).media.videoRenditions;
				B_(t).media = B_(e).media, B_(t).track = e;
				let a = B_(e).renditionSet;
				a.add(t);
				let r = a.size - 1;
				r in J_.prototype || Object.defineProperty(J_.prototype, r, {
					get() {
						return z_(this)[r]
					}
				}), queueMicrotask((() => {
					e.selected && i.dispatchEvent(new j_("addrendition", {rendition: t}))
				}))
			}(this, s), s
		}

		removeRendition(e) {
			!function (e) {
				let t = B_(e).media.videoRenditions, i = B_(e).track;
				B_(i).renditionSet.delete(e), queueMicrotask((() => {
					B_(e).track.selected && t.dispatchEvent(new j_("removerendition", {rendition: e}))
				}))
			}(e)
		}
	};

	function ak(e) {
		return [...B_(e).media.audioTracks].filter((e => e.enabled)).flatMap((e => [...B_(e).renditionSet]))
	}

	tk = new WeakMap;
	var rk, nk, sk, ok = class extends EventTarget {
		constructor() {
			super(...arguments), OA(this, rk, void 0), OA(this, nk, void 0), OA(this, sk, void 0)
		}

		get length() {
			return ak(this).length
		}

		get selectedIndex() {
			return ak(this).findIndex((e => e.selected))
		}

		set selectedIndex(e) {
			for (let [t, i] of ak(this).entries()) i.selected = t === e
		}

		get onaddrendition() {
			return MA(this, rk)
		}

		set onaddrendition(e) {
			MA(this, rk) && (this.removeEventListener("addrendition", MA(this, rk)), PA(this, rk, void 0)), "function" == typeof e && (PA(this, rk, e), this.addEventListener("addrendition", e))
		}

		get onremoverendition() {
			return MA(this, nk)
		}

		set onremoverendition(e) {
			MA(this, nk) && (this.removeEventListener("removerendition", MA(this, nk)), PA(this, nk, void 0)), "function" == typeof e && (PA(this, nk, e), this.addEventListener("removerendition", e))
		}

		get onchange() {
			return MA(this, sk)
		}

		set onchange(e) {
			MA(this, sk) && (this.removeEventListener("change", MA(this, sk)), PA(this, sk, void 0)), "function" == typeof e && (PA(this, sk, e), this.addEventListener("change", e))
		}

		[Symbol.iterator]() {
			return ak(this).values()
		}

		getRenditionById(e) {
			var t;
			return null != (t = ak(this).find((t => `${t.id}` == `${e}`))) ? t : null
		}
	};
	rk = new WeakMap, nk = new WeakMap, sk = new WeakMap;
	var lk;

	function dk(e, t) {
		let i = e.audioTracks;
		B_(t).media = e, B_(t).renditionSet || (B_(t).renditionSet = new Set);
		let a = B_(i).trackSet;
		a.add(t);
		let r = a.size - 1;
		r in gk.prototype || Object.defineProperty(gk.prototype, r, {
			get() {
				return [...B_(this).trackSet][r]
			}
		}), queueMicrotask((() => {
			i.dispatchEvent(new U_("addtrack", {track: t}))
		}))
	}

	function uk(e) {
		var t;
		let i = null == (t = B_(e).media) ? void 0 : t.audioTracks;
		i && (B_(i).trackSet.delete(e), queueMicrotask((() => {
			i.dispatchEvent(new U_("removetrack", {track: e}))
		})))
	}

	lk = new WeakMap;
	var hk, ck, mk, fk, pk, gk = class extends EventTarget {
		constructor() {
			super(), OA(this, fk), OA(this, hk, void 0), OA(this, ck, void 0), OA(this, mk, void 0), B_(this).trackSet = new Set
		}

		get length() {
			return MA(this, fk, pk).size
		}

		get onaddtrack() {
			return MA(this, hk)
		}

		set onaddtrack(e) {
			MA(this, hk) && (this.removeEventListener("addtrack", MA(this, hk)), PA(this, hk, void 0)), "function" == typeof e && (PA(this, hk, e), this.addEventListener("addtrack", e))
		}

		get onremovetrack() {
			return MA(this, ck)
		}

		set onremovetrack(e) {
			MA(this, ck) && (this.removeEventListener("removetrack", MA(this, ck)), PA(this, ck, void 0)), "function" == typeof e && (PA(this, ck, e), this.addEventListener("removetrack", e))
		}

		get onchange() {
			return MA(this, mk)
		}

		set onchange(e) {
			MA(this, mk) && (this.removeEventListener("change", MA(this, mk)), PA(this, mk, void 0)), "function" == typeof e && (PA(this, mk, e), this.addEventListener("change", e))
		}

		[Symbol.iterator]() {
			return MA(this, fk, pk).values()
		}

		getTrackById(e) {
			var t;
			return null != (t = [...MA(this, fk, pk)].find((t => t.id === e))) ? t : null
		}
	};
	hk = new WeakMap, ck = new WeakMap, mk = new WeakMap, fk = new WeakSet, pk = function () {
		return B_(this).trackSet
	};
	var vk, Ek = class {
		constructor() {
			CA(this, "id"), CA(this, "kind"), CA(this, "label", ""), CA(this, "language", ""), CA(this, "sourceBuffer"), OA(this, vk, !1)
		}

		get enabled() {
			return MA(this, vk)
		}

		set enabled(e) {
			MA(this, vk) !== e && (PA(this, vk, e), function (e) {
				let t = B_(e).media.audioTracks;
				!t || B_(t).changeRequested || (B_(t).changeRequested = !0, queueMicrotask((() => {
					delete B_(t).changeRequested, t.dispatchEvent(new Event("change"))
				})))
			}(this))
		}

		addRendition(e, t, i) {
			let a = new class {
				constructor() {
					CA(this, "src"), CA(this, "id"), CA(this, "bitrate"), CA(this, "codec"), OA(this, lk, !1)
				}

				get selected() {
					return MA(this, lk)
				}

				set selected(e) {
					MA(this, lk) !== e && (PA(this, lk, e), function (e) {
						let t = B_(e).media.audioRenditions;
						!t || B_(t).changeRequested || (B_(t).changeRequested = !0, queueMicrotask((() => {
							delete B_(t).changeRequested, B_(e).track.enabled && t.dispatchEvent(new Event("change"))
						})))
					}(this))
				}
			};
			return a.src = e, a.codec = t, a.bitrate = i, function (e, t) {
				let i = B_(e).media.audioRenditions;
				B_(t).media = B_(e).media, B_(t).track = e;
				let a = B_(e).renditionSet;
				a.add(t);
				let r = a.size - 1;
				r in ok.prototype || Object.defineProperty(ok.prototype, r, {
					get() {
						return ak(this)[r]
					}
				}), queueMicrotask((() => {
					e.enabled && i.dispatchEvent(new j_("addrendition", {rendition: t}))
				}))
			}(this, a), a
		}

		removeRendition(e) {
			!function (e) {
				let t = B_(e).media.audioRenditions, i = B_(e).track;
				B_(i).renditionSet.delete(e), queueMicrotask((() => {
					B_(e).track.enabled && t.dispatchEvent(new j_("removerendition", {rendition: e}))
				}))
			}(e)
		}
	};
	vk = new WeakMap;
	var bk = Ak(globalThis.HTMLMediaElement, "video"), yk = Ak(globalThis.HTMLMediaElement, "audio");

	function Tk(e) {
		if (null == e || !e.prototype) return e;
		let t = Ak(e, "video");
		(!t || `${t}`.includes("[native code]")) && Object.defineProperty(e.prototype, "videoTracks", {
			get() {
				return function (e) {
					var t;
					let i = B_(e).videoTracks;
					if (!i && (i = new Y_, B_(e).videoTracks = i, bk)) {
						let a = bk.call(null != (t = e.nativeEl) ? t : e);
						for (let t of a) $_(e, t);
						a.addEventListener("change", (() => {
							i.dispatchEvent(new Event("change"))
						})), a.addEventListener("addtrack", (t => {
							if ([...i].some((e => e instanceof ik))) for (let e of a) H_(e); else $_(e, t.track)
						})), a.addEventListener("removetrack", (e => {
							H_(e.track)
						}))
					}
					return i
				}(this)
			}
		});
		let i = Ak(e, "audio");
		(!i || `${i}`.includes("[native code]")) && Object.defineProperty(e.prototype, "audioTracks", {
			get() {
				return function (e) {
					var t;
					let i = B_(e).audioTracks;
					if (!i && (i = new gk, B_(e).audioTracks = i, yk)) {
						let a = yk.call(null != (t = e.nativeEl) ? t : e);
						for (let t of a) dk(e, t);
						a.addEventListener("change", (() => {
							i.dispatchEvent(new Event("change"))
						})), a.addEventListener("addtrack", (t => {
							if ([...i].some((e => e instanceof Ek))) for (let e of a) uk(e); else dk(e, t.track)
						})), a.addEventListener("removetrack", (e => {
							uk(e.track)
						}))
					}
					return i
				}(this)
			}
		}), "addVideoTrack" in e.prototype || (e.prototype.addVideoTrack = function (e, t = "", i = "") {
			let a = new ik;
			return a.kind = e, a.label = t, a.language = i, $_(this, a), a
		}), "removeVideoTrack" in e.prototype || (e.prototype.removeVideoTrack = H_), "addAudioTrack" in e.prototype || (e.prototype.addAudioTrack = function (e, t = "", i = "") {
			let a = new Ek;
			return a.kind = e, a.label = t, a.language = i, dk(this, a), a
		}), "removeAudioTrack" in e.prototype || (e.prototype.removeAudioTrack = uk), "videoRenditions" in e.prototype || Object.defineProperty(e.prototype, "videoRenditions", {
			get() {
				return a(this)
			}
		});
		let a = e => {
			let t = B_(e).videoRenditions;
			return t || (t = new J_, B_(t).media = e, B_(e).videoRenditions = t), t
		};
		"audioRenditions" in e.prototype || Object.defineProperty(e.prototype, "audioRenditions", {
			get() {
				return r(this)
			}
		});
		let r = e => {
			let t = B_(e).audioRenditions;
			return t || (t = new ok, B_(t).media = e, B_(e).audioRenditions = t), t
		};
		return e
	}

	function Ak(e, t) {
		var i;
		if (null != e && e.prototype) return null == (i = Object.getOwnPropertyDescriptor(e.prototype, `${t}Tracks`)) ? void 0 : i.get
	}

	YA.push("castchange", "entercast", "leavecast");
	var _k, kk, Sk, wk, Lk, Rk, Ik, Dk, Ck, xk, Mk = {
		BEACON_COLLECTION_DOMAIN: "beacon-collection-domain",
		CUSTOM_DOMAIN: "custom-domain",
		DEBUG: "debug",
		DISABLE_TRACKING: "disable-tracking",
		DISABLE_COOKIES: "disable-cookies",
		ENV_KEY: "env-key",
		MAX_RESOLUTION: "max-resolution",
		MIN_RESOLUTION: "min-resolution",
		RENDITION_ORDER: "rendition-order",
		METADATA_URL: "metadata-url",
		PLAYBACK_ID: "playback-id",
		PLAYER_SOFTWARE_NAME: "player-software-name",
		PLAYER_SOFTWARE_VERSION: "player-software-version",
		PREFER_CMCD: "prefer-cmcd",
		PREFER_PLAYBACK: "prefer-playback",
		START_TIME: "start-time",
		STREAM_TYPE: "stream-type",
		TARGET_LIVE_WINDOW: "target-live-window",
		LIVE_EDGE_OFFSET: "live-edge-offset",
		TYPE: "type"
	}, Ok = Object.values(Mk), Pk = qA, Nk = class extends ZA {
		constructor() {
			super(), OA(this, Ck), OA(this, _k, void 0), OA(this, kk, void 0), OA(this, Sk, void 0), OA(this, wk, {}), OA(this, Lk, void 0), OA(this, Rk, void 0), OA(this, Ik, void 0), OA(this, Dk, void 0), PA(this, Sk, uf.utils.now())
		}

		static get observedAttributes() {
			var e;
			return [...Ok, ...null != (e = ZA.observedAttributes) ? e : []]
		}

		get preferCmcd() {
			var e;
			return null != (e = this.getAttribute(Mk.PREFER_CMCD)) ? e : void 0
		}

		set preferCmcd(e) {
			e !== this.preferCmcd && (e ? CT.includes(e) ? this.setAttribute(Mk.PREFER_CMCD, e) : console.warn(`Invalid value for preferCmcd. Must be one of ${CT.join()}`) : this.removeAttribute(Mk.PREFER_CMCD))
		}

		get playerInitTime() {
			return MA(this, Sk)
		}

		get playerSoftwareName() {
			var e;
			return null != (e = MA(this, Ik)) ? e : "mux-video"
		}

		set playerSoftwareName(e) {
			PA(this, Ik, e)
		}

		get playerSoftwareVersion() {
			var e;
			return null != (e = MA(this, Rk)) ? e : Pk
		}

		set playerSoftwareVersion(e) {
			PA(this, Rk, e)
		}

		get _hls() {
			var e;
			return null == (e = MA(this, _k)) ? void 0 : e.engine
		}

		get mux() {
			var e;
			return null == (e = this.nativeEl) ? void 0 : e.mux
		}

		get error() {
			var e;
			return null != (e = (e => {
				var t;
				return null == (t = rA.get(e)) ? void 0 : t.error
			})(this.nativeEl)) ? e : null
		}

		get errorTranslator() {
			return MA(this, Dk)
		}

		set errorTranslator(e) {
			PA(this, Dk, e)
		}

		get src() {
			return this.getAttribute("src")
		}

		set src(e) {
			e !== this.src && (null == e ? this.removeAttribute("src") : this.setAttribute("src", e))
		}

		get type() {
			var e;
			return null != (e = this.getAttribute(Mk.TYPE)) ? e : void 0
		}

		set type(e) {
			e !== this.type && (e ? this.setAttribute(Mk.TYPE, e) : this.removeAttribute(Mk.TYPE))
		}

		get autoplay() {
			let e = this.getAttribute("autoplay");
			return null !== e && ("" === e || e)
		}

		set autoplay(e) {
			e !== this.autoplay && (e ? this.setAttribute("autoplay", "string" == typeof e ? e : "") : this.removeAttribute("autoplay"))
		}

		get preload() {
			let e = this.getAttribute("preload");
			return "" === e ? "auto" : ["none", "metadata", "auto"].includes(e) ? e : super.preload
		}

		set preload(e) {
			e != this.getAttribute("preload") && (["", "none", "metadata", "auto"].includes(e) ? this.setAttribute("preload", e) : this.removeAttribute("preload"))
		}

		get debug() {
			return null != this.getAttribute(Mk.DEBUG)
		}

		set debug(e) {
			e !== this.debug && (e ? this.setAttribute(Mk.DEBUG, "") : this.removeAttribute(Mk.DEBUG))
		}

		get disableTracking() {
			return this.hasAttribute(Mk.DISABLE_TRACKING)
		}

		set disableTracking(e) {
			e !== this.disableTracking && this.toggleAttribute(Mk.DISABLE_TRACKING, !!e)
		}

		get disableCookies() {
			return this.hasAttribute(Mk.DISABLE_COOKIES)
		}

		set disableCookies(e) {
			e !== this.disableCookies && (e ? this.setAttribute(Mk.DISABLE_COOKIES, "") : this.removeAttribute(Mk.DISABLE_COOKIES))
		}

		get startTime() {
			let e = this.getAttribute(Mk.START_TIME);
			if (null == e) return;
			let t = +e;
			return Number.isNaN(t) ? void 0 : t
		}

		set startTime(e) {
			e !== this.startTime && (null == e ? this.removeAttribute(Mk.START_TIME) : this.setAttribute(Mk.START_TIME, `${e}`))
		}

		get playbackId() {
			var e;
			return null != (e = this.getAttribute(Mk.PLAYBACK_ID)) ? e : void 0
		}

		set playbackId(e) {
			e !== this.playbackId && (e ? this.setAttribute(Mk.PLAYBACK_ID, e) : this.removeAttribute(Mk.PLAYBACK_ID))
		}

		get maxResolution() {
			var e;
			return null != (e = this.getAttribute(Mk.MAX_RESOLUTION)) ? e : void 0
		}

		set maxResolution(e) {
			e !== this.maxResolution && (e ? this.setAttribute(Mk.MAX_RESOLUTION, e) : this.removeAttribute(Mk.MAX_RESOLUTION))
		}

		get minResolution() {
			var e;
			return null != (e = this.getAttribute(Mk.MIN_RESOLUTION)) ? e : void 0
		}

		set minResolution(e) {
			e !== this.minResolution && (e ? this.setAttribute(Mk.MIN_RESOLUTION, e) : this.removeAttribute(Mk.MIN_RESOLUTION))
		}

		get renditionOrder() {
			var e;
			return null != (e = this.getAttribute(Mk.RENDITION_ORDER)) ? e : void 0
		}

		set renditionOrder(e) {
			e !== this.renditionOrder && (e ? this.setAttribute(Mk.RENDITION_ORDER, e) : this.removeAttribute(Mk.RENDITION_ORDER))
		}

		get customDomain() {
			var e;
			return null != (e = this.getAttribute(Mk.CUSTOM_DOMAIN)) ? e : void 0
		}

		set customDomain(e) {
			e !== this.customDomain && (e ? this.setAttribute(Mk.CUSTOM_DOMAIN, e) : this.removeAttribute(Mk.CUSTOM_DOMAIN))
		}

		get ended() {
			return gA(this.nativeEl, this._hls)
		}

		get envKey() {
			var e;
			return null != (e = this.getAttribute(Mk.ENV_KEY)) ? e : void 0
		}

		set envKey(e) {
			e !== this.envKey && (e ? this.setAttribute(Mk.ENV_KEY, e) : this.removeAttribute(Mk.ENV_KEY))
		}

		get beaconCollectionDomain() {
			var e;
			return null != (e = this.getAttribute(Mk.BEACON_COLLECTION_DOMAIN)) ? e : void 0
		}

		set beaconCollectionDomain(e) {
			e !== this.beaconCollectionDomain && (e ? this.setAttribute(Mk.BEACON_COLLECTION_DOMAIN, e) : this.removeAttribute(Mk.BEACON_COLLECTION_DOMAIN))
		}

		get streamType() {
			var e;
			return null != (e = this.getAttribute(Mk.STREAM_TYPE)) ? e : hA(this.nativeEl)
		}

		set streamType(e) {
			e !== this.streamType && (e ? this.setAttribute(Mk.STREAM_TYPE, e) : this.removeAttribute(Mk.STREAM_TYPE))
		}

		get targetLiveWindow() {
			return this.hasAttribute(Mk.TARGET_LIVE_WINDOW) ? +this.getAttribute(Mk.TARGET_LIVE_WINDOW) : (e => {
				var t, i;
				return null != (i = null == (t = rA.get(e)) ? void 0 : t.targetLiveWindow) ? i : Number.NaN
			})(this.nativeEl)
		}

		set targetLiveWindow(e) {
			e != this.targetLiveWindow && (null == e ? this.removeAttribute(Mk.TARGET_LIVE_WINDOW) : this.setAttribute(Mk.TARGET_LIVE_WINDOW, "" + +e))
		}

		get liveEdgeStart() {
			var e, t;
			if (this.hasAttribute(Mk.LIVE_EDGE_OFFSET)) {
				let {liveEdgeOffset: i} = this, a = null != (e = this.nativeEl.seekable.end(0)) ? e : 0,
					r = null != (t = this.nativeEl.seekable.start(0)) ? t : 0;
				return Math.max(r, a - i)
			}
			return (e => {
				var t;
				let i = null == (t = rA.get(e)) ? void 0 : t.liveEdgeStartOffset;
				if ("number" != typeof i) return Number.NaN;
				let a = cA(e);
				return a.length ? a.end(a.length - 1) - i : Number.NaN
			})(this.nativeEl)
		}

		get liveEdgeOffset() {
			if (this.hasAttribute(Mk.LIVE_EDGE_OFFSET)) return +this.getAttribute(Mk.LIVE_EDGE_OFFSET)
		}

		set liveEdgeOffset(e) {
			e != this.targetLiveWindow && (null == e ? this.removeAttribute(Mk.LIVE_EDGE_OFFSET) : this.setAttribute(Mk.LIVE_EDGE_OFFSET, "" + +e))
		}

		get seekable() {
			return cA(this.nativeEl)
		}

		get activeCuePoint() {
			return zT(this.nativeEl)
		}

		get cuePoints() {
			return function (e, t = {label: VT}) {
				let i = qT(e, t);
				return null != i && i.cues ? Array.from(i.cues, (e => jT(e))) : []
			}(this.nativeEl)
		}

		get currentPdt() {
			return function (e, t) {
				if (t && t.playingDate) return t.playingDate;
				if ("function" == typeof e.getStartDate) {
					let t = e.getStartDate();
					return new Date(t.getTime() + 1e3 * e.currentTime)
				}
				return new Date(NaN)
			}(this.nativeEl, this._hls)
		}

		get preferPlayback() {
			let e = this.getAttribute(Mk.PREFER_PLAYBACK);
			if (e === RT || e === IT) return e
		}

		set preferPlayback(e) {
			e !== this.preferPlayback && (e === RT || e === IT ? this.setAttribute(Mk.PREFER_PLAYBACK, e) : this.removeAttribute(Mk.PREFER_PLAYBACK))
		}

		get metadata() {
			return {
				...this.getAttributeNames().filter((e => e.startsWith("metadata-") && ![Mk.METADATA_URL].includes(e))).reduce(((e, t) => {
					let i = this.getAttribute(t);
					return null != i && (e[t.replace(/^metadata-/, "").replace(/-/g, "_")] = i), e
				}), {}), ...MA(this, wk)
			}
		}

		set metadata(e) {
			PA(this, wk, null != e ? e : {}), this.mux && this.mux.emit("hb", MA(this, wk))
		}

		get _hlsConfig() {
			return MA(this, Lk)
		}

		set _hlsConfig(e) {
			PA(this, Lk, e)
		}

		async addCuePoints(e) {
			return YT(this.nativeEl, e)
		}

		getStartDate() {
			return function (e, t) {
				if (t) {
					let i = t.playingDate;
					if (null != i) return new Date(i.getTime() - 1e3 * e.currentTime)
				}
				return "function" == typeof e.getStartDate ? e.getStartDate() : new Date(NaN)
			}(this.nativeEl, this._hls)
		}

		load() {
			PA(this, _k, vA(this, this.nativeEl, MA(this, _k)))
		}

		unload() {
			EA(this.nativeEl, MA(this, _k)), PA(this, _k, void 0)
		}

		attributeChangedCallback(e, t, i) {
			var a, r;
			switch (ZA.observedAttributes.includes(e) && !["src", "autoplay", "preload"].includes(e) && super.attributeChangedCallback(e, t, i), e) {
				case Mk.PLAYER_SOFTWARE_NAME:
					this.playerSoftwareName = null != i ? i : void 0;
					break;
				case Mk.PLAYER_SOFTWARE_VERSION:
					this.playerSoftwareVersion = null != i ? i : void 0;
					break;
				case"src": {
					let e = !!t, a = !!i;
					!e && a ? NA(this, Ck, xk).call(this) : e && !a ? this.unload() : e && a && (this.unload(), NA(this, Ck, xk).call(this));
					break
				}
				case"autoplay":
					if (i === t) break;
					null == (a = MA(this, _k)) || a.setAutoplay(this.autoplay);
					break;
				case"preload":
					if (i === t) break;
					null == (r = MA(this, _k)) || r.setPreload(i);
					break;
				case Mk.PLAYBACK_ID:
					this.src = dA(this);
					break;
				case Mk.DEBUG: {
					let e = this.debug;
					this.mux && console.info("Cannot toggle debug mode of mux data after initialization. Make sure you set all metadata to override before setting the src."), this._hls && (this._hls.config.debug = e);
					break
				}
				case Mk.METADATA_URL:
					i && fetch(i).then((e => e.json())).then((e => this.metadata = e)).catch((() => console.error(`Unable to load or parse metadata JSON from metadata-url ${i}!`)));
					break;
				case Mk.STREAM_TYPE:
					(null == i || i !== t) && this.dispatchEvent(new CustomEvent("streamtypechange", {
						composed: !0,
						bubbles: !0
					}));
					break;
				case Mk.TARGET_LIVE_WINDOW:
					(null == i || i !== t) && this.dispatchEvent(new CustomEvent("targetlivewindowchange", {
						composed: !0,
						bubbles: !0,
						detail: this.targetLiveWindow
					}))
			}
		}

		connectedCallback() {
			var e;
			null == (e = super.connectedCallback) || e.call(this), this.nativeEl && this.src && !MA(this, _k) && NA(this, Ck, xk).call(this)
		}

		disconnectedCallback() {
			this.unload()
		}
	};
	_k = new WeakMap, kk = new WeakMap, Sk = new WeakMap, wk = new WeakMap, Lk = new WeakMap, Rk = new WeakMap, Ik = new WeakMap, Dk = new WeakMap, Ck = new WeakSet, xk = async function () {
		MA(this, kk) || (await PA(this, kk, Promise.resolve()), PA(this, kk, null), this.load())
	};
	var Uk = class extends (N_(Tk(Nk))) {
	};
	KA.customElements.get("mux-video") || (KA.customElements.define("mux-video", Uk), KA.MuxVideoElement = Uk);
	var Fk = Uk, Bk = {code: "en"}, $k = "en";

	function Hk(e, t = !0) {
		var i, a;
		let r = t && null != (a = null == (i = Bk) ? void 0 : i[e]) ? a : e, n = t ? Bk.code : $k;
		return new Wk(r, n)
	}

	var Wk = class {
		constructor(e, t = (e => null != (e = Bk.code) ? e : $k)()) {
			this.message = e, this.locale = t
		}

		format(e) {
			return this.message.replace(/\{(\w+)\}/g, ((t, i) => {
				var a;
				return null != (a = e[i]) ? a : ""
			}))
		}

		toString() {
			return this.message
		}
	};

	function Gk(e) {
		return e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
	}

	function Vk(e) {
		return e.replace(/[-_]([a-z])/g, ((e, t) => t.toUpperCase()))
	}

	function Kk(e) {
		if (null == e) return;
		let t = +e;
		return Number.isNaN(t) ? void 0 : t
	}

	function qk(e) {
		let t = function (e) {
			let t = {};
			for (let i in e) null != e[i] && (t[i] = e[i]);
			return new URLSearchParams(t)
		}(e).toString();
		return t ? "?" + t : ""
	}

	function Yk(e) {
		let t = (null != e ? e : "").split(".")[1];
		if (!t) return {};
		let i = t.replace(/-/g, "+").replace(/_/g, "/"), a = decodeURIComponent(atob(i).split("").map((function (e) {
			return "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2)
		})).join(""));
		return JSON.parse(a)
	}

	var jk = (e, t) => !(!e || !t) && (!!e.contains(t) || jk(e, t.getRootNode().host)), zk = "mux.com", Xk = (() => {
		try {
			return "2.5.0"
		} catch {
		}
		return "UNKNOWN"
	})(), Qk = () => Xk, Zk = e => {
		if (e) {
			if ([LT.LIVE, LT.ON_DEMAND].includes(e)) return e;
			if (null != e && e.includes("live")) return LT.LIVE
		}
	}, Jk = {crossorigin: "crossOrigin", playsinline: "playsInline"};

	function eS(e) {
		var t;
		return null != (t = Jk[e]) ? t : Vk(e)
	}

	var tS, iS, aS, rS = class {
		constructor(e, t) {
			i(this, tS, void 0), i(this, iS, void 0), i(this, aS, []), a(this, tS, e), a(this, iS, t)
		}

		get length() {
			return t(this, aS).length
		}

		get value() {
			var e;
			return null != (e = t(this, aS).join(" ")) ? e : ""
		}

		set value(e) {
			var t;
			e !== this.value && (a(this, aS, []), this.add(...null != (t = null == e ? void 0 : e.split(" ")) ? t : []))
		}

		[Symbol.iterator]() {
			return t(this, aS).values()
		}

		toString() {
			return this.value
		}

		item(e) {
			return t(this, aS)[e]
		}

		values() {
			return t(this, aS).values()
		}

		keys() {
			return t(this, aS).keys()
		}

		forEach(e) {
			t(this, aS).forEach(e)
		}

		add(...e) {
			var i, a;
			e.forEach((e => {
				this.contains(e) || t(this, aS).push(e)
			})), ("" !== this.value || null != (i = t(this, tS)) && i.hasAttribute(`${t(this, iS)}`)) && (null == (a = t(this, tS)) || a.setAttribute(`${t(this, iS)}`, `${this.value}`))
		}

		remove(...e) {
			var i;
			e.forEach((e => {
				t(this, aS).splice(t(this, aS).indexOf(e), 1)
			})), null == (i = t(this, tS)) || i.setAttribute(`${t(this, iS)}`, `${this.value}`)
		}

		contains(e) {
			return t(this, aS).includes(e)
		}

		toggle(e, t) {
			return void 0 !== t ? t ? (this.add(e), !0) : (this.remove(e), !1) : this.contains(e) ? (this.remove(e), !1) : (this.add(e), !0)
		}

		replace(e, t) {
			this.remove(e), this.add(t)
		}
	};
	tS = new WeakMap, iS = new WeakMap, aS = new WeakMap;
	var nS = `[mux-player ${Qk()}]`;

	function sS(...e) {
		console.warn(nS, ...e)
	}

	function oS(...e) {
		console.error(nS, ...e)
	}

	function lS(e) {
		var t;
		let i = null != (t = e.message) ? t : "";
		if (e.context && (i += ` ${e.context}`), e.file) {
			let t = "https://github.com/muxinc/elements/blob/main/errors/";
			i += ` ${Hk("Read more: ")}\n${t}${e.file}`
		}
		sS(i)
	}

	var dS = {
			AUTOPLAY: "autoplay",
			CROSSORIGIN: "crossorigin",
			LOOP: "loop",
			MUTED: "muted",
			PLAYSINLINE: "playsinline",
			PRELOAD: "preload"
		}, uS = {VOLUME: "volume", PLAYBACKRATE: "playbackrate", MUTED: "muted"}, hS = Object.freeze({
			length: 0, start(e) {
				let t = e >>> 0;
				if (t >= this.length) throw new DOMException(`Failed to execute 'start' on 'TimeRanges': The index provided (${t}) is greater than or equal to the maximum bound (${this.length}).`);
				return 0
			}, end(e) {
				let t = e >>> 0;
				if (t >= this.length) throw new DOMException(`Failed to execute 'end' on 'TimeRanges': The index provided (${t}) is greater than or equal to the maximum bound (${this.length}).`);
				return 0
			}
		}), cS = YA.filter((e => "error" !== e)), mS = Object.values(dS).filter((e => ![dS.PLAYSINLINE].includes(e))),
		fS = Object.values(uS);
	var pS = class extends h.HTMLElement {
		constructor() {
			super(), this.querySelectorAll(":scope > track").forEach((e => {
				var t;
				null == (t = this.media) || t.append(e.cloneNode())
			}));
			new MutationObserver((e => {
				for (let t of e) "childList" === t.type && (t.removedNodes.forEach((e => {
					var t, i;
					let a = null == (t = this.media) ? void 0 : t.querySelector(`track[src="${e.src}"]`);
					a && (null == (i = this.media) || i.removeChild(a))
				})), t.addedNodes.forEach((e => {
					var t;
					null == (t = this.media) || t.append(e.cloneNode())
				})))
			})).observe(this, {childList: !0, subtree: !0})
		}

		static get observedAttributes() {
			return [...mS, ...fS]
		}

		get media() {
			var e;
			return null == (e = this.shadowRoot) ? void 0 : e.querySelector("mux-video")
		}

		get audioTracks() {
			return this.media.audioTracks
		}

		get videoTracks() {
			return this.media.videoTracks
		}

		get audioRenditions() {
			return this.media.audioRenditions
		}

		get videoRenditions() {
			return this.media.videoRenditions
		}

		get paused() {
			var e, t;
			return null == (t = null == (e = this.media) ? void 0 : e.paused) || t
		}

		get duration() {
			var e, t;
			return null != (t = null == (e = this.media) ? void 0 : e.duration) ? t : NaN
		}

		get ended() {
			var e, t;
			return null != (t = null == (e = this.media) ? void 0 : e.ended) && t
		}

		get buffered() {
			var e, t;
			return null != (t = null == (e = this.media) ? void 0 : e.buffered) ? t : hS
		}

		get seekable() {
			var e, t;
			return null != (t = null == (e = this.media) ? void 0 : e.seekable) ? t : hS
		}

		get readyState() {
			var e, t;
			return null != (t = null == (e = this.media) ? void 0 : e.readyState) ? t : 0
		}

		get videoWidth() {
			var e, t;
			return null != (t = null == (e = this.media) ? void 0 : e.videoWidth) ? t : 0
		}

		get videoHeight() {
			var e, t;
			return null != (t = null == (e = this.media) ? void 0 : e.videoHeight) ? t : 0
		}

		get currentTime() {
			var e, t;
			return null != (t = null == (e = this.media) ? void 0 : e.currentTime) ? t : 0
		}

		set currentTime(e) {
			this.media && (this.media.currentTime = Number(e))
		}

		get volume() {
			var e, t;
			return null != (t = null == (e = this.media) ? void 0 : e.volume) ? t : 1
		}

		set volume(e) {
			this.media && (this.media.volume = Number(e))
		}

		get playbackRate() {
			var e, t;
			return null != (t = null == (e = this.media) ? void 0 : e.playbackRate) ? t : 1
		}

		set playbackRate(e) {
			this.media && (this.media.playbackRate = Number(e))
		}

		get defaultPlaybackRate() {
			var e;
			return null != (e = Kk(this.getAttribute(uS.PLAYBACKRATE))) ? e : 1
		}

		set defaultPlaybackRate(e) {
			null != e ? this.setAttribute(uS.PLAYBACKRATE, `${e}`) : this.removeAttribute(uS.PLAYBACKRATE)
		}

		get crossOrigin() {
			return gS(this, dS.CROSSORIGIN)
		}

		set crossOrigin(e) {
			this.setAttribute(dS.CROSSORIGIN, `${e}`)
		}

		get autoplay() {
			return null != gS(this, dS.AUTOPLAY)
		}

		set autoplay(e) {
			e ? this.setAttribute(dS.AUTOPLAY, "string" == typeof e ? e : "") : this.removeAttribute(dS.AUTOPLAY)
		}

		get loop() {
			return null != gS(this, dS.LOOP)
		}

		set loop(e) {
			e ? this.setAttribute(dS.LOOP, "") : this.removeAttribute(dS.LOOP)
		}

		get muted() {
			var e, t;
			return null != (t = null == (e = this.media) ? void 0 : e.muted) && t
		}

		set muted(e) {
			this.media && (this.media.muted = !!e)
		}

		get defaultMuted() {
			return null != gS(this, dS.MUTED)
		}

		set defaultMuted(e) {
			e ? this.setAttribute(dS.MUTED, "") : this.removeAttribute(dS.MUTED)
		}

		get playsInline() {
			return null != gS(this, dS.PLAYSINLINE)
		}

		set playsInline(e) {
			oS("playsInline is set to true by default and is not currently supported as a setter.")
		}

		get preload() {
			return this.media ? this.media.preload : this.getAttribute("preload")
		}

		set preload(e) {
			["", "none", "metadata", "auto"].includes(e) ? this.setAttribute(dS.PRELOAD, e) : this.removeAttribute(dS.PRELOAD)
		}

		attributeChangedCallback(e, t, i) {
			var a, r;
			switch (e) {
				case uS.MUTED:
					return void (this.media && (this.media.muted = null != i, this.media.defaultMuted = null != i));
				case uS.VOLUME: {
					let e = null != (a = Kk(i)) ? a : 1;
					return void (this.media && (this.media.volume = e))
				}
				case uS.PLAYBACKRATE: {
					let e = null != (r = Kk(i)) ? r : 1;
					return void (this.media && (this.media.playbackRate = e, this.media.defaultPlaybackRate = e))
				}
			}
		}

		play() {
			var e, t;
			return null != (t = null == (e = this.media) ? void 0 : e.play()) ? t : Promise.reject()
		}

		pause() {
			var e;
			null == (e = this.media) || e.pause()
		}

		requestCast(e) {
			var t;
			return null == (t = this.media) ? void 0 : t.requestCast(e)
		}
	};

	function gS(e, t) {
		return e.media ? e.media.getAttribute(t) : e.getAttribute(t)
	}

	var vS, ES, bS, yS, TS, AS, _S, kS, SS, wS, LS, RS = pS, IS = Object.defineProperty,
		DS = (e, t, i) => (((e, t, i) => {
			t in e ? IS(e, t, {enumerable: !0, configurable: !0, writable: !0, value: i}) : e[t] = i
		})(e, "symbol" != typeof t ? t + "" : t, i), i), CS = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, xS = (e, t, i) => (CS(e, t, "read from private field"), i ? i.call(e) : t.get(e)), MS = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, OS = (e, t, i, a) => (CS(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i), PS = {
			processCallback(e, t, i) {
				if (i) for (let [e, a] of t) if (e in i) {
					let t = i[e];
					"boolean" == typeof t && a instanceof GS && "boolean" == typeof a.element[a.attributeName] ? a.booleanValue = t : "function" == typeof t && a instanceof GS ? a.element[a.attributeName] = t : a.value = t
				}
			}
		}, NS = class extends z.DocumentFragment {
			constructor(e, t, i = PS) {
				var a;
				super(), MS(this, vS, void 0), MS(this, ES, void 0), this.append(e.content.cloneNode(!0)), OS(this, vS, US(this)), OS(this, ES, i), null == (a = i.createCallback) || a.call(i, this, xS(this, vS), t), i.processCallback(this, xS(this, vS), t)
			}

			update(e) {
				xS(this, ES).processCallback(this, xS(this, vS), e)
			}
		};
	vS = new WeakMap, ES = new WeakMap;
	var US = (e, t = []) => {
		let i, a;
		for (let r of e.attributes || []) if (r.value.includes("{{")) {
			let n = new WS;
			for ([i, a] of BS(r.value)) if (i) {
				let i = new GS(e, r.name, r.namespaceURI);
				n.append(i), t.push([a, i])
			} else n.append(a);
			r.value = n.toString()
		}
		for (let r of e.childNodes) if (1 !== r.nodeType || r instanceof HTMLTemplateElement) {
			if (1 === r.nodeType || r.data.includes("{{")) {
				let n = [];
				if (r.data) for ([i, a] of BS(r.data)) if (i) {
					let i = new VS(e);
					n.push(i), t.push([a, i])
				} else n.push(new Text(a)); else if (r instanceof HTMLTemplateElement) {
					let i = new KS(e, r);
					n.push(i), t.push([i.expression, i])
				}
				r.replaceWith(...n.flatMap((e => e.replacementNodes || [e])))
			}
		} else US(r, t);
		return t
	}, FS = {}, BS = e => {
		let t, i = "", a = 0, r = FS[e], n = 0;
		if (r) return r;
		for (r = []; t = e[n]; n++) "{" === t && "{" === e[n + 1] && "\\" !== e[n - 1] && e[n + 2] && 1 == ++a ? (i && r.push([0, i]), i = "", n++) : "}" !== t || "}" !== e[n + 1] || "\\" === e[n - 1] || --a ? i += t || "" : (r.push([1, i.trim()]), i = "", n++);
		return i && r.push([0, (a > 0 ? "{{" : "") + i]), FS[e] = r
	}, $S = class {
		get value() {
			return ""
		}

		set value(e) {
		}

		toString() {
			return this.value
		}
	}, HS = new WeakMap, WS = class {
		constructor() {
			MS(this, bS, [])
		}

		get length() {
			return xS(this, bS).length
		}

		[Symbol.iterator]() {
			return xS(this, bS).values()
		}

		item(e) {
			return xS(this, bS)[e]
		}

		append(...e) {
			for (let t of e) t instanceof GS && HS.set(t, this), xS(this, bS).push(t)
		}

		toString() {
			return xS(this, bS).join("")
		}
	};
	bS = new WeakMap;
	var GS = class extends $S {
		constructor(e, t, i) {
			super(), MS(this, kS), MS(this, yS, ""), MS(this, TS, void 0), MS(this, AS, void 0), MS(this, _S, void 0), OS(this, TS, e), OS(this, AS, t), OS(this, _S, i)
		}

		get attributeName() {
			return xS(this, AS)
		}

		get attributeNamespace() {
			return xS(this, _S)
		}

		get element() {
			return xS(this, TS)
		}

		get value() {
			return xS(this, yS)
		}

		set value(e) {
			xS(this, yS) !== e && (OS(this, yS, e), xS(this, kS, SS) && 1 !== xS(this, kS, SS).length ? xS(this, TS).setAttributeNS(xS(this, _S), xS(this, AS), xS(this, kS, SS)) : null == e ? xS(this, TS).removeAttributeNS(xS(this, _S), xS(this, AS)) : xS(this, TS).setAttributeNS(xS(this, _S), xS(this, AS), e))
		}

		get booleanValue() {
			return xS(this, TS).hasAttributeNS(xS(this, _S), xS(this, AS))
		}

		set booleanValue(e) {
			if (xS(this, kS, SS) && 1 !== xS(this, kS, SS).length) throw new DOMException("Value is not fully templatized");
			this.value = e ? "" : null
		}
	};
	yS = new WeakMap, TS = new WeakMap, AS = new WeakMap, _S = new WeakMap, kS = new WeakSet, SS = function () {
		return HS.get(this)
	};
	var VS = class extends $S {
		constructor(e, t) {
			super(), MS(this, wS, void 0), MS(this, LS, void 0), OS(this, wS, e), OS(this, LS, t ? [...t] : [new Text])
		}

		get replacementNodes() {
			return xS(this, LS)
		}

		get parentNode() {
			return xS(this, wS)
		}

		get nextSibling() {
			return xS(this, LS)[xS(this, LS).length - 1].nextSibling
		}

		get previousSibling() {
			return xS(this, LS)[0].previousSibling
		}

		get value() {
			return xS(this, LS).map((e => e.textContent)).join("")
		}

		set value(e) {
			this.replace(e)
		}

		replace(...e) {
			let t = e.flat().flatMap((e => null == e ? [new Text] : e.forEach ? [...e] : 11 === e.nodeType ? [...e.childNodes] : e.nodeType ? [e] : [new Text(e)]));
			t.length || t.push(new Text), OS(this, LS, function (e, t, i, a = null) {
				let r, n, s, o = 0, l = i.length, d = t.length;
				for (; o < l && o < d && t[o] == i[o];) o++;
				for (; o < l && o < d && i[l - 1] == t[d - 1];) a = i[(--d, --l)];
				if (o == d) for (; o < l;) e.insertBefore(i[o++], a);
				if (o == l) for (; o < d;) e.removeChild(t[o++]); else {
					for (r = t[o]; o < l;) s = i[o++], n = r ? r.nextSibling : a, r == s ? r = n : o < l && i[o] == n ? (e.replaceChild(s, r), r = n) : e.insertBefore(s, r);
					for (; r != a;) n = r.nextSibling, e.removeChild(r), r = n
				}
				return i
			}(xS(this, LS)[0].parentNode, xS(this, LS), t, this.nextSibling))
		}
	};
	wS = new WeakMap, LS = new WeakMap;
	var KS = class extends VS {
		constructor(e, t) {
			let i = t.getAttribute("directive") || t.getAttribute("type"),
				a = t.getAttribute("expression") || t.getAttribute(i) || "";
			a.startsWith("{{") && (a = a.trim().slice(2, -2).trim()), super(e), DS(this, "directive"), this.expression = a, this.template = t, this.directive = i
		}
	};
	var qS = {string: e => String(e)}, YS = class {
		constructor(e) {
			this.template = e, this.state = void 0
		}
	}, jS = new WeakMap, zS = new WeakMap, XS = {
		partial: (e, t) => {
			t[e.expression] = new YS(e.template)
		}, if: (e, t) => {
			var i;
			if (ew(e.expression, t)) if (jS.get(e) !== e.template) {
				jS.set(e, e.template);
				let i = new NS(e.template, t, ZS);
				e.replace(i), zS.set(e, i)
			} else null == (i = zS.get(e)) || i.update(t); else e.replace(""), jS.delete(e), zS.delete(e)
		}
	}, QS = Object.keys(XS), ZS = {
		processCallback(e, t, i) {
			var a, r;
			if (i) for (let [e, n] of t) {
				if (n instanceof KS) {
					if (!n.directive) {
						let e = QS.find((e => n.template.hasAttribute(e)));
						e && (n.directive = e, n.expression = n.template.getAttribute(e))
					}
					null == (a = XS[n.directive]) || a.call(XS, n, i);
					continue
				}
				let t = ew(e, i);
				t instanceof YS ? jS.get(n) !== t.template ? (jS.set(n, t.template), t = new NS(t.template, t.state, ZS), n.value = t, zS.set(n, t)) : null == (r = zS.get(n)) || r.update(t.state) : t ? (n instanceof GS && n.attributeName.startsWith("aria-") && (t = String(t)), n instanceof GS ? "boolean" == typeof t ? n.booleanValue = t : "function" == typeof t ? n.element[n.attributeName] = t : n.value = t : (n.value = t, jS.delete(n), zS.delete(n))) : n instanceof GS ? n.value = void 0 : (n.value = void 0, jS.delete(n), zS.delete(n))
			}
		}
	}, JS = {
		"!": e => !e,
		"!!": e => !!e,
		"==": (e, t) => e == t,
		"!=": (e, t) => e != t,
		">": (e, t) => e > t,
		">=": (e, t) => e >= t,
		"<": (e, t) => e < t,
		"<=": (e, t) => e <= t,
		"??": (e, t) => null != e ? e : t,
		"|": (e, t) => {
			var i;
			return null == (i = qS[t]) ? void 0 : i.call(qS, e)
		}
	};

	function ew(e, t = {}) {
		var i, a, r, n, s, o, l;
		let d = function (e) {
			return function (e, t) {
				let i, a, r, n = [];
				for (; e;) {
					r = null, i = e.length;
					for (let n in t) a = t[n].exec(e), a && a.index < i && (r = {
						token: a[0],
						type: n,
						matches: a.slice(1)
					}, i = a.index);
					i && n.push({
						token: e.substr(0, i),
						type: void 0
					}), r && n.push(r), e = e.substr(i + (r ? r.token.length : 0))
				}
				return n
			}(e, {
				boolean: /true|false/,
				number: /-?\d+\.?\d*/,
				string: /(["'])((?:\\.|[^\\])*?)\1/,
				operator: /[!=><][=!]?|\?\?|\|/,
				ws: /\s+/,
				param: /[$a-z_][$\w]*/i
			}).filter((({type: e}) => "ws" !== e))
		}(e);
		if (0 === d.length || d.some((({type: e}) => !e))) return tw(e);
		if (">" === (null == (i = d[0]) ? void 0 : i.token)) {
			let i = t[null == (a = d[1]) ? void 0 : a.token];
			if (!i) return tw(e);
			let o = {...t};
			i.state = o;
			let l = d.slice(2);
			for (let e = 0; e < l.length; e += 3) {
				let i = null == (r = l[e]) ? void 0 : r.token, a = null == (n = l[e + 1]) ? void 0 : n.token,
					d = null == (s = l[e + 2]) ? void 0 : s.token;
				i && "=" === a && (o[i] = aw(d, t))
			}
			return i
		}
		if (1 === d.length) return iw(d[0]) ? aw(d[0].token, t) : tw(e);
		if (2 === d.length) {
			let i = null == (o = d[0]) ? void 0 : o.token, a = JS[i];
			return a && iw(d[1]) ? a(aw(d[1].token, t)) : tw(e)
		}
		if (3 === d.length) {
			let i = null == (l = d[1]) ? void 0 : l.token, a = JS[i];
			if (!a || !iw(d[0]) || !iw(d[2])) return tw(e);
			let r = aw(d[0].token, t);
			return a(r, "|" === i ? d[2].token : aw(d[2].token, t))
		}
	}

	function tw(e) {
		return console.warn(`Warning: invalid expression \`${e}\``), !1
	}

	function iw({type: e}) {
		return ["number", "boolean", "string", "param"].includes(e)
	}

	function aw(e, t) {
		let i = e[0], a = e.slice(-1);
		return "true" === e || "false" === e ? "true" === e : i === a && ["'", '"'].includes(i) ? e.slice(1, -1) : F(e) ? parseFloat(e) : t[e]
	}

	var rw, nw, sw, ow, lw, dw, uw, hw = Object.defineProperty, cw = (e, t, i) => (((e, t, i) => {
			t in e ? hw(e, t, {enumerable: !0, configurable: !0, writable: !0, value: i}) : e[t] = i
		})(e, "symbol" != typeof t ? t + "" : t, i), i), mw = (e, t, i) => {
			if (!t.has(e)) throw TypeError("Cannot " + i)
		}, fw = (e, t, i) => (mw(e, t, "read from private field"), i ? i.call(e) : t.get(e)), pw = (e, t, i) => {
			if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
			t instanceof WeakSet ? t.add(e) : t.set(e, i)
		}, gw = (e, t, i, a) => (mw(e, t, "write to private field"), a ? a.call(e, i) : t.set(e, i), i),
		vw = (e, t, i) => (mw(e, t, "access private method"), i),
		Ew = {mediatargetlivewindow: "targetlivewindow", mediastreamtype: "streamtype"},
		bw = X.createElement("template");
	bw.innerHTML = "\n  <style>\n    :host {\n      display: inline-block;\n      line-height: 0;\n    }\n\n    media-controller {\n      width: 100%;\n      height: 100%;\n    }\n\n    media-controller:not([mediasubtitleslist]) media-captions-selectmenu,\n    media-captions-button:not([mediasubtitleslist]),\n    media-rendition-selectmenu[mediarenditionunavailable],\n    media-audio-track-selectmenu[mediaaudiotrackunavailable],\n    media-volume-range[mediavolumeunavailable],\n    media-airplay-button[mediaairplayunavailable],\n    media-fullscreen-button[mediafullscreenunavailable],\n    media-cast-button[mediacastunavailable],\n    media-pip-button[mediapipunavailable] {\n      display: none;\n    }\n  </style>\n";
	var yw = class extends z.HTMLElement {
		constructor() {
			super(), pw(this, ow), pw(this, dw), cw(this, "renderRoot"), cw(this, "renderer"), pw(this, rw, void 0), pw(this, nw, void 0), pw(this, sw, void 0), this.shadowRoot ? this.renderRoot = this.shadowRoot : (this.renderRoot = this.attachShadow({mode: "open"}), this.createRenderer());
			let e = new MutationObserver((e => {
				var t;
				this.mediaController && (null == (t = this.mediaController) || !t.breakpointsComputed) || e.some((e => {
					let t = e.target;
					return t === this || "media-controller" === t.localName && !(!Ew[e.attributeName] && !e.attributeName.startsWith("breakpoint"))
				})) && this.render()
			}));
			e.observe(this, {attributes: !0}), e.observe(this.renderRoot, {
				attributes: !0,
				subtree: !0
			}), this.addEventListener(E.BREAKPOINTS_COMPUTED, this.render), vw(this, ow, lw).call(this, "template")
		}

		get mediaController() {
			return this.renderRoot.querySelector("media-controller")
		}

		get template() {
			var e;
			return null != (e = fw(this, rw)) ? e : this.constructor.template
		}

		set template(e) {
			gw(this, sw, null), gw(this, rw, e), this.createRenderer()
		}

		get props() {
			var e, t, i;
			let a = [...Array.from(null != (t = null == (e = this.mediaController) ? void 0 : e.attributes) ? t : []).filter((({name: e}) => Ew[e] || e.startsWith("breakpoint"))), ...Array.from(this.attributes)],
				r = {};
			for (let e of a) {
				let t = null != (i = Ew[e.name]) ? i : U(e.name), {value: a} = e;
				null != a ? (F(a) && (a = parseFloat(a)), r[t] = "" === a || a) : r[t] = !1
			}
			return r
		}

		attributeChangedCallback(e, t, i) {
			"template" === e && t != i && vw(this, dw, uw).call(this)
		}

		connectedCallback() {
			vw(this, dw, uw).call(this)
		}

		createRenderer() {
			this.template && this.template !== fw(this, nw) && (gw(this, nw, this.template), this.renderer = new NS(this.template, this.props, this.constructor.processor), this.renderRoot.textContent = "", this.renderRoot.append(bw.content.cloneNode(!0), this.renderer))
		}

		render() {
			var e;
			null == (e = this.renderer) || e.update(this.props)
		}
	};
	rw = new WeakMap, nw = new WeakMap, sw = new WeakMap, ow = new WeakSet, lw = function (e) {
		if (Object.prototype.hasOwnProperty.call(this, e)) {
			let t = this[e];
			delete this[e], this[e] = t
		}
	}, dw = new WeakSet, uw = function () {
		var e;
		let t = this.getAttribute("template");
		if (!t || t === fw(this, sw)) return;
		let i = this.getRootNode(), a = null == (e = null == i ? void 0 : i.getElementById) ? void 0 : e.call(i, t);
		if (a) return gw(this, sw, t), gw(this, rw, a), void this.createRenderer();
		(function (e) {
			if (!/^(\/|\.\/|https?:\/\/)/.test(e)) return !1;
			let t = /^https?:\/\//.test(e) ? void 0 : location.origin;
			try {
				new URL(e, t)
			} catch {
				return !1
			}
			return !0
		})(t) && (gw(this, sw, t), async function (e) {
			let t = await fetch(e);
			if (200 !== t.status) throw new Error(`Failed to load resource: the server responded with a status of ${t.status}`);
			return t.text()
		}(t).then((e => {
			let t = X.createElement("template");
			t.innerHTML = e, gw(this, rw, t), this.createRenderer()
		})).catch(console.error))
	}, cw(yw, "template"), cw(yw, "observedAttributes", ["template"]), cw(yw, "processor", ZS), z.customElements.get("media-theme") || z.customElements.define("media-theme", yw);
	var Tw = "\n  :host {\n    z-index: 100;\n    display: var(--media-dialog-display, flex);\n    justify-content: center;\n    align-items: center;\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    box-sizing: border-box;\n    color: #fff;\n    line-height: 18px;\n    font-family: Arial, sans-serif;\n    padding: var(--media-dialog-backdrop-padding, 0);\n    background: var(--media-dialog-backdrop-background,\n      linear-gradient(to bottom, rgba(20, 20, 30, 0.7) 50%, rgba(20, 20, 30, 0.9))\n    );\n    /* Needs to use !important to prevent overwrite of media-chrome */\n    transition: var(--media-dialog-transition-open, visibility .2s, opacity .2s) !important;\n    transform: var(--media-dialog-transform-open, none) !important;\n    visibility: visible !important;\n    opacity: 1 !important;\n    pointer-events: auto !important;\n  }\n\n  :host(:not([open])) {\n    /* Needs to use !important to prevent overwrite of media-chrome */\n    transition: var(--media-dialog-transition-close, visibility .1s, opacity .1s) !important;\n    transform: var(--media-dialog-transform-close, none) !important;\n    visibility: hidden !important;\n    opacity: 0 !important;\n    pointer-events: none !important;\n  }\n\n  :focus-visible {\n    box-shadow: 0 0 0 2px rgba(27, 127, 204, 0.9);\n  }\n\n  .dialog {\n    position: relative;\n    box-sizing: border-box;\n    background: var(--media-dialog-background, none);\n    padding: var(--media-dialog-padding, 10px);\n    width: min(320px, 100%);\n    word-wrap: break-word;\n    max-height: 100%;\n    overflow: auto;\n    text-align: center;\n    line-height: 1.4;\n  }\n",
		Aw = c.createElement("template");
	Aw.innerHTML = `\n  <style>\n    ${Tw}\n  </style>\n\n  <div class="dialog">\n    <slot></slot>\n  </div>\n`;
	var _w = class extends h.HTMLElement {
		constructor() {
			var e;
			super(), this.attachShadow({mode: "open"}), null == (e = this.shadowRoot) || e.appendChild(this.constructor.template.content.cloneNode(!0))
		}

		show() {
			this.setAttribute("open", ""), this.dispatchEvent(new CustomEvent("open", {
				composed: !0,
				bubbles: !0
			})), kw(this)
		}

		close() {
			this.hasAttribute("open") && (this.removeAttribute("open"), this.dispatchEvent(new CustomEvent("close", {
				composed: !0,
				bubbles: !0
			})), function (e) {
				e._previouslyFocusedElement instanceof HTMLElement && e._previouslyFocusedElement.focus()
			}(this))
		}

		attributeChangedCallback(e, t, i) {
			"open" === e && t !== i && (null != i ? this.show() : this.close())
		}

		connectedCallback() {
			this.hasAttribute("role") || this.setAttribute("role", "dialog"), this.hasAttribute("open") && kw(this)
		}
	};

	function kw(e) {
		let t = new CustomEvent("initfocus", {composed: !0, bubbles: !0, cancelable: !0});
		if (e.dispatchEvent(t), t.defaultPrevented) return;
		let i = e.querySelector("[autofocus]:not([disabled])");
		!i && e.tabIndex >= 0 && (i = e), i || (i = Sw(e.shadowRoot)), e._previouslyFocusedElement = c.activeElement, c.activeElement instanceof HTMLElement && c.activeElement.blur(), e.addEventListener("transitionend", (() => {
			i instanceof HTMLElement && i.focus({preventScroll: !0})
		}), {once: !0})
	}

	function Sw(e) {
		let t = ["button", "input", "keygen", "select", "textarea"].map((function (e) {
			return e + ":not([disabled])"
		}));
		t.push('[tabindex]:not([disabled]):not([tabindex=""])');
		let i = null == e ? void 0 : e.querySelector(t.join(", "));
		if (!i && "attachShadow" in Element.prototype) {
			let t = (null == e ? void 0 : e.querySelectorAll("*")) || [];
			for (let e = 0; e < t.length && !(t[e].tagName && t[e].shadowRoot && (i = Sw(t[e].shadowRoot), i)); e++) ;
		}
		return i
	}

	_w.styles = Tw, _w.template = Aw, _w.observedAttributes = ["open"], h.customElements.get("media-dialog") || (h.customElements.define("media-dialog", _w), h.MediaDialog = _w);
	var ww = _w, Lw = c.createElement("template");
	Lw.innerHTML = `\n  <style>\n    ${ww.styles}\n\n    .close {\n      background: none;\n      color: inherit;\n      border: none;\n      padding: 0;\n      font: inherit;\n      cursor: pointer;\n      outline: inherit;\n      width: 28px;\n      height: 28px;\n      position: absolute;\n      top: 1rem;\n      right: 1rem;\n    }\n  </style>\n\n  <div class="dialog">\n    <slot></slot>\n  </div>\n\n  <slot name="close">\n    <button class="close" tabindex="0">\n      <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">\n        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />\n      </svg>\n    </button>\n  </slot>\n`;
	var Rw = class extends ww {
		constructor() {
			var e, t;
			super(), null == (t = null == (e = this.shadowRoot) ? void 0 : e.querySelector(".close")) || t.addEventListener("click", (() => {
				this.close()
			}))
		}
	};
	Rw.template = Lw, h.customElements.get("mxp-dialog") || (h.customElements.define("mxp-dialog", Rw), h.MxpDialog = Rw);
	var Iw = new WeakMap, Dw = class e {
		constructor(e, t) {
			this.element = e, this.type = t, this.element.addEventListener(this.type, this);
			let i = Iw.get(this.element);
			i && i.set(this.type, this)
		}

		static for(t) {
			Iw.has(t.element) || Iw.set(t.element, new Map);
			let i = t.attributeName.slice(2), a = Iw.get(t.element);
			return a && a.has(i) ? a.get(i) : new e(t.element, i)
		}

		set(e) {
			if ("function" == typeof e) this.handleEvent = e.bind(this.element); else if ("object" == typeof e && "function" == typeof e.handleEvent) this.handleEvent = e.handleEvent.bind(e); else {
				this.element.removeEventListener(this.type, this);
				let e = Iw.get(this.element);
				e && e.delete(this.type)
			}
		}
	};

	function Cw(e, t) {
		(function (e, t) {
			if (e instanceof GS && t instanceof Element) {
				let i = e.element;
				return i[e.attributeName] !== t && (e.element.removeAttributeNS(e.attributeNamespace, e.attributeName), i[e.attributeName] = t), !0
			}
			return !1
		})(e, t) || function (e, t) {
			if ("boolean" == typeof t && e instanceof GS) {
				let i = e.attributeNamespace;
				return t !== e.element.hasAttributeNS(i, e.attributeName) && (e.booleanValue = t), !0
			}
			return !1
		}(e, t) || function (e, t) {
			return !!(e instanceof GS && e.attributeName.startsWith("on")) && (Dw.for(e).set(t), e.element.removeAttributeNS(e.attributeNamespace, e.attributeName), !0)
		}(e, t) || function (e, t) {
			return !1 === t && e instanceof VS && (e.replace(""), !0)
		}(e, t) || function (e, t) {
			return t instanceof Pw && e instanceof VS && (t.renderInto(e), !0)
		}(e, t) || function (e, t) {
			return t instanceof DocumentFragment && e instanceof VS && (t.childNodes.length && e.replace(...t.childNodes), !0)
		}(e, t) || function (e, t) {
			if (e instanceof GS) {
				let i = e.attributeNamespace, a = e.element.getAttributeNS(i, e.attributeName);
				return String(t) !== a && (e.value = String(t)), !0
			}
			e.value = String(t)
		}(e, t)
	}

	var xw = new Map, Mw = new WeakMap, Ow = new WeakMap, Pw = class {
		constructor(e, t, i) {
			this.strings = e, this.values = t, this.processor = i, this.stringsKey = this.strings.join("")
		}

		get template() {
			if (xw.has(this.stringsKey)) return xw.get(this.stringsKey);
			{
				let e = c.createElement("template"), t = this.strings.length - 1;
				return e.innerHTML = this.strings.reduce(((e, i, a) => e + i + (a < t ? `{{ ${a} }}` : "")), ""), xw.set(this.stringsKey, e), e
			}
		}

		renderInto(e) {
			var t;
			let i = this.template;
			if (Mw.get(e) !== i) {
				Mw.set(e, i);
				let t = new NS(i, this.values, this.processor);
				return Ow.set(e, t), void (e instanceof VS ? e.replace(...t.children) : e.appendChild(t))
			}
			let a = Ow.get(e);
			null == (t = null == a ? void 0 : a.update) || t.call(a, this.values)
		}
	}, Nw = {
		processCallback(e, t, i) {
			var a;
			if (i) for (let [e, r] of t) if (e in i) {
				Cw(r, null != (a = i[e]) ? a : "")
			}
		}
	};

	function Uw(e, ...t) {
		return new Pw(e, t, Nw)
	}

	var Fw = Object.values({
		TOP: "top",
		CENTER: "center",
		BOTTOM: "bottom",
		LAYER: "layer",
		MEDIA_LAYER: "media-layer",
		POSTER_LAYER: "poster-layer",
		VERTICAL_LAYER: "vertical-layer",
		CENTERED_LAYER: "centered-layer",
		GESTURE_LAYER: "gesture-layer",
		CONTROLLER_LAYER: "controller",
		BUTTON: "button",
		RANGE: "range",
		DISPLAY: "display",
		CONTROL_BAR: "control-bar",
		SELECTMENU: "selectmenu",
		LISTBOX: "listbox",
		OPTION: "option",
		POSTER: "poster",
		LIVE: "live",
		PLAY: "play",
		PRE_PLAY: "pre-play",
		SEEK_BACKWARD: "seek-backward",
		SEEK_FORWARD: "seek-forward",
		MUTE: "mute",
		CAPTIONS: "captions",
		AIRPLAY: "airplay",
		PIP: "pip",
		FULLSCREEN: "fullscreen",
		CAST: "cast",
		PLAYBACK_RATE: "playback-rate",
		VOLUME: "volume",
		TIME: "time",
		TITLE: "title",
		AUDIO_TRACK: "audio-track",
		RENDITION: "rendition"
	}).join(", "), Bw = e => {
		var t, i, a, r, n, s, o, l, d, u, h, c, m, f, p, g, v, E, b, y, T, A, _, k, S, w, L, R, I, D, C, x, M, O, P, N;
		return Uw`
  <media-theme
    template="${e.themeTemplate || !1}"
    defaultstreamtype="${null != (t = e.defaultStreamType) && t}"
    hotkeys="${(e => {
			let t = e.hotKeys ? `${e.hotKeys}` : "";
			return "live" === Zk(e.streamType) && (t += " noarrowleft noarrowright"), t
		})(e) || !1}"
    nohotkeys="${e.noHotKeys || !e.hasSrc || e.isDialogOpen || !1}"
    noautoseektolive="${!(null == (i = e.streamType) || !i.includes(LT.LIVE)) && 0 !== e.targetLiveWindow}"
    novolumepref="${e.novolumepref || !1}"
    disabled="${!e.hasSrc || e.isDialogOpen}"
    audio="${null != (a = e.audio) && a}"
    style="${null != (r = function (e) {
			let t = "";
			return Object.entries(e).forEach((([e, i]) => {
				null != i && (t += `${Gk(e)}: ${i}; `)
			})), t ? t.trim() : void 0
		}({
			"--media-primary-color": e.primaryColor,
			"--media-secondary-color": e.secondaryColor,
			"--media-accent-color": e.accentColor
		})) && r}"
    defaultsubtitles="${!e.defaultHiddenCaptions}"
    forwardseekoffset="${null != (n = e.forwardSeekOffset) && n}"
    backwardseekoffset="${null != (s = e.backwardSeekOffset) && s}"
    playbackrates="${null != (o = e.playbackRates) && o}"
    defaultshowremainingtime="${null != (l = e.defaultShowRemainingTime) && l}"
    defaultduration="${null != (d = e.defaultDuration) && d}"
    hideduration="${null != (u = e.hideDuration) && u}"
    title="${null != (h = e.title) && h}"
    exportparts="${Fw}"
  >
    <mux-video
      slot="media"
      target-live-window="${null != (c = e.targetLiveWindow) && c}"
      stream-type="${null != (m = Zk(e.streamType)) && m}"
      crossorigin="${null != (f = e.crossOrigin) ? f : ""}"
      playsinline
      autoplay="${null != (p = e.autoplay) && p}"
      muted="${null != (g = e.muted) && g}"
      loop="${null != (v = e.loop) && v}"
      preload="${null != (E = e.preload) && E}"
      debug="${null != (b = e.debug) && b}"
      prefer-cmcd="${null != (y = e.preferCmcd) && y}"
      disable-tracking="${null != (T = e.disableTracking) && T}"
      disable-cookies="${null != (A = e.disableCookies) && A}"
      prefer-playback="${null != (_ = e.preferPlayback) && _}"
      start-time="${null != e.startTime && e.startTime}"
      beacon-collection-domain="${null != (k = e.beaconCollectionDomain) && k}"
      player-software-name="${null != (S = e.playerSoftwareName) && S}"
      player-software-version="${null != (w = e.playerSoftwareVersion) && w}"
      env-key="${null != (L = e.envKey) && L}"
      custom-domain="${null != (R = e.customDomain) && R}"
      src="${e.src ? e.src : !!e.playbackId && dA(e)}"
      cast-src="${e.src ? e.src : !!e.playbackId && dA(e)}"
      exportparts="video"
    >
      ${e.storyboard ? Uw`<track label="thumbnails" default kind="metadata" src="${e.storyboard}" />` : Uw``}
    </mux-video>
    <slot name="poster" slot="poster">
      <media-poster-image
        part="poster"
        exportparts="poster, img"
        src="${"" !== e.poster && (null != (I = e.poster) && I)}"
        placeholdersrc="${null != (D = e.placeholder) && D}"
      ></media-poster-image>
    </slot>
    <mxp-dialog
      no-auto-hide
      open="${null != (C = e.isDialogOpen) && C}"
      onclose="${e.onCloseErrorDialog}"
      oninitfocus="${e.onInitFocusDialog}"
    >
      ${null != (x = e.dialog) && x.title ? Uw`<h3>${e.dialog.title}</h3>` : Uw``}
      <p>
        ${null == (M = e.dialog) ? void 0 : M.message}
        ${null != (O = e.dialog) && O.linkUrl ? Uw`<a
              href="${e.dialog.linkUrl}"
              target="_blank"
              rel="external noopener"
              aria-label="${null != (P = e.dialog.linkText) ? P : ""} ${Hk("(opens in a new window)")}"
              >${null != (N = e.dialog.linkText) ? N : e.dialog.linkUrl}</a
            >` : Uw``}
      </p>
    </mxp-dialog>
  </media-theme>
`
	};

	function $w(e, t, i, a, r) {
		var n, s, o;
		let l = {}, d = {};
		switch (e.code) {
			case kT.MEDIA_ERR_NETWORK:
				switch (l.title = Hk("Network Error", r), l.message = e.message, null == (n = e.data) ? void 0 : n.response.code) {
					case 412:
						l.title = Hk("Video is not currently available", r), l.message = Hk("The live stream or video file are not yet ready.", r), d.message = Hk("This playback-id may belong to a live stream that is not currently active or an asset that is not ready.", r), d.file = "412-not-playable.md";
						break;
					case 404:
						l.title = Hk("Video does not exist", r), l.message = "", d.message = Hk("This playback-id does not exist. You may have used an Asset ID or an ID from a different resource.", r), d.file = "404-not-found.md";
						break;
					case 403: {
						if (l.title = Hk("Invalid playback URL", r), l.message = Hk("The video URL or playback-token are formatted with incorrect or incomplete information.", r), d.message = Hk("403 error trying to access this playback URL. If this is a signed URL, you might need to provide a playback-token.", r), d.file = "missing-signed-tokens.md", !a) break;
						let {exp: e, aud: t, sub: n} = Yk(a), s = n !== i, o = "v" !== t,
							u = {timeStyle: "medium", dateStyle: "medium"};
						if (Date.now() > 1e3 * e) {
							l.title = Hk("Video URL has expired", r), l.message = Hk("The video’s secured playback-token has expired.", r), d.message = Hk("The video’s secured playback-token has expired.", r), d.context = Hk("Expired at: {expiredDate}. Current time: {currentDate}.", r).format({
								expiredDate: new Intl.DateTimeFormat(Bk.code, u).format(1e3 * e),
								currentDate: new Intl.DateTimeFormat(Bk.code, u).format(Date.now())
							}), d.file = "403-expired-token.md";
							break
						}
						if (s) {
							l.title = Hk("Video URL is formatted incorrectly", r), l.message = Hk("The video’s playback ID does not match the one encoded in the playback-token.", r), d.message = Hk("The video’s playback ID does not match the one encoded in the playback-token.", r), d.context = Hk("Specified playback ID: {playbackId} and the playback ID encoded in the playback-token: {tokenPlaybackId}", r).format({
								playbackId: i,
								tokenPlaybackId: n
							}), d.file = "403-playback-id-mismatch.md";
							break
						}
						if (o) {
							l.title = Hk("Video URL is formatted incorrectly", r), l.message = Hk("The playback-token is formatted with incorrect information.", r), d.message = Hk("The playback-token is formatted with incorrect information.", r), d.context = Hk("The playback-token has an incorrect aud value: {tokenType}. aud value should be v.", r).format({tokenType: t}), d.file = "403-incorrect-aud-value.md";
							break
						}
						d.message = Hk("403 error trying to access this playback URL. If this is a signed playback ID, the token might not have been generated correctly.", r), d.file = "403-malformatted-token.md";
						break
					}
				}
				break;
			case kT.MEDIA_ERR_DECODE: {
				let {message: t} = e;
				l = {title: Hk("Media Error", r), message: t}, d.file = "media-decode-error.md";
				break
			}
			case kT.MEDIA_ERR_SRC_NOT_SUPPORTED: {
				let n = null == (o = null == (s = e.data) ? void 0 : s.response) ? void 0 : o.code;
				if (n >= 400 && n < 500) {
					e.code = kT.MEDIA_ERR_NETWORK, e.data = {response: {code: n}}, ({
						dialog: l,
						devlog: d
					} = $w(e, t, i, a));
					break
				}
				l = {title: Hk("Source Not Supported", r), message: e.message}, d.file = "media-src-not-supported.md";
				break
			}
			default:
				l = {title: Hk("Error", r), message: e.message}
		}
		return t && (l = {
			title: Hk("Your device appears to be offline", r),
			message: Hk("Check your internet connection and try reloading this video.", r)
		}), {dialog: l, devlog: d}
	}

	var Hw = c.createElement("template");
	"innerHTML" in Hw && (Hw.innerHTML = '<template id="media-theme-gerwig">\n  <style>\n    @keyframes pre-play-hide {\n      0% {\n        transform: scale(1);\n        opacity: 1;\n      }\n\n      30% {\n        transform: scale(0.7);\n      }\n\n      100% {\n        transform: scale(1.5);\n        opacity: 0;\n      }\n    }\n\n    :host {\n      --_primary-color: var(--media-primary-color, #fff);\n      --_secondary-color: var(--media-secondary-color, transparent);\n      --_accent-color: var(--media-accent-color, #fa50b5);\n      --_text-color: var(--media-text-color, #000);\n\n      --media-icon-color: var(--_primary-color);\n      --media-control-background: var(--_secondary-color);\n      --media-control-hover-background: var(--_accent-color);\n      --media-time-buffered-color: rgba(255, 255, 255, 0.4);\n      --media-preview-time-text-shadow: none;\n      --media-control-height: 14px;\n      --media-control-padding: 6px;\n\n      color: var(--_primary-color);\n      display: inline-block;\n      width: 100%;\n      height: 100%;\n    }\n\n    :host([audio]) {\n      --_secondary-color: var(--media-secondary-color, black);\n      --media-preview-time-text-shadow: none;\n    }\n\n    :host([audio]) ::slotted([slot=\'media\']) {\n      height: 0px;\n    }\n\n    :host([audio]) media-loading-indicator {\n      display: none;\n    }\n\n    :host([audio]) media-controller {\n      background: transparent;\n    }\n\n    :host([audio]) media-controller::part(vertical-layer) {\n      background: transparent;\n    }\n\n    :host([audio]) media-control-bar {\n      width: 100%;\n      background-color: var(--media-control-background);\n    }\n\n    /*\n     * 0.433s is the transition duration for VTT Regions.\n     * Borrowed here, so the captions don\'t move too fast.\n     */\n    media-controller ::slotted([slot=\'media\']) {\n      --media-webkit-text-track-transform: translateY(0) scale(0.98);\n      --media-webkit-text-track-transition: transform 0.433s ease-out 0.3s;\n    }\n    media-controller:is([mediapaused], :not([userinactive])) ::slotted([slot=\'media\']) {\n      --media-webkit-text-track-transform: translateY(-50px) scale(0.98);\n      --media-webkit-text-track-transition: transform 0.15s ease;\n    }\n\n    media-time-range {\n      --media-box-padding-left: 6px;\n      --media-box-padding-right: 6px;\n      --media-range-bar-color: var(--_accent-color);\n      --media-time-range-buffered-color: var(--_primary-color);\n      --media-range-track-color: transparent;\n      --media-range-track-background: rgba(255, 255, 255, 0.4);\n      --media-range-thumb-background: radial-gradient(\n        circle,\n        #000 0%,\n        #000 25%,\n        var(--_accent-color) 25%,\n        var(--_accent-color)\n      );\n      --media-range-thumb-width: 12px;\n      --media-range-thumb-height: 12px;\n      --media-range-thumb-transform: scale(0);\n      --media-range-thumb-transition: transform 0.3s;\n      --media-range-thumb-opacity: 1;\n      --media-preview-background: var(--_primary-color);\n      --media-box-arrow-background: var(--_primary-color);\n      --media-preview-thumbnail-border: 5px solid var(--_primary-color);\n      --media-preview-border-radius: 5px;\n      --media-text-color: var(--_text-color);\n      --media-control-hover-background: transparent;\n      color: var(--_accent-color);\n      padding: 0 6px;\n    }\n\n    :host([audio]) media-time-range {\n      --media-preview-time-padding: 1.5px 6px;\n      --media-preview-box-margin: 0 0 -5px;\n    }\n\n    media-time-range:hover {\n      --media-range-thumb-transform: scale(1);\n    }\n\n    media-preview-thumbnail {\n      border-bottom-width: 0;\n    }\n\n    [part~=\'listbox\'] {\n      border-radius: 2px;\n      border: 1px solid rgba(0, 0, 0, 0.1);\n      bottom: calc(100% + 16px);\n      padding: 2.5px 10px;\n    }\n\n    [part~=\'listbox\']::part(indicator) {\n      fill: var(--_accent-color);\n    }\n\n    [part~=\'listbox\']::part(option) {\n      box-sizing: border-box;\n      display: flex;\n      align-items: center;\n      padding: 6px 10px;\n      min-height: 34px;\n    }\n\n    [part~=\'listbox\']::part(option-selected) {\n      font-weight: 700;\n    }\n\n    media-captions-selectmenu,\n    media-rendition-selectmenu,\n    media-audio-track-selectmenu,\n    media-playback-rate-listbox[part~=\'listbox\'] {\n      --media-listbox-background: var(--_primary-color);\n      --media-option-selected-background: transparent;\n      --media-option-hover-background: transparent;\n      --media-option-hover-outline: var(--_accent-color) solid 1px;\n      --media-text-color: var(--_text-color);\n    }\n\n    /* The icon is a circle so make it 16px high instead of 14px for more balance. */\n    media-audio-track-selectmenu {\n      --media-control-padding: 5px;\n      --media-control-height: 16px;\n    }\n\n    media-playback-rate-button {\n      --media-control-padding: 6px 3px;\n      min-width: 4.4ch;\n    }\n\n    media-playback-rate-listbox[part~=\'listbox\'] {\n      --media-listbox-layout: row;\n      --media-option-selected-background: var(--_accent-color);\n      margin-right: 6px;\n      padding: 0;\n    }\n\n    media-playback-rate-listbox[part~=\'listbox\']::part(option) {\n      padding: 6px 4px;\n    }\n\n    media-playback-rate-listbox[part~=\'listbox\']::part(option-selected) {\n      color: #fff;\n    }\n\n    :host(:not([audio])) media-time-range {\n      /* Adding px is required here for calc() */\n      --media-range-padding: 0px;\n      background: transparent;\n      z-index: 10;\n      height: 10px;\n      bottom: -3px;\n      width: 100%;\n    }\n\n    media-control-bar :is([role=\'button\'], [role=\'switch\'], button) {\n      line-height: 0;\n    }\n\n    media-control-bar :is([part*=\'button\'], [part*=\'range\'], [part*=\'display\']) {\n      border-radius: 3px;\n    }\n\n    .spacer {\n      flex-grow: 1;\n      background-color: var(--media-control-background, rgba(20, 20, 30, 0.7));\n    }\n\n    media-control-bar[slot~=\'top-chrome\'] {\n      min-height: 42px;\n      pointer-events: none;\n    }\n\n    media-control-bar {\n      --gradient-steps: hsl(0 0% 0% / 0) 0%, hsl(0 0% 0% / 0.013) 8.1%, hsl(0 0% 0% / 0.049) 15.5%,\n        hsl(0 0% 0% / 0.104) 22.5%, hsl(0 0% 0% / 0.175) 29%, hsl(0 0% 0% / 0.259) 35.3%, hsl(0 0% 0% / 0.352) 41.2%,\n        hsl(0 0% 0% / 0.45) 47.1%, hsl(0 0% 0% / 0.55) 52.9%, hsl(0 0% 0% / 0.648) 58.8%, hsl(0 0% 0% / 0.741) 64.7%,\n        hsl(0 0% 0% / 0.825) 71%, hsl(0 0% 0% / 0.896) 77.5%, hsl(0 0% 0% / 0.951) 84.5%, hsl(0 0% 0% / 0.987) 91.9%,\n        hsl(0 0% 0%) 100%;\n    }\n\n    :host([title]:not([audio])) media-control-bar[slot=\'top-chrome\']::before {\n      content: \'\';\n      position: absolute;\n      width: 100%;\n      padding-bottom: min(100px, 25%);\n      background: linear-gradient(to top, var(--gradient-steps));\n      opacity: 0.8;\n      pointer-events: none;\n    }\n\n    :host(:not([audio])) media-control-bar[part~=\'bottom\']::before {\n      content: \'\';\n      position: absolute;\n      width: 100%;\n      bottom: 0;\n      left: 0;\n      padding-bottom: min(100px, 25%);\n      background: linear-gradient(to bottom, var(--gradient-steps));\n      opacity: 0.8;\n      z-index: 1;\n      pointer-events: none;\n    }\n\n    media-control-bar[part~=\'bottom\'] > * {\n      z-index: 2;\n    }\n\n    media-control-bar[part~=\'bottom\'] {\n      padding: 6px 6px;\n    }\n\n    media-control-bar[slot~=\'top-chrome\'] > * {\n      --media-control-background: transparent;\n      --media-control-hover-background: transparent;\n      position: relative;\n    }\n\n    media-controller::part(vertical-layer) {\n      transition: background-color 1s;\n    }\n\n    media-controller:is([mediapaused], :not([userinactive]))::part(vertical-layer) {\n      background-color: var(--controls-backdrop-color, var(--controls, transparent));\n      transition: background-color 0.25s;\n    }\n\n    .center-controls {\n      --media-button-icon-width: 100%;\n      --media-button-icon-height: auto;\n      pointer-events: none;\n      width: 100%;\n      display: flex;\n      flex-flow: row;\n      align-items: center;\n      justify-content: center;\n      filter: drop-shadow(0 0 2px rgb(0 0 0 / 0.25)) drop-shadow(0 0 6px rgb(0 0 0 / 0.25));\n      paint-order: stroke;\n      stroke: rgba(102, 102, 102, 1);\n      stroke-width: 0.3px;\n      text-shadow: 0 0 2px rgb(0 0 0 / 0.25), 0 0 6px rgb(0 0 0 / 0.25);\n    }\n\n    .center-controls media-play-button {\n      --media-control-background: transparent;\n      --media-control-hover-background: transparent;\n      --media-control-padding: 0;\n      width: 40px;\n    }\n\n    [breakpointsm] .center-controls media-play-button {\n      width: 90px;\n      height: 90px;\n      border-radius: 50%;\n      transition: background 0.4s;\n      padding: 24px;\n      --media-control-background: #000;\n      --media-control-hover-background: var(--_accent-color);\n    }\n\n    .center-controls media-seek-backward-button,\n    .center-controls media-seek-forward-button {\n      --media-control-background: transparent;\n      --media-control-hover-background: transparent;\n      padding: 0;\n      margin: 0 20px;\n      width: max(33px, min(8%, 40px));\n    }\n\n    [breakpointsm]:not([audio]) .center-controls.pre-playback {\n      display: grid;\n      align-items: initial;\n      justify-content: initial;\n      height: 100%;\n      overflow: hidden;\n    }\n\n    [breakpointsm]:not([audio]) .center-controls.pre-playback media-play-button {\n      place-self: var(--_pre-playback-place, center);\n      grid-area: 1 / 1;\n      margin: 16px;\n    }\n\n    /* Show and hide controls or pre-playback state */\n\n    [breakpointsm]:is([mediahasplayed], :not([mediapaused])):not([audio])\n      .center-controls.pre-playback\n      media-play-button {\n      animation: 0.3s linear forwards pre-play-hide;\n    }\n\n    .autoplay-unmute {\n      --media-control-hover-background: transparent;\n      width: 100%;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      filter: drop-shadow(0 0 2px rgb(0 0 0 / 0.25)) drop-shadow(0 0 6px rgb(0 0 0 / 0.25));\n    }\n\n    .autoplay-unmute-btn {\n      --media-control-height: 16px;\n      border-radius: 8px;\n      background: #000;\n      color: var(--_primary-color);\n      display: flex;\n      align-items: center;\n      padding: 8px 16px;\n      font-size: 18px;\n      font-weight: 500;\n      cursor: pointer;\n    }\n\n    .autoplay-unmute-btn:hover {\n      background: var(--_accent-color);\n    }\n\n    [breakpointsm] .autoplay-unmute-btn {\n      --media-control-height: 30px;\n      padding: 14px 24px;\n      font-size: 26px;\n    }\n\n    .autoplay-unmute-btn svg {\n      margin: 0 6px 0 0;\n    }\n\n    [breakpointsm] .autoplay-unmute-btn svg {\n      margin: 0 10px 0 0;\n    }\n\n    media-controller:not([audio]):not([mediahasplayed]) *:is(media-control-bar, media-time-range) {\n      display: none;\n    }\n\n    media-loading-indicator {\n      --media-loading-icon-width: 100%;\n      --media-button-icon-height: auto;\n      display: var(--media-control-display, var(--media-loading-indicator-display, flex));\n      pointer-events: none;\n      position: absolute;\n      width: min(15%, 150px);\n      flex-flow: row;\n      align-items: center;\n      justify-content: center;\n    }\n\n    /* Intentionally don\'t target the div for transition but the children\n     of the div. Prevents messing with media-chrome\'s autohide feature. */\n    media-loading-indicator + div * {\n      transition: opacity 0.15s;\n      opacity: 1;\n    }\n\n    media-loading-indicator[medialoading]:not([mediapaused]) ~ div > * {\n      opacity: 0;\n      transition-delay: 400ms;\n    }\n\n    media-volume-range {\n      width: min(100%, 100px);\n      --media-range-padding-left: 10px;\n      --media-range-padding-right: 10px;\n      --media-range-thumb-width: 12px;\n      --media-range-thumb-height: 12px;\n      --media-range-thumb-background: radial-gradient(\n        circle,\n        #000 0%,\n        #000 25%,\n        var(--_primary-color) 25%,\n        var(--_primary-color)\n      );\n      --media-control-hover-background: none;\n    }\n\n    media-time-display {\n      white-space: nowrap;\n    }\n\n    /* Generic style for explicitly disabled controls */\n    media-control-bar[part~=\'bottom\'] [disabled],\n    media-control-bar[part~=\'bottom\'] [aria-disabled=\'true\'] {\n      opacity: 60%;\n      cursor: not-allowed;\n    }\n\n    media-text-display {\n      --media-font-size: 16px;\n      --media-control-padding: 14px;\n      font-weight: 500;\n    }\n\n    media-play-button.animated *:is(g, path) {\n      transition: all 0.3s;\n    }\n\n    media-play-button.animated[mediapaused] .pause-icon-pt1 {\n      opacity: 0;\n    }\n\n    media-play-button.animated[mediapaused] .pause-icon-pt2 {\n      transform-origin: center center;\n      transform: scaleY(0);\n    }\n\n    media-play-button.animated[mediapaused] .play-icon {\n      clip-path: inset(0 0 0 0);\n    }\n\n    media-play-button.animated:not([mediapaused]) .play-icon {\n      clip-path: inset(0 0 0 100%);\n    }\n\n    media-seek-forward-button,\n    media-seek-backward-button {\n      --media-font-weight: 400;\n    }\n\n    .mute-icon {\n      display: inline-block;\n    }\n\n    .mute-icon :is(path, g) {\n      transition: opacity 0.5s;\n    }\n\n    .muted {\n      opacity: 0;\n    }\n\n    media-mute-button[mediavolumelevel=\'low\'] :is(.volume-medium, .volume-high),\n    media-mute-button[mediavolumelevel=\'medium\'] :is(.volume-high) {\n      opacity: 0;\n    }\n\n    media-mute-button[mediavolumelevel=\'off\'] .unmuted {\n      opacity: 0;\n    }\n\n    media-mute-button[mediavolumelevel=\'off\'] .muted {\n      opacity: 1;\n    }\n\n    /**\n     * Our defaults for these buttons are to hide them at small sizes\n     * users can override this with CSS\n     */\n    media-controller:not([breakpointsm]):not([audio]) {\n      --bottom-play-button: none;\n      --bottom-seek-backward-button: none;\n      --bottom-seek-forward-button: none;\n      --bottom-time-display: none;\n      --bottom-playback-rate-selectmenu: none;\n      --bottom-pip-button: none;\n    }\n  </style>\n\n  <template partial="TitleDisplay">\n    <template if="title">\n      <media-text-display part="top title display" class="title-display">{{title}}</media-text-display>\n    </template>\n  </template>\n\n  <template partial="PlayButton">\n    <media-play-button\n      part="{{section ?? \'bottom\'}} play button"\n      disabled="{{disabled}}"\n      aria-disabled="{{disabled}}"\n      class="animated"\n    >\n      <svg aria-hidden="true" viewBox="0 0 18 14" slot="icon">\n        <g class="play-icon">\n          <path\n            d="M15.5987 6.2911L3.45577 0.110898C2.83667 -0.204202 2.06287 0.189698 2.06287 0.819798V13.1802C2.06287 13.8103 2.83667 14.2042 3.45577 13.8891L15.5987 7.7089C16.2178 7.3938 16.2178 6.6061 15.5987 6.2911Z"\n          />\n        </g>\n        <g class="pause-icon">\n          <path\n            class="pause-icon-pt1"\n            d="M5.90709 0H2.96889C2.46857 0 2.06299 0.405585 2.06299 0.9059V13.0941C2.06299 13.5944 2.46857 14 2.96889 14H5.90709C6.4074 14 6.81299 13.5944 6.81299 13.0941V0.9059C6.81299 0.405585 6.4074 0 5.90709 0Z"\n          />\n          <path\n            class="pause-icon-pt2"\n            d="M15.1571 0H12.2189C11.7186 0 11.313 0.405585 11.313 0.9059V13.0941C11.313 13.5944 11.7186 14 12.2189 14H15.1571C15.6574 14 16.063 13.5944 16.063 13.0941V0.9059C16.063 0.405585 15.6574 0 15.1571 0Z"\n          />\n        </g>\n      </svg>\n    </media-play-button>\n  </template>\n\n  <template partial="PrePlayButton">\n    <media-play-button\n      part="{{section ?? \'center\'}} play button pre-play"\n      disabled="{{disabled}}"\n      aria-disabled="{{disabled}}"\n    >\n      <svg aria-hidden="true" viewBox="0 0 18 14" slot="icon" style="transform: translate(3px, 0)">\n        <path\n          d="M15.5987 6.2911L3.45577 0.110898C2.83667 -0.204202 2.06287 0.189698 2.06287 0.819798V13.1802C2.06287 13.8103 2.83667 14.2042 3.45577 13.8891L15.5987 7.7089C16.2178 7.3938 16.2178 6.6061 15.5987 6.2911Z"\n        />\n      </svg>\n    </media-play-button>\n  </template>\n\n  <template partial="SeekBackwardButton">\n    <media-seek-backward-button\n      seekoffset="{{backwardseekoffset}}"\n      part="{{section ?? \'bottom\'}} seek-backward button"\n      disabled="{{disabled}}"\n      aria-disabled="{{disabled}}"\n    >\n      <svg viewBox="0 0 22 14" aria-hidden="true" slot="icon">\n        <path\n          d="M3.65 2.07888L0.0864 6.7279C-0.0288 6.87812 -0.0288 7.12188 0.0864 7.2721L3.65 11.9211C3.7792 12.0896 4 11.9703 4 11.7321V2.26787C4 2.02968 3.7792 1.9104 3.65 2.07888Z"\n        />\n        <text transform="translate(6 12)" style="font-size: 14px; font-family: \'ArialMT\', \'Arial\'">\n          {{backwardseekoffset}}\n        </text>\n      </svg>\n    </media-seek-backward-button>\n  </template>\n\n  <template partial="SeekForwardButton">\n    <media-seek-forward-button\n      seekoffset="{{forwardseekoffset}}"\n      part="{{section ?? \'bottom\'}} seek-forward button"\n      disabled="{{disabled}}"\n      aria-disabled="{{disabled}}"\n    >\n      <svg viewBox="0 0 22 14" aria-hidden="true" slot="icon">\n        <g>\n          <text transform="translate(-1 12)" style="font-size: 14px; font-family: \'ArialMT\', \'Arial\'">\n            {{forwardseekoffset}}\n          </text>\n          <path\n            d="M18.35 11.9211L21.9136 7.2721C22.0288 7.12188 22.0288 6.87812 21.9136 6.7279L18.35 2.07888C18.2208 1.91041 18 2.02968 18 2.26787V11.7321C18 11.9703 18.2208 12.0896 18.35 11.9211Z"\n          />\n        </g>\n      </svg>\n    </media-seek-forward-button>\n  </template>\n\n  <template partial="MuteButton">\n    <media-mute-button part="bottom mute button" disabled="{{disabled}}" aria-disabled="{{disabled}}">\n      <svg viewBox="0 0 18 14" slot="icon" class="mute-icon" aria-hidden="true">\n        <g class="unmuted">\n          <path\n            d="M6.76786 1.21233L3.98606 3.98924H1.19937C0.593146 3.98924 0.101743 4.51375 0.101743 5.1607V6.96412L0 6.99998L0.101743 7.03583V8.83926C0.101743 9.48633 0.593146 10.0108 1.19937 10.0108H3.98606L6.76773 12.7877C7.23561 13.2547 8 12.9007 8 12.2171V1.78301C8 1.09925 7.23574 0.745258 6.76786 1.21233Z"\n          />\n          <path\n            class="volume-low"\n            d="M10 3.54781C10.7452 4.55141 11.1393 5.74511 11.1393 6.99991C11.1393 8.25471 10.7453 9.44791 10 10.4515L10.7988 11.0496C11.6734 9.87201 12.1356 8.47161 12.1356 6.99991C12.1356 5.52821 11.6735 4.12731 10.7988 2.94971L10 3.54781Z"\n          />\n          <path\n            class="volume-medium"\n            d="M12.3778 2.40086C13.2709 3.76756 13.7428 5.35806 13.7428 7.00026C13.7428 8.64246 13.2709 10.233 12.3778 11.5992L13.2106 12.1484C14.2107 10.6185 14.739 8.83796 14.739 7.00016C14.739 5.16236 14.2107 3.38236 13.2106 1.85156L12.3778 2.40086Z"\n          />\n          <path\n            class="volume-high"\n            d="M15.5981 0.75L14.7478 1.2719C15.7937 2.9919 16.3468 4.9723 16.3468 7C16.3468 9.0277 15.7937 11.0082 14.7478 12.7281L15.5981 13.25C16.7398 11.3722 17.343 9.211 17.343 7C17.343 4.789 16.7398 2.6268 15.5981 0.75Z"\n          />\n        </g>\n        <g class="muted">\n          <path\n            fill-rule="evenodd"\n            clip-rule="evenodd"\n            d="M4.39976 4.98924H1.19937C1.19429 4.98924 1.17777 4.98961 1.15296 5.01609C1.1271 5.04369 1.10174 5.09245 1.10174 5.1607V8.83926C1.10174 8.90761 1.12714 8.95641 1.15299 8.984C1.17779 9.01047 1.1943 9.01084 1.19937 9.01084H4.39977L7 11.6066V2.39357L4.39976 4.98924ZM7.47434 1.92006C7.4743 1.9201 7.47439 1.92002 7.47434 1.92006V1.92006ZM6.76773 12.7877L3.98606 10.0108H1.19937C0.593146 10.0108 0.101743 9.48633 0.101743 8.83926V7.03583L0 6.99998L0.101743 6.96412V5.1607C0.101743 4.51375 0.593146 3.98924 1.19937 3.98924H3.98606L6.76786 1.21233C7.23574 0.745258 8 1.09925 8 1.78301V12.2171C8 12.9007 7.23561 13.2547 6.76773 12.7877Z"\n          />\n          <path\n            fill-rule="evenodd"\n            clip-rule="evenodd"\n            d="M15.2677 9.30323C15.463 9.49849 15.7796 9.49849 15.9749 9.30323C16.1701 9.10796 16.1701 8.79138 15.9749 8.59612L14.2071 6.82841L15.9749 5.06066C16.1702 4.8654 16.1702 4.54882 15.9749 4.35355C15.7796 4.15829 15.4631 4.15829 15.2678 4.35355L13.5 6.1213L11.7322 4.35348C11.537 4.15822 11.2204 4.15822 11.0251 4.35348C10.8298 4.54874 10.8298 4.86532 11.0251 5.06058L12.7929 6.82841L11.0251 8.59619C10.8299 8.79146 10.8299 9.10804 11.0251 9.3033C11.2204 9.49856 11.537 9.49856 11.7323 9.3033L13.5 7.53552L15.2677 9.30323Z"\n          />\n        </g>\n      </svg>\n    </media-mute-button>\n  </template>\n\n  <template partial="PipButton">\n    <media-pip-button part="bottom pip button" disabled="{{disabled}}" aria-disabled="{{disabled}}">\n      <svg viewBox="0 0 18 14" aria-hidden="true" slot="icon">\n        <path\n          d="M15.9891 0H2.011C0.9004 0 0 0.9003 0 2.0109V11.989C0 13.0996 0.9004 14 2.011 14H15.9891C17.0997 14 18 13.0997 18 11.9891V2.0109C18 0.9003 17.0997 0 15.9891 0ZM17 11.9891C17 12.5465 16.5465 13 15.9891 13H2.011C1.4536 13 1.0001 12.5465 1.0001 11.9891V2.0109C1.0001 1.4535 1.4536 0.9999 2.011 0.9999H15.9891C16.5465 0.9999 17 1.4535 17 2.0109V11.9891Z"\n        />\n        <path\n          d="M15.356 5.67822H8.19523C8.03253 5.67822 7.90063 5.81012 7.90063 5.97282V11.3836C7.90063 11.5463 8.03253 11.6782 8.19523 11.6782H15.356C15.5187 11.6782 15.6506 11.5463 15.6506 11.3836V5.97282C15.6506 5.81012 15.5187 5.67822 15.356 5.67822Z"\n        />\n      </svg>\n    </media-pip-button>\n  </template>\n\n  <template partial="CaptionsMenuButton">\n    <media-captions-selectmenu part="bottom captions selectmenu" disabled="{{disabled}}" aria-disabled="{{disabled}}">\n      <media-captions-button\n        slot="button"\n        part="bottom captions button"\n        disabled="{{disabled}}"\n        aria-disabled="{{disabled}}"\n      >\n        <svg aria-hidden="true" viewBox="0 0 18 14" slot="on">\n          <path\n            d="M15.989 0H2.011C0.9004 0 0 0.9003 0 2.0109V11.9891C0 13.0997 0.9004 14 2.011 14H15.989C17.0997 14 18 13.0997 18 11.9891V2.0109C18 0.9003 17.0997 0 15.989 0ZM4.2292 8.7639C4.5954 9.1902 5.0935 9.4031 5.7233 9.4031C6.1852 9.4031 6.5544 9.301 6.8302 9.0969C7.1061 8.8933 7.2863 8.614 7.3702 8.26H8.4322C8.3062 8.884 8.0093 9.3733 7.5411 9.7273C7.0733 10.0813 6.4703 10.2581 5.732 10.2581C5.108 10.2581 4.5699 10.1219 4.1168 9.8489C3.6637 9.5759 3.3141 9.1946 3.0685 8.7058C2.8224 8.2165 2.6994 7.6511 2.6994 7.009C2.6994 6.3611 2.8224 5.7927 3.0685 5.3034C3.3141 4.8146 3.6637 4.4323 4.1168 4.1559C4.5699 3.88 5.108 3.7418 5.732 3.7418C6.4703 3.7418 7.0733 3.922 7.5411 4.2818C8.0094 4.6422 8.3062 5.1461 8.4322 5.794H7.3702C7.2862 5.4283 7.106 5.1368 6.8302 4.921C6.5544 4.7052 6.1852 4.5968 5.7233 4.5968C5.0934 4.5968 4.5954 4.8116 4.2292 5.2404C3.8635 5.6696 3.6804 6.259 3.6804 7.009C3.6804 7.7531 3.8635 8.3381 4.2292 8.7639ZM11.0974 8.7639C11.4636 9.1902 11.9617 9.4031 12.5915 9.4031C13.0534 9.4031 13.4226 9.301 13.6984 9.0969C13.9743 8.8933 14.1545 8.614 14.2384 8.26H15.3004C15.1744 8.884 14.8775 9.3733 14.4093 9.7273C13.9415 10.0813 13.3385 10.2581 12.6002 10.2581C11.9762 10.2581 11.4381 10.1219 10.985 9.8489C10.5319 9.5759 10.1823 9.1946 9.9367 8.7058C9.6906 8.2165 9.5676 7.6511 9.5676 7.009C9.5676 6.3611 9.6906 5.7927 9.9367 5.3034C10.1823 4.8146 10.5319 4.4323 10.985 4.1559C11.4381 3.88 11.9762 3.7418 12.6002 3.7418C13.3385 3.7418 13.9415 3.922 14.4093 4.2818C14.8776 4.6422 15.1744 5.1461 15.3004 5.794H14.2384C14.1544 5.4283 13.9742 5.1368 13.6984 4.921C13.4226 4.7052 13.0534 4.5968 12.5915 4.5968C11.9616 4.5968 11.4636 4.8116 11.0974 5.2404C10.7317 5.6696 10.5486 6.259 10.5486 7.009C10.5486 7.7531 10.7317 8.3381 11.0974 8.7639Z"\n          />\n        </svg>\n        <svg aria-hidden="true" viewBox="0 0 18 14" slot="off">\n          <path\n            d="M5.73219 10.258C5.10819 10.258 4.57009 10.1218 4.11699 9.8488C3.66389 9.5758 3.31429 9.1945 3.06869 8.7057C2.82259 8.2164 2.69958 7.651 2.69958 7.0089C2.69958 6.361 2.82259 5.7926 3.06869 5.3033C3.31429 4.8145 3.66389 4.4322 4.11699 4.1558C4.57009 3.8799 5.10819 3.7417 5.73219 3.7417C6.47049 3.7417 7.07348 3.9219 7.54128 4.2817C8.00958 4.6421 8.30638 5.146 8.43238 5.7939H7.37039C7.28639 5.4282 7.10618 5.1367 6.83039 4.9209C6.55459 4.7051 6.18538 4.5967 5.72348 4.5967C5.09358 4.5967 4.59559 4.8115 4.22939 5.2403C3.86369 5.6695 3.68058 6.2589 3.68058 7.0089C3.68058 7.753 3.86369 8.338 4.22939 8.7638C4.59559 9.1901 5.09368 9.403 5.72348 9.403C6.18538 9.403 6.55459 9.3009 6.83039 9.0968C7.10629 8.8932 7.28649 8.6139 7.37039 8.2599H8.43238C8.30638 8.8839 8.00948 9.3732 7.54128 9.7272C7.07348 10.0812 6.47049 10.258 5.73219 10.258Z"\n          />\n          <path\n            d="M12.6003 10.258C11.9763 10.258 11.4382 10.1218 10.9851 9.8488C10.532 9.5758 10.1824 9.1945 9.93685 8.7057C9.69075 8.2164 9.56775 7.651 9.56775 7.0089C9.56775 6.361 9.69075 5.7926 9.93685 5.3033C10.1824 4.8145 10.532 4.4322 10.9851 4.1558C11.4382 3.8799 11.9763 3.7417 12.6003 3.7417C13.3386 3.7417 13.9416 3.9219 14.4094 4.2817C14.8777 4.6421 15.1745 5.146 15.3005 5.7939H14.2385C14.1545 5.4282 13.9743 5.1367 13.6985 4.9209C13.4227 4.7051 13.0535 4.5967 12.5916 4.5967C11.9617 4.5967 11.4637 4.8115 11.0975 5.2403C10.7318 5.6695 10.5487 6.2589 10.5487 7.0089C10.5487 7.753 10.7318 8.338 11.0975 8.7638C11.4637 9.1901 11.9618 9.403 12.5916 9.403C13.0535 9.403 13.4227 9.3009 13.6985 9.0968C13.9744 8.8932 14.1546 8.6139 14.2385 8.2599H15.3005C15.1745 8.8839 14.8776 9.3732 14.4094 9.7272C13.9416 10.0812 13.3386 10.258 12.6003 10.258Z"\n          />\n          <path\n            d="M15.9891 1C16.5465 1 17 1.4535 17 2.011V11.9891C17 12.5465 16.5465 13 15.9891 13H2.0109C1.4535 13 1 12.5465 1 11.9891V2.0109C1 1.4535 1.4535 0.9999 2.0109 0.9999L15.9891 1ZM15.9891 0H2.0109C0.9003 0 0 0.9003 0 2.0109V11.9891C0 13.0997 0.9003 14 2.0109 14H15.9891C17.0997 14 18 13.0997 18 11.9891V2.0109C18 0.9003 17.0997 0 15.9891 0Z"\n          />\n        </svg>\n      </media-captions-button>\n      <media-captions-listbox slot="listbox" exportparts="option" part="bottom captions listbox">\n        <div slot="select-indicator">\n          <style>\n            .listbox-indicator {\n              position: relative;\n              top: 1px;\n              width: 0.9em;\n              height: auto;\n              fill: var(--_accent-color);\n            }\n\n            [aria-selected=\'false\'] .listbox-indicator {\n              display: none;\n            }\n          </style>\n          <svg viewBox="0 0 14 18" class="listbox-indicator">\n            <path\n              d="M12.252 3.48c-.115.033-.301.161-.425.291-.059.063-1.407 1.815-2.995 3.894s-2.897 3.79-2.908 3.802c-.013.014-.661-.616-1.672-1.624-.908-.905-1.702-1.681-1.765-1.723-.401-.27-.783-.211-1.176.183a1.285 1.285 0 0 0-.261.342.582.582 0 0 0-.082.35c0 .165.01.205.08.35.075.153.213.296 2.182 2.271 1.156 1.159 2.17 2.159 2.253 2.222.189.143.338.196.539.194.203-.003.412-.104.618-.299.205-.193 6.7-8.693 6.804-8.903a.716.716 0 0 0 .085-.345c.01-.179.005-.203-.062-.339-.124-.252-.45-.531-.746-.639a.784.784 0 0 0-.469-.027"\n              fill-rule="evenodd"\n            />\n          </svg>\n        </div>\n      </media-captions-listbox>\n    </media-captions-selectmenu>\n  </template>\n\n  <template partial="AirplayButton">\n    <media-airplay-button part="bottom airplay button" disabled="{{disabled}}" aria-disabled="{{disabled}}">\n      <svg viewBox="0 0 18 14" aria-hidden="true" slot="icon">\n        <path\n          d="M16.1383 0H1.8618C0.8335 0 0 0.8335 0 1.8617V10.1382C0 11.1664 0.8335 12 1.8618 12H3.076C3.1204 11.9433 3.1503 11.8785 3.2012 11.826L4.004 11H1.8618C1.3866 11 1 10.6134 1 10.1382V1.8617C1 1.3865 1.3866 0.9999 1.8618 0.9999H16.1383C16.6135 0.9999 17.0001 1.3865 17.0001 1.8617V10.1382C17.0001 10.6134 16.6135 11 16.1383 11H13.9961L14.7989 11.826C14.8499 11.8785 14.8798 11.9432 14.9241 12H16.1383C17.1665 12 18.0001 11.1664 18.0001 10.1382V1.8617C18 0.8335 17.1665 0 16.1383 0Z"\n        />\n        <path\n          d="M9.55061 8.21903C9.39981 8.06383 9.20001 7.98633 9.00011 7.98633C8.80021 7.98633 8.60031 8.06383 8.44951 8.21903L4.09771 12.697C3.62471 13.1838 3.96961 13.9998 4.64831 13.9998H13.3518C14.0304 13.9998 14.3754 13.1838 13.9023 12.697L9.55061 8.21903Z"\n        />\n      </svg>\n    </media-airplay-button>\n  </template>\n\n  <template partial="FullscreenButton">\n    <media-fullscreen-button part="bottom fullscreen button" disabled="{{disabled}}" aria-disabled="{{disabled}}">\n      <svg viewBox="0 0 18 14" aria-hidden="true" slot="enter">\n        <path\n          d="M1.00745 4.39539L1.01445 1.98789C1.01605 1.43049 1.47085 0.978289 2.02835 0.979989L6.39375 0.992589L6.39665 -0.007411L2.03125 -0.020011C0.920646 -0.023211 0.0176463 0.874489 0.0144463 1.98509L0.00744629 4.39539H1.00745Z"\n        />\n        <path\n          d="M17.0144 2.03431L17.0076 4.39541H18.0076L18.0144 2.03721C18.0176 0.926712 17.1199 0.0237125 16.0093 0.0205125L11.6439 0.0078125L11.641 1.00781L16.0064 1.02041C16.5638 1.02201 17.016 1.47681 17.0144 2.03431Z"\n        />\n        <path\n          d="M16.9925 9.60498L16.9855 12.0124C16.9839 12.5698 16.5291 13.022 15.9717 13.0204L11.6063 13.0078L11.6034 14.0078L15.9688 14.0204C17.0794 14.0236 17.9823 13.1259 17.9855 12.0153L17.9925 9.60498H16.9925Z"\n        />\n        <path\n          d="M0.985626 11.9661L0.992426 9.60498H-0.0074737L-0.0142737 11.9632C-0.0174737 13.0738 0.880226 13.9767 1.99083 13.98L6.35623 13.9926L6.35913 12.9926L1.99373 12.98C1.43633 12.9784 0.983926 12.5236 0.985626 11.9661Z"\n        />\n      </svg>\n      <svg viewBox="0 0 18 14" aria-hidden="true" slot="exit">\n        <path\n          d="M5.39655 -0.0200195L5.38955 2.38748C5.38795 2.94488 4.93315 3.39708 4.37565 3.39538L0.0103463 3.38278L0.00744629 4.38278L4.37285 4.39538C5.48345 4.39858 6.38635 3.50088 6.38965 2.39028L6.39665 -0.0200195H5.39655Z"\n        />\n        <path\n          d="M12.6411 2.36891L12.6479 0.0078125H11.6479L11.6411 2.36601C11.6379 3.47651 12.5356 4.37951 13.6462 4.38271L18.0116 4.39531L18.0145 3.39531L13.6491 3.38271C13.0917 3.38111 12.6395 2.92641 12.6411 2.36891Z"\n        />\n        <path\n          d="M12.6034 14.0204L12.6104 11.613C12.612 11.0556 13.0668 10.6034 13.6242 10.605L17.9896 10.6176L17.9925 9.61759L13.6271 9.60499C12.5165 9.60179 11.6136 10.4995 11.6104 11.6101L11.6034 14.0204H12.6034Z"\n        />\n        <path\n          d="M5.359 11.6315L5.3522 13.9926H6.3522L6.359 11.6344C6.3622 10.5238 5.4645 9.62088 4.3539 9.61758L-0.0115043 9.60498L-0.0144043 10.605L4.351 10.6176C4.9084 10.6192 5.3607 11.074 5.359 11.6315Z"\n        />\n      </svg>\n    </media-fullscreen-button>\n  </template>\n\n  <template partial="CastButton">\n    <media-cast-button part="bottom cast button" disabled="{{disabled}}" aria-disabled="{{disabled}}">\n      <svg viewBox="0 0 18 14" aria-hidden="true" slot="enter">\n        <path\n          d="M16.0072 0H2.0291C0.9185 0 0.0181 0.9003 0.0181 2.011V5.5009C0.357 5.5016 0.6895 5.5275 1.0181 5.5669V2.011C1.0181 1.4536 1.4716 1 2.029 1H16.0072C16.5646 1 17.0181 1.4536 17.0181 2.011V11.9891C17.0181 12.5465 16.5646 13 16.0072 13H8.4358C8.4746 13.3286 8.4999 13.6611 8.4999 13.9999H16.0071C17.1177 13.9999 18.018 13.0996 18.018 11.989V2.011C18.0181 0.9003 17.1178 0 16.0072 0ZM0 6.4999V7.4999C3.584 7.4999 6.5 10.4159 6.5 13.9999H7.5C7.5 9.8642 4.1357 6.4999 0 6.4999ZM0 8.7499V9.7499C2.3433 9.7499 4.25 11.6566 4.25 13.9999H5.25C5.25 11.1049 2.895 8.7499 0 8.7499ZM0.0181 11V14H3.0181C3.0181 12.3431 1.675 11 0.0181 11Z"\n        />\n      </svg>\n      <svg viewBox="0 0 18 14" aria-hidden="true" slot="exit">\n        <path\n          d="M15.9891 0H2.01103C0.900434 0 3.35947e-05 0.9003 3.35947e-05 2.011V5.5009C0.338934 5.5016 0.671434 5.5275 1.00003 5.5669V2.011C1.00003 1.4536 1.45353 1 2.01093 1H15.9891C16.5465 1 17 1.4536 17 2.011V11.9891C17 12.5465 16.5465 13 15.9891 13H8.41773C8.45653 13.3286 8.48183 13.6611 8.48183 13.9999H15.989C17.0996 13.9999 17.9999 13.0996 17.9999 11.989V2.011C18 0.9003 17.0997 0 15.9891 0ZM-0.0180664 6.4999V7.4999C3.56593 7.4999 6.48193 10.4159 6.48193 13.9999H7.48193C7.48193 9.8642 4.11763 6.4999 -0.0180664 6.4999ZM-0.0180664 8.7499V9.7499C2.32523 9.7499 4.23193 11.6566 4.23193 13.9999H5.23193C5.23193 11.1049 2.87693 8.7499 -0.0180664 8.7499ZM3.35947e-05 11V14H3.00003C3.00003 12.3431 1.65693 11 3.35947e-05 11Z"\n        />\n        <path d="M2.15002 5.634C5.18352 6.4207 7.57252 8.8151 8.35282 11.8499H15.8501V2.1499H2.15002V5.634Z" />\n      </svg>\n    </media-cast-button>\n  </template>\n\n  <template partial="LiveButton">\n    <media-live-button part="{{section ?? \'top\'}} live button" disabled="{{disabled}}" aria-disabled="{{disabled}}">\n      <span slot="text">Live</span>\n    </media-live-button>\n  </template>\n\n  <template partial="PlaybackRateSelect">\n    <media-playback-rate-selectmenu\n      part="bottom playback-rate selectmenu"\n      disabled="{{disabled}}"\n      aria-disabled="{{disabled}}"\n    >\n      <media-playback-rate-button slot="button" part="bottom playback-rate button"></media-playback-rate-button>\n      <media-playback-rate-listbox\n        slot="listbox"\n        rates="{{playbackrates}}"\n        exportparts="option"\n        part="bottom playback-rate listbox"\n      ></media-playback-rate-listbox>\n    </media-playback-rate-selectmenu>\n  </template>\n\n  <template partial="VolumeRange">\n    <media-volume-range\n      part="bottom volume range"\n      disabled="{{disabled}}"\n      aria-disabled="{{disabled}}"\n    ></media-volume-range>\n  </template>\n\n  <template partial="TimeDisplay">\n    <media-time-display\n      remaining="{{defaultshowremainingtime}}"\n      showduration="{{!hideduration}}"\n      part="bottom time display"\n      disabled="{{disabled}}"\n      aria-disabled="{{disabled}}"\n    ></media-time-display>\n  </template>\n\n  <template partial="TimeRange">\n    <media-time-range part="bottom time range" disabled="{{disabled}}" aria-disabled="{{disabled}}">\n      <media-preview-thumbnail slot="preview"></media-preview-thumbnail>\n      <media-preview-chapter-display slot="preview"></media-preview-chapter-display>\n      <media-preview-time-display slot="preview"></media-preview-time-display>\n      <div slot="preview" part="arrow"></div>\n    </media-time-range>\n  </template>\n\n  <template partial="AudioTrackSelect">\n    <media-audio-track-selectmenu\n      part="bottom audio-track selectmenu"\n      disabled="{{disabled}}"\n      aria-disabled="{{disabled}}"\n    >\n      <media-audio-track-button slot="button" part="bottom audio-track button">\n        <svg aria-hidden="true" slot="icon" viewBox="0 0 18 16">\n          <path d="M9 15A7 7 0 1 1 9 1a7 7 0 0 1 0 14Zm0 1A8 8 0 1 0 9 0a8 8 0 0 0 0 16Z" />\n          <path\n            d="M5.2 6.3a.5.5 0 0 1 .5.5v2.4a.5.5 0 1 1-1 0V6.8a.5.5 0 0 1 .5-.5Zm2.4-2.4a.5.5 0 0 1 .5.5v7.2a.5.5 0 0 1-1 0V4.4a.5.5 0 0 1 .5-.5ZM10 5.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5Zm2.4-.8a.5.5 0 0 1 .5.5v5.6a.5.5 0 0 1-1 0V5.2a.5.5 0 0 1 .5-.5Z"\n          />\n        </svg>\n      </media-audio-track-button>\n      <media-audio-track-listbox slot="listbox" exportparts="option" part="bottom audio-track listbox">\n        <div slot="select-indicator">\n          <style>\n            .listbox-indicator {\n              position: relative;\n              top: 1px;\n              width: 0.9em;\n              height: auto;\n              fill: var(--_accent-color);\n            }\n\n            [aria-selected=\'false\'] .listbox-indicator {\n              display: none;\n            }\n          </style>\n          <svg viewBox="0 0 14 18" class="listbox-indicator">\n            <path\n              d="M12.252 3.48c-.115.033-.301.161-.425.291-.059.063-1.407 1.815-2.995 3.894s-2.897 3.79-2.908 3.802c-.013.014-.661-.616-1.672-1.624-.908-.905-1.702-1.681-1.765-1.723-.401-.27-.783-.211-1.176.183a1.285 1.285 0 0 0-.261.342.582.582 0 0 0-.082.35c0 .165.01.205.08.35.075.153.213.296 2.182 2.271 1.156 1.159 2.17 2.159 2.253 2.222.189.143.338.196.539.194.203-.003.412-.104.618-.299.205-.193 6.7-8.693 6.804-8.903a.716.716 0 0 0 .085-.345c.01-.179.005-.203-.062-.339-.124-.252-.45-.531-.746-.639a.784.784 0 0 0-.469-.027"\n              fill-rule="evenodd"\n            />\n          </svg>\n        </div>\n      </media-audio-track-listbox>\n    </media-audio-track-selectmenu>\n  </template>\n\n  <template partial="RenditionSelect">\n    <media-rendition-selectmenu part="bottom rendition selectmenu" disabled="{{disabled}}" aria-disabled="{{disabled}}">\n      <media-rendition-button slot="button" part="bottom rendition button">\n        <svg aria-hidden="true" slot="icon" viewBox="0 0 18 14">\n          <path\n            d="M2.25 9a2 2 0 1 0 0-4 2 2 0 0 0 0 4ZM9 9a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm6.75 0a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"\n          />\n        </svg>\n      </media-rendition-button>\n      <media-rendition-listbox slot="listbox" exportparts="option" part="bottom rendition listbox">\n        <div slot="select-indicator">\n          <style>\n            .listbox-indicator {\n              position: relative;\n              top: 1px;\n              width: 0.9em;\n              height: auto;\n              fill: var(--_accent-color);\n            }\n\n            [aria-selected=\'false\'] .listbox-indicator {\n              display: none;\n            }\n          </style>\n          <svg viewBox="0 0 14 18" class="listbox-indicator">\n            <path\n              d="M12.252 3.48c-.115.033-.301.161-.425.291-.059.063-1.407 1.815-2.995 3.894s-2.897 3.79-2.908 3.802c-.013.014-.661-.616-1.672-1.624-.908-.905-1.702-1.681-1.765-1.723-.401-.27-.783-.211-1.176.183a1.285 1.285 0 0 0-.261.342.582.582 0 0 0-.082.35c0 .165.01.205.08.35.075.153.213.296 2.182 2.271 1.156 1.159 2.17 2.159 2.253 2.222.189.143.338.196.539.194.203-.003.412-.104.618-.299.205-.193 6.7-8.693 6.804-8.903a.716.716 0 0 0 .085-.345c.01-.179.005-.203-.062-.339-.124-.252-.45-.531-.746-.639a.784.784 0 0 0-.469-.027"\n              fill-rule="evenodd"\n            />\n          </svg>\n        </div>\n      </media-rendition-listbox>\n    </media-rendition-selectmenu>\n  </template>\n\n  <media-controller\n    part="controller"\n    defaultstreamtype="{{defaultstreamtype ?? \'on-demand\'}}"\n    breakpoints="sm:470"\n    gesturesdisabled="{{disabled}}"\n    hotkeys="{{hotkeys}}"\n    nohotkeys="{{nohotkeys}}"\n    novolumepref="{{novolumepref}}"\n    audio="{{audio}}"\n    noautoseektolive="{{noautoseektolive}}"\n    defaultsubtitles="{{defaultsubtitles}}"\n    defaultduration="{{defaultduration ?? false}}"\n    keyboardforwardseekoffset="{{forwardseekoffset}}"\n    keyboardbackwardseekoffset="{{backwardseekoffset}}"\n    exportparts="layer, media-layer, poster-layer, vertical-layer, centered-layer, gesture-layer"\n    style="--_pre-playback-place:{{preplaybackplace ?? \'center\'}}"\n  >\n    <slot name="media" slot="media"></slot>\n    <slot name="poster" slot="poster"></slot>\n\n    <media-loading-indicator slot="centered-chrome" noautohide></media-loading-indicator>\n\n    <template if="!audio">\n      \x3c!-- Pre-playback UI --\x3e\n      <div slot="centered-chrome" class="center-controls pre-playback">\n        <template if="streamtype == \'on-demand\'">\n          <template if="!breakpointsm"> {{>SeekBackwardButton section="center"}} </template>\n          <template if="!breakpointsm"> {{>PlayButton section="center"}} </template>\n          <template if="breakpointsm"> {{>PrePlayButton section="center"}} </template>\n          <template if="!breakpointsm"> {{>SeekForwardButton section="center"}} </template>\n        </template>\n\n        <template if="streamtype == \'live\'">\n          <template if="!breakpointsm">\n            <template if="targetlivewindow > 0"> {{>SeekBackwardButton section="center"}} </template>\n          </template>\n          <template if="!breakpointsm"> {{>PlayButton section="center"}} </template>\n          <template if="breakpointsm"> {{>PrePlayButton section="center"}} </template>\n          <template if="!breakpointsm">\n            <template if="targetlivewindow > 0"> {{>SeekForwardButton section="center"}} </template>\n          </template>\n        </template>\n      </div>\n\n      \x3c!-- Auotplay centered unmute button --\x3e\n      \x3c!--\n        todo: figure out how show this with available state variables\n        needs to show when:\n        - autoplay is enabled\n        - playback has been successful\n        - audio is muted\n        - in place / instead of the pre-plaback play button\n        - not to show again after user has interacted with this button\n          - OR user has interacted with the mute button in the control bar\n      --\x3e\n      \x3c!--\n        There should be a >MuteButton to the left of the "Unmute" text, but a templating bug\n        makes it appear even if commented out in the markup, add it back when code is un-commented\n      --\x3e\n      \x3c!-- <div slot="centered-chrome" class="autoplay-unmute">\n        <div role="button" class="autoplay-unmute-btn">Unmute</div>\n      </div> --\x3e\n\n      <template if="streamtype == \'on-demand\'">\n        <template if="breakpointsm">\n          <media-control-bar part="control-bar top" slot="top-chrome">{{>TitleDisplay}} </media-control-bar>\n        </template>\n        {{>TimeRange}}\n        <media-control-bar part="control-bar bottom">\n          {{>PlayButton}} {{>SeekBackwardButton}} {{>SeekForwardButton}} {{>TimeDisplay}} {{>MuteButton}}\n          {{>VolumeRange}}\n          <div class="spacer"></div>\n          {{>RenditionSelect}} {{>PlaybackRateSelect}} {{>AudioTrackSelect}} {{>CaptionsMenuButton}} {{>AirplayButton}}\n          {{>CastButton}} {{>PipButton}} {{>FullscreenButton}}\n        </media-control-bar>\n      </template>\n\n      <template if="streamtype == \'live\'">\n        <media-control-bar part="control-bar top" slot="top-chrome">\n          {{>LiveButton}}\n          <template if="breakpointsm"> {{>TitleDisplay}} </template>\n        </media-control-bar>\n        <template if="targetlivewindow > 0">{{>TimeRange}}</template>\n        <media-control-bar part="control-bar bottom">\n          {{>PlayButton}}\n          <template if="targetlivewindow > 0">{{>SeekBackwardButton}} {{>SeekForwardButton}}</template>\n          {{>MuteButton}} {{>VolumeRange}}\n          <div class="spacer"></div>\n          {{>RenditionSelect}} {{>AudioTrackSelect}} {{>CaptionsMenuButton}} {{>AirplayButton}} {{>CastButton}}\n          {{>PipButton}} {{>FullscreenButton}}\n        </media-control-bar>\n      </template>\n    </template>\n\n    <template if="audio">\n      <template if="streamtype == \'on-demand\'">\n        <template if="title">\n          <media-control-bar part="control-bar top">{{>TitleDisplay}}</media-control-bar>\n        </template>\n        <media-control-bar part="control-bar bottom">\n          {{>PlayButton}}\n          <template if="breakpointsm"> {{>SeekBackwardButton}} {{>SeekForwardButton}} </template>\n          {{>MuteButton}}\n          <template if="breakpointsm">{{>VolumeRange}}</template>\n          {{>TimeDisplay}} {{>TimeRange}}\n          <template if="breakpointsm">{{>PlaybackRateSelect}}</template>\n          {{>AirplayButton}} {{>CastButton}}\n        </media-control-bar>\n      </template>\n\n      <template if="streamtype == \'live\'">\n        <template if="title">\n          <media-control-bar part="control-bar top">{{>TitleDisplay}}</media-control-bar>\n        </template>\n        <media-control-bar part="control-bar bottom">\n          <template if="breakpointsm">\n            {{>PlayButton}} {{>LiveButton section="bottom"}} {{>MuteButton}} {{>VolumeRange}}\n            <template if="targetlivewindow > 0"> {{>SeekBackwardButton}} {{>SeekForwardButton}} </template>\n          </template>\n          <template if="targetlivewindow > 0"> {{>TimeDisplay}} {{>TimeRange}} </template>\n          <template if="!targetlivewindow"><div class="spacer"></div></template>\n          {{>AirplayButton}} {{>CastButton}}\n        </media-control-bar>\n      </template>\n    </template>\n\n    <slot></slot>\n  </media-controller>\n</template>\n');
	var Ww, Gw, Vw = class extends yw {
	};
	Vw.template = null == (Gw = null == (Ww = Hw.content) ? void 0 : Ww.children) ? void 0 : Gw[0], h.customElements.get("media-theme-gerwig") || h.customElements.define("media-theme-gerwig", Vw);
	var Kw = {SRC: "src", POSTER: "poster"}, qw = {
			STYLE: "style",
			DEFAULT_HIDDEN_CAPTIONS: "default-hidden-captions",
			PRIMARY_COLOR: "primary-color",
			SECONDARY_COLOR: "secondary-color",
			ACCENT_COLOR: "accent-color",
			FORWARD_SEEK_OFFSET: "forward-seek-offset",
			BACKWARD_SEEK_OFFSET: "backward-seek-offset",
			PLAYBACK_TOKEN: "playback-token",
			THUMBNAIL_TOKEN: "thumbnail-token",
			STORYBOARD_TOKEN: "storyboard-token",
			STORYBOARD_SRC: "storyboard-src",
			THUMBNAIL_TIME: "thumbnail-time",
			AUDIO: "audio",
			NOHOTKEYS: "nohotkeys",
			HOTKEYS: "hotkeys",
			PLAYBACK_RATES: "playbackrates",
			DEFAULT_SHOW_REMAINING_TIME: "default-show-remaining-time",
			DEFAULT_DURATION: "default-duration",
			TITLE: "title",
			PLACEHOLDER: "placeholder",
			THEME: "theme",
			DEFAULT_STREAM_TYPE: "default-stream-type",
			TARGET_LIVE_WINDOW: "target-live-window",
			EXTRA_SOURCE_PARAMS: "extra-source-params",
			NO_VOLUME_PREF: "no-volume-pref"
		},
		Yw = ["audio", "backwardseekoffset", "defaultduration", "defaultshowremainingtime", "defaultsubtitles", "noautoseektolive", "disabled", "exportparts", "forwardseekoffset", "hideduration", "hotkeys", "nohotkeys", "playbackrates", "defaultstreamtype", "streamtype", "style", "targetlivewindow", "template", "title", "novolumepref"];

	function jw(e) {
		var t, i;
		let a = e.theme;
		if (a) {
			let r = null == (i = null == (t = e.getRootNode()) ? void 0 : t.getElementById) ? void 0 : i.call(t, a);
			if (r && r instanceof HTMLTemplateElement) return r;
			a.startsWith("media-theme-") || (a = `media-theme-${a}`);
			let n = h.customElements.get(a);
			if (null != n && n.template) return n.template
		}
	}

	function zw(e) {
		var t;
		let i = null == (t = e.mediaController) ? void 0 : t.querySelector("media-time-display");
		return i && "none" === getComputedStyle(i).getPropertyValue("--media-duration-display-display").trim()
	}

	function Xw(e) {
		let t = e.hasAttribute(qw.TITLE) ? {video_title: e.getAttribute(qw.TITLE)} : {};
		return e.getAttributeNames().filter((e => e.startsWith("metadata-"))).reduce(((t, i) => {
			let a = e.getAttribute(i);
			return null !== a && (t[i.replace(/^metadata-/, "").replace(/-/g, "_")] = a), t
		}), t)
	}

	var Qw, Zw, Jw, eL, tL, iL, aL, rL, nL, sL, oL, lL, dL, uL, hL, cL, mL, fL, pL, gL, vL, EL = Object.values(Mk),
		bL = Object.values(Kw), yL = Object.values(qw), TL = Qk(), AL = {dialog: void 0, isDialogOpen: !1},
		_L = {redundant_streams: !0}, kL = class extends RS {
			constructor() {
				super(), i(this, iL), i(this, rL), i(this, sL), i(this, lL), i(this, uL), i(this, cL), i(this, fL), i(this, gL), i(this, Qw, !1), i(this, Zw, {}), i(this, Jw, !0), i(this, eL, new rS(this, "hotkeys")), i(this, tL, {
					...AL,
					onCloseErrorDialog: () => r(this, sL, oL).call(this, {dialog: void 0, isDialogOpen: !1}),
					onInitFocusDialog: e => {
						jk(this, c.activeElement) || e.preventDefault()
					}
				}), this.attachShadow({mode: "open"}), r(this, rL, nL).call(this), this.isConnected && r(this, iL, aL).call(this)
			}

			static get observedAttributes() {
				var e;
				return [...null != (e = RS.observedAttributes) ? e : [], ...bL, ...EL, ...yL]
			}

			get mediaTheme() {
				var e;
				return null == (e = this.shadowRoot) ? void 0 : e.querySelector("media-theme")
			}

			get mediaController() {
				var e, t;
				return null == (t = null == (e = this.mediaTheme) ? void 0 : e.shadowRoot) ? void 0 : t.querySelector("media-controller")
			}

			get preferCmcd() {
				var e;
				return null != (e = this.getAttribute(Mk.PREFER_CMCD)) ? e : void 0
			}

			set preferCmcd(e) {
				e !== this.preferCmcd && (e ? CT.includes(e) ? this.setAttribute(Mk.PREFER_CMCD, e) : sS(`Invalid value for preferCmcd. Must be one of ${CT.join()}`) : this.removeAttribute(Mk.PREFER_CMCD))
			}

			get hasPlayed() {
				var e, t;
				return null != (t = null == (e = this.mediaController) ? void 0 : e.hasAttribute(v.MEDIA_HAS_PLAYED)) && t
			}

			get inLiveWindow() {
				var e;
				return null == (e = this.mediaController) ? void 0 : e.hasAttribute(v.MEDIA_TIME_IS_LIVE)
			}

			get _hls() {
				var e;
				return null == (e = this.media) ? void 0 : e._hls
			}

			get mux() {
				var e;
				return null == (e = this.media) ? void 0 : e.mux
			}

			get theme() {
				var e;
				return null != (e = this.getAttribute(qw.THEME)) ? e : "gerwig"
			}

			set theme(e) {
				this.setAttribute(qw.THEME, `${e}`)
			}

			get themeProps() {
				let e = this.mediaTheme;
				if (!e) return;
				let t = {};
				for (let i of e.getAttributeNames()) {
					if (Yw.includes(i)) continue;
					let a = e.getAttribute(i);
					t[Vk(i)] = "" === a || a
				}
				return t
			}

			set themeProps(e) {
				var t, i;
				r(this, iL, aL).call(this);
				let a = {...this.themeProps, ...e};
				for (let r in a) {
					if (Yw.includes(r)) continue;
					let a = null == e ? void 0 : e[r];
					"boolean" == typeof a || null == a ? null == (t = this.mediaTheme) || t.toggleAttribute(Gk(r), !!a) : null == (i = this.mediaTheme) || i.setAttribute(Gk(r), a)
				}
			}

			get playbackId() {
				var e;
				return null != (e = this.getAttribute(Mk.PLAYBACK_ID)) ? e : void 0
			}

			set playbackId(e) {
				e ? this.setAttribute(Mk.PLAYBACK_ID, e) : this.removeAttribute(Mk.PLAYBACK_ID)
			}

			get src() {
				var e, t;
				return this.playbackId ? null != (e = SL(this, Kw.SRC)) ? e : void 0 : null != (t = this.getAttribute(Kw.SRC)) ? t : void 0
			}

			set src(e) {
				e ? this.setAttribute(Kw.SRC, e) : this.removeAttribute(Kw.SRC)
			}

			get poster() {
				var e;
				let t = this.getAttribute(Kw.POSTER);
				return null != t ? t : this.playbackId && !this.audio ? ((e, {
					token: t,
					customDomain: i = zk,
					thumbnailTime: a
				} = {}) => {
					let r = null == t ? a : void 0, {aud: n} = Yk(t);
					if (!t || "t" === n) {
						// return `https://image.${i}/${e}/thumbnail.webp${qk({token: t, time: r})}`
						return `https://custom_cname.tradetracker.net/${e}/thumbnail.webp${qk({token: t, time: r})}`
					}
				})(this.playbackId, {
					customDomain: this.customDomain,
					thumbnailTime: null != (e = this.thumbnailTime) ? e : this.startTime,
					token: this.tokens.thumbnail
				}) : void 0
			}

			set poster(e) {
				e || "" === e ? this.setAttribute(Kw.POSTER, e) : this.removeAttribute(Kw.POSTER)
			}

			get storyboardSrc() {
				var e;
				return null != (e = this.getAttribute(qw.STORYBOARD_SRC)) ? e : void 0
			}

			set storyboardSrc(e) {
				e ? this.setAttribute(qw.STORYBOARD_SRC, e) : this.removeAttribute(qw.STORYBOARD_SRC)
			}

			get storyboard() {
				return this.storyboardSrc && !this.tokens.storyboard ? this.storyboardSrc : !this.audio && this.playbackId && this.streamType && ![LT.LIVE, LT.UNKNOWN].includes(this.streamType) ? ((e, {
					token: t,
					customDomain: i = zk
				} = {}) => {
					let {aud: a} = Yk(t);
					if (!t || "s" === a) return `https://image.${i}/${e}/storyboard.vtt${qk({token: t, format: "webp"})}`
				})(this.playbackId, {customDomain: this.customDomain, token: this.tokens.storyboard}) : void 0
			}

			get audio() {
				return this.hasAttribute(qw.AUDIO)
			}

			set audio(e) {
				e ? this.setAttribute(qw.AUDIO, "") : this.removeAttribute(qw.AUDIO)
			}

			get hotkeys() {
				return t(this, eL)
			}

			get nohotkeys() {
				return this.hasAttribute(qw.NOHOTKEYS)
			}

			set nohotkeys(e) {
				e ? this.setAttribute(qw.NOHOTKEYS, "") : this.removeAttribute(qw.NOHOTKEYS)
			}

			get thumbnailTime() {
				return Kk(this.getAttribute(qw.THUMBNAIL_TIME))
			}

			set thumbnailTime(e) {
				this.setAttribute(qw.THUMBNAIL_TIME, `${e}`)
			}

			get title() {
				var e;
				return null != (e = this.getAttribute(qw.TITLE)) ? e : ""
			}

			set title(e) {
				e !== this.title && (e ? this.setAttribute(qw.TITLE, e) : this.removeAttribute("title"), super.title = e)
			}

			get placeholder() {
				var e;
				return null != (e = SL(this, qw.PLACEHOLDER)) ? e : ""
			}

			set placeholder(e) {
				this.setAttribute(qw.PLACEHOLDER, `${e}`)
			}

			get primaryColor() {
				var e, t;
				let i = this.getAttribute(qw.PRIMARY_COLOR);
				if (null != i || this.mediaTheme && (i = null == (t = null == (e = h.getComputedStyle(this.mediaTheme)) ? void 0 : e.getPropertyValue("--_primary-color")) ? void 0 : t.trim(), i)) return i
			}

			set primaryColor(e) {
				this.setAttribute(qw.PRIMARY_COLOR, `${e}`)
			}

			get secondaryColor() {
				var e, t;
				let i = this.getAttribute(qw.SECONDARY_COLOR);
				if (null != i || this.mediaTheme && (i = null == (t = null == (e = h.getComputedStyle(this.mediaTheme)) ? void 0 : e.getPropertyValue("--_secondary-color")) ? void 0 : t.trim(), i)) return i
			}

			set secondaryColor(e) {
				this.setAttribute(qw.SECONDARY_COLOR, `${e}`)
			}

			get accentColor() {
				var e, t;
				let i = this.getAttribute(qw.ACCENT_COLOR);
				if (null != i || this.mediaTheme && (i = null == (t = null == (e = h.getComputedStyle(this.mediaTheme)) ? void 0 : e.getPropertyValue("--_accent-color")) ? void 0 : t.trim(), i)) return i
			}

			set accentColor(e) {
				this.setAttribute(qw.ACCENT_COLOR, `${e}`)
			}

			get defaultShowRemainingTime() {
				return this.hasAttribute(qw.DEFAULT_SHOW_REMAINING_TIME)
			}

			set defaultShowRemainingTime(e) {
				e ? this.setAttribute(qw.DEFAULT_SHOW_REMAINING_TIME, "") : this.removeAttribute(qw.DEFAULT_SHOW_REMAINING_TIME)
			}

			get playbackRates() {
				if (this.hasAttribute(qw.PLAYBACK_RATES)) return this.getAttribute(qw.PLAYBACK_RATES).trim().split(/\s*,?\s+/).map((e => Number(e))).filter((e => !Number.isNaN(e))).sort(((e, t) => e - t))
			}

			set playbackRates(e) {
				e ? this.setAttribute(qw.PLAYBACK_RATES, e.join(" ")) : this.removeAttribute(qw.PLAYBACK_RATES)
			}

			get forwardSeekOffset() {
				var e;
				return null != (e = Kk(this.getAttribute(qw.FORWARD_SEEK_OFFSET))) ? e : 10
			}

			set forwardSeekOffset(e) {
				this.setAttribute(qw.FORWARD_SEEK_OFFSET, `${e}`)
			}

			get backwardSeekOffset() {
				var e;
				return null != (e = Kk(this.getAttribute(qw.BACKWARD_SEEK_OFFSET))) ? e : 10
			}

			set backwardSeekOffset(e) {
				this.setAttribute(qw.BACKWARD_SEEK_OFFSET, `${e}`)
			}

			get defaultHiddenCaptions() {
				return this.hasAttribute(qw.DEFAULT_HIDDEN_CAPTIONS)
			}

			set defaultHiddenCaptions(e) {
				e ? this.setAttribute(qw.DEFAULT_HIDDEN_CAPTIONS, "") : this.removeAttribute(qw.DEFAULT_HIDDEN_CAPTIONS)
			}

			get defaultDuration() {
				return Kk(this.getAttribute(qw.DEFAULT_DURATION))
			}

			set defaultDuration(e) {
				null == e ? this.removeAttribute(qw.DEFAULT_DURATION) : this.setAttribute(qw.DEFAULT_DURATION, `${e}`)
			}

			get playerSoftwareName() {
				var e;
				return null != (e = this.getAttribute(Mk.PLAYER_SOFTWARE_NAME)) ? e : "mux-player"
			}

			get playerSoftwareVersion() {
				var e;
				return null != (e = this.getAttribute(Mk.PLAYER_SOFTWARE_VERSION)) ? e : TL
			}

			get beaconCollectionDomain() {
				var e;
				return null != (e = this.getAttribute(Mk.BEACON_COLLECTION_DOMAIN)) ? e : void 0
			}

			set beaconCollectionDomain(e) {
				e !== this.beaconCollectionDomain && (e ? this.setAttribute(Mk.BEACON_COLLECTION_DOMAIN, e) : this.removeAttribute(Mk.BEACON_COLLECTION_DOMAIN))
			}

			get maxResolution() {
				var e;
				return null != (e = this.getAttribute(Mk.MAX_RESOLUTION)) ? e : void 0
			}

			set maxResolution(e) {
				e !== this.maxResolution && (e ? this.setAttribute(Mk.MAX_RESOLUTION, e) : this.removeAttribute(Mk.MAX_RESOLUTION))
			}

			get minResolution() {
				var e;
				return null != (e = this.getAttribute(Mk.MIN_RESOLUTION)) ? e : void 0
			}

			set minResolution(e) {
				e !== this.minResolution && (e ? this.setAttribute(Mk.MIN_RESOLUTION, e) : this.removeAttribute(Mk.MIN_RESOLUTION))
			}

			get renditionOrder() {
				var e;
				return null != (e = this.getAttribute(Mk.RENDITION_ORDER)) ? e : void 0
			}

			set renditionOrder(e) {
				e !== this.renditionOrder && (e ? this.setAttribute(Mk.RENDITION_ORDER, e) : this.removeAttribute(Mk.RENDITION_ORDER))
			}

			get extraSourceParams() {
				return this.hasAttribute(qw.EXTRA_SOURCE_PARAMS) ? [...new URLSearchParams(this.getAttribute(qw.EXTRA_SOURCE_PARAMS)).entries()].reduce(((e, [t, i]) => (e[t] = i, e)), {}) : _L
			}

			set extraSourceParams(e) {
				null == e ? this.removeAttribute(qw.EXTRA_SOURCE_PARAMS) : this.setAttribute(qw.EXTRA_SOURCE_PARAMS, new URLSearchParams(e).toString())
			}

			get customDomain() {
				var e;
				return null != (e = this.getAttribute(Mk.CUSTOM_DOMAIN)) ? e : void 0
			}

			set customDomain(e) {
				e !== this.customDomain && (e ? this.setAttribute(Mk.CUSTOM_DOMAIN, e) : this.removeAttribute(Mk.CUSTOM_DOMAIN))
			}

			get envKey() {
				var e;
				return null != (e = SL(this, Mk.ENV_KEY)) ? e : void 0
			}

			set envKey(e) {
				this.setAttribute(Mk.ENV_KEY, `${e}`)
			}

			get noVolumePref() {
				return this.hasAttribute(qw.NO_VOLUME_PREF)
			}

			set noVolumePref(e) {
				e ? this.setAttribute(qw.NO_VOLUME_PREF, "") : this.removeAttribute(qw.NO_VOLUME_PREF)
			}

			get debug() {
				return null != SL(this, Mk.DEBUG)
			}

			set debug(e) {
				e ? this.setAttribute(Mk.DEBUG, "") : this.removeAttribute(Mk.DEBUG)
			}

			get disableTracking() {
				return null != SL(this, Mk.DISABLE_TRACKING)
			}

			set disableTracking(e) {
				this.toggleAttribute(Mk.DISABLE_TRACKING, !!e)
			}

			get disableCookies() {
				return null != SL(this, Mk.DISABLE_COOKIES)
			}

			set disableCookies(e) {
				e ? this.setAttribute(Mk.DISABLE_COOKIES, "") : this.removeAttribute(Mk.DISABLE_COOKIES)
			}

			get streamType() {
				var e, t, i;
				return null != (i = null != (t = this.getAttribute(Mk.STREAM_TYPE)) ? t : null == (e = this.media) ? void 0 : e.streamType) ? i : LT.UNKNOWN
			}

			set streamType(e) {
				this.setAttribute(Mk.STREAM_TYPE, `${e}`)
			}

			get defaultStreamType() {
				var e, t, i;
				return null != (i = null != (t = this.getAttribute(qw.DEFAULT_STREAM_TYPE)) ? t : null == (e = this.mediaController) ? void 0 : e.getAttribute(qw.DEFAULT_STREAM_TYPE)) ? i : LT.ON_DEMAND
			}

			set defaultStreamType(e) {
				e ? this.setAttribute(qw.DEFAULT_STREAM_TYPE, e) : this.removeAttribute(qw.DEFAULT_STREAM_TYPE)
			}

			get targetLiveWindow() {
				var e, t;
				return this.hasAttribute(qw.TARGET_LIVE_WINDOW) ? +this.getAttribute(qw.TARGET_LIVE_WINDOW) : null != (t = null == (e = this.media) ? void 0 : e.targetLiveWindow) ? t : Number.NaN
			}

			set targetLiveWindow(e) {
				e == this.targetLiveWindow || Number.isNaN(e) && Number.isNaN(this.targetLiveWindow) || (null == e ? this.removeAttribute(qw.TARGET_LIVE_WINDOW) : this.setAttribute(qw.TARGET_LIVE_WINDOW, "" + +e))
			}

			get liveEdgeStart() {
				var e;
				return null == (e = this.media) ? void 0 : e.liveEdgeStart
			}

			get startTime() {
				return Kk(SL(this, Mk.START_TIME))
			}

			set startTime(e) {
				this.setAttribute(Mk.START_TIME, `${e}`)
			}

			get preferPlayback() {
				let e = this.getAttribute(Mk.PREFER_PLAYBACK);
				if (e === RT || e === IT) return e
			}

			set preferPlayback(e) {
				e !== this.preferPlayback && (e === RT || e === IT ? this.setAttribute(Mk.PREFER_PLAYBACK, e) : this.removeAttribute(Mk.PREFER_PLAYBACK))
			}

			get metadata() {
				var e;
				return null == (e = this.media) ? void 0 : e.metadata
			}

			set metadata(e) {
				r(this, iL, aL).call(this), this.media ? this.media.metadata = {...Xw(this), ...e} : oS("underlying media element missing when trying to set metadata. metadata will not be set.")
			}

			get _hlsConfig() {
				var e;
				return null == (e = this.media) ? void 0 : e._hlsConfig
			}

			set _hlsConfig(e) {
				r(this, iL, aL).call(this), this.media ? this.media._hlsConfig = e : oS("underlying media element missing when trying to set _hlsConfig. _hlsConfig will not be set.")
			}

			get activeCuePoint() {
				var e;
				return null == (e = this.media) ? void 0 : e.activeCuePoint
			}

			get cuePoints() {
				var e, t;
				return null != (t = null == (e = this.media) ? void 0 : e.cuePoints) ? t : []
			}

			get currentPdt() {
				var e;
				return null == (e = this.media) ? void 0 : e.currentPdt
			}

			get tokens() {
				let e = this.getAttribute(qw.PLAYBACK_TOKEN), i = this.getAttribute(qw.THUMBNAIL_TOKEN),
					a = this.getAttribute(qw.STORYBOARD_TOKEN);
				return {...t(this, Zw), ...null != e ? {playback: e} : {}, ...null != i ? {thumbnail: i} : {}, ...null != a ? {storyboard: a} : {}}
			}

			set tokens(e) {
				a(this, Zw, null != e ? e : {})
			}

			get playbackToken() {
				var e;
				return null != (e = this.getAttribute(qw.PLAYBACK_TOKEN)) ? e : void 0
			}

			set playbackToken(e) {
				this.setAttribute(qw.PLAYBACK_TOKEN, `${e}`)
			}

			get thumbnailToken() {
				var e;
				return null != (e = this.getAttribute(qw.THUMBNAIL_TOKEN)) ? e : void 0
			}

			set thumbnailToken(e) {
				this.setAttribute(qw.THUMBNAIL_TOKEN, `${e}`)
			}

			get storyboardToken() {
				var e;
				return null != (e = this.getAttribute(qw.STORYBOARD_TOKEN)) ? e : void 0
			}

			set storyboardToken(e) {
				this.setAttribute(qw.STORYBOARD_TOKEN, `${e}`)
			}

			get textTracks() {
				var e;
				return null == (e = this.media) ? void 0 : e.textTracks
			}

			connectedCallback() {
				var e;
				let t = null == (e = this.shadowRoot) ? void 0 : e.querySelector("mux-video");
				t && (t.metadata = Xw(this))
			}

			attributeChangedCallback(e, i, n) {
				switch (r(this, iL, aL).call(this), super.attributeChangedCallback(e, i, n), e) {
					case qw.HOTKEYS:
						t(this, eL).value = n;
						break;
					case qw.THUMBNAIL_TIME:
						null != n && this.tokens.thumbnail && sS(Hk("Use of thumbnail-time with thumbnail-token is currently unsupported. Ignore thumbnail-time.").format({}));
						break;
					case qw.THUMBNAIL_TOKEN: {
						let {aud: e} = Yk(n);
						n && "t" !== e && sS(Hk("The provided thumbnail-token should have audience value 't' instead of '{aud}'.").format({aud: e}));
						break
					}
					case qw.STORYBOARD_TOKEN: {
						let {aud: e} = Yk(n);
						n && "s" !== e && sS(Hk("The provided storyboard-token should have audience value 's' instead of '{aud}'.").format({aud: e}));
						break
					}
					case Mk.PLAYBACK_ID:
						null != n && n.includes("?token") && oS(Hk("The specificed playback ID {playbackId} contains a token which must be provided via the playback-token attribute.").format({playbackId: n}));
						break;
					case Mk.STREAM_TYPE:
						n && ![LT.LIVE, LT.ON_DEMAND, LT.UNKNOWN].includes(n) ? ["ll-live", "live:dvr", "ll-live:dvr"].includes(this.streamType) ? this.targetLiveWindow = n.includes("dvr") ? Number.POSITIVE_INFINITY : 0 : lS({
							file: "invalid-stream-type.md",
							message: Hk("Invalid stream-type value supplied: `{streamType}`. Please provide stream-type as either: `on-demand` or `live`").format({streamType: this.streamType})
						}) : n === LT.LIVE ? null == this.getAttribute(qw.TARGET_LIVE_WINDOW) && (this.targetLiveWindow = 0) : this.targetLiveWindow = Number.NaN
				}
				[Mk.PLAYBACK_ID, Kw.SRC, qw.PLAYBACK_TOKEN].includes(e) && i !== n && a(this, tL, {...t(this, tL), ...AL}), r(this, lL, dL).call(this, {[eS(e)]: n})
			}

			async addCuePoints(e) {
				var t;
				if (r(this, iL, aL).call(this), this.media) return null == (t = this.media) ? void 0 : t.addCuePoints(e);
				oS("underlying media element missing when trying to addCuePoints. cuePoints will not be added.")
			}

			getStartDate() {
				var e;
				return null == (e = this.media) ? void 0 : e.getStartDate()
			}

			addTextTrack(e, t, i, a) {
				var r;
				let n = null == (r = this.media) ? void 0 : r.nativeEl;
				if (n) return GT(n, e, t, i, a)
			}

			removeTextTrack(e) {
				var t;
				let i = null == (t = this.media) ? void 0 : t.nativeEl;
				if (i) return function (e, t) {
					let i = Array.prototype.find.call(e.querySelectorAll("track"), (e => e.track === t));
					null == i || i.remove()
				}(i, e)
			}
		};

	function SL(e, t) {
		return e.media ? e.media.getAttribute(t) : e.getAttribute(t)
	}

	Qw = new WeakMap, Zw = new WeakMap, Jw = new WeakMap, eL = new WeakMap, tL = new WeakMap, iL = new WeakSet, aL = function () {
		var e, i, n;
		if (!t(this, Qw)) {
			a(this, Qw, !0), r(this, lL, dL).call(this);
			try {
				if (customElements.upgrade(this.mediaTheme), !(this.mediaTheme instanceof h.HTMLElement)) throw ""
			} catch {
				oS("<media-theme> failed to upgrade!")
			}
			try {
				if (customElements.upgrade(this.media), !(this.media instanceof Fk)) throw ""
			} catch {
				oS("<mux-video> failed to upgrade!")
			}
			try {
				if (customElements.upgrade(this.mediaController), !(this.mediaController instanceof Ri)) throw ""
			} catch {
				oS("<media-controller> failed to upgrade!")
			}
			(function (e) {
				e.querySelectorAll(":scope > track").forEach((t => {
					var i;
					null == (i = e.media) || i.append(t.cloneNode())
				})), cS.forEach((t => {
					var i;
					null == (i = e.media) || i.addEventListener(t, (t => {
						e.dispatchEvent(new Event(t.type))
					}))
				}))
			})(this), r(this, uL, hL).call(this), r(this, cL, mL).call(this), r(this, fL, pL).call(this), a(this, Jw, null == (i = null == (e = this.mediaController) ? void 0 : e.hasAttribute(Ve.USER_INACTIVE)) || i), r(this, gL, vL).call(this), null == (n = this.media) || n.addEventListener("streamtypechange", (() => {
				r(this, lL, dL).call(this)
			}))
		}
	}, rL = new WeakSet, nL = function () {
		var e, t;
		try {
			null == (e = null == window ? void 0 : window.CSS) || e.registerProperty({
				name: "--media-primary-color",
				syntax: "<color>",
				inherits: !0
			}), null == (t = null == window ? void 0 : window.CSS) || t.registerProperty({
				name: "--media-secondary-color",
				syntax: "<color>",
				inherits: !0
			})
		} catch {
		}
	}, sL = new WeakSet, oL = function (e) {
		Object.assign(t(this, tL), e), r(this, lL, dL).call(this)
	}, lL = new WeakSet, dL = function (e = {}) {
		!function (e, t) {
			e.renderInto(t)
		}((e => Uw`
  <style>
    ${":host {\n  --media-control-display: var(--controls);\n  --media-loading-indicator-display: var(--loading-indicator);\n  --media-dialog-display: var(--dialog);\n  --media-play-button-display: var(--play-button);\n  --media-live-button-display: var(--live-button);\n  --media-seek-backward-button-display: var(--seek-backward-button);\n  --media-seek-forward-button-display: var(--seek-forward-button);\n  --media-mute-button-display: var(--mute-button);\n  --media-captions-button-display: var(--captions-button);\n  --media-captions-selectmenu-display: var(--captions-selectmenu, var(--media-captions-button-display));\n  --media-rendition-selectmenu-display: var(--rendition-selectmenu);\n  --media-audio-track-selectmenu-display: var(--audio-track-selectmenu);\n  --media-airplay-button-display: var(--airplay-button);\n  --media-pip-button-display: var(--pip-button);\n  --media-fullscreen-button-display: var(--fullscreen-button);\n  --media-cast-button-display: var(--cast-button);\n  --media-playback-rate-button-display: var(--playback-rate-button);\n  --media-playback-rate-selectmenu-display: var(--playback-rate-selectmenu);\n  --media-volume-range-display: var(--volume-range);\n  --media-time-range-display: var(--time-range);\n  --media-time-display-display: var(--time-display);\n  --media-duration-display-display: var(--duration-display);\n  --media-title-display-display: var(--title-display);\n\n  display: inline-block;\n  width: 100%;\n  line-height: 0;\n}\n\n/* Hide custom elements that are not defined yet */\n:not(:defined) {\n  display: none;\n}\n\na {\n  color: #fff;\n  font-size: 0.9em;\n  text-decoration: underline;\n}\n\nmedia-theme {\n  width: 100%;\n  height: 100%;\n  direction: ltr;\n}\n\nmedia-poster-image {\n  width: 100%;\n  height: 100%;\n}\n\nmedia-poster-image:not([src]):not([placeholdersrc]) {\n  display: none;\n}\n\n::part(top),\n[part~='top'] {\n  --media-control-display: var(--controls, var(--top-controls));\n  --media-play-button-display: var(--play-button, var(--top-play-button));\n  --media-live-button-display: var(--live-button, var(--top-live-button));\n  --media-seek-backward-button-display: var(--seek-backward-button, var(--top-seek-backward-button));\n  --media-seek-forward-button-display: var(--seek-forward-button, var(--top-seek-forward-button));\n  --media-mute-button-display: var(--mute-button, var(--top-mute-button));\n  --media-captions-button-display: var(--captions-button, var(--top-captions-button));\n  --media-captions-selectmenu-display: var(\n    --captions-selectmenu,\n    var(--media-captions-button-display, var(--top-captions-selectmenu))\n  );\n  --media-rendition-selectmenu-display: var(--rendition-selectmenu, var(--top-rendition-selectmenu));\n  --media-audio-track-selectmenu-display: var(--audio-track-selectmenu, var(--top-audio-track-selectmenu));\n  --media-airplay-button-display: var(--airplay-button, var(--top-airplay-button));\n  --media-pip-button-display: var(--pip-button, var(--top-pip-button));\n  --media-fullscreen-button-display: var(--fullscreen-button, var(--top-fullscreen-button));\n  --media-cast-button-display: var(--cast-button, var(--top-cast-button));\n  --media-playback-rate-button-display: var(--playback-rate-button, var(--top-playback-rate-button));\n  --media-playback-rate-selectmenu-display: var(\n    --captions-selectmenu,\n    var(--media-playback-rate-button-display, var(--top-playback-rate-selectmenu))\n  );\n  --media-volume-range-display: var(--volume-range, var(--top-volume-range));\n  --media-time-range-display: var(--time-range, var(--top-time-range));\n  --media-time-display-display: var(--time-display, var(--top-time-display));\n  --media-duration-display-display: var(--duration-display, var(--top-duration-display));\n  --media-title-display-display: var(--title-display, var(--top-title-display));\n}\n\n::part(center),\n[part~='center'] {\n  --media-control-display: var(--controls, var(--center-controls));\n  --media-play-button-display: var(--play-button, var(--center-play-button));\n  --media-live-button-display: var(--live-button, var(--center-live-button));\n  --media-seek-backward-button-display: var(--seek-backward-button, var(--center-seek-backward-button));\n  --media-seek-forward-button-display: var(--seek-forward-button, var(--center-seek-forward-button));\n  --media-mute-button-display: var(--mute-button, var(--center-mute-button));\n  --media-captions-button-display: var(--captions-button, var(--center-captions-button));\n  --media-captions-selectmenu-display: var(\n    --captions-selectmenu,\n    var(--media-captions-button-display, var(--center-captions-selectmenu))\n  );\n  --media-rendition-selectmenu-display: var(--rendition-selectmenu, var(--center-rendition-selectmenu));\n  --media-audio-track-selectmenu-display: var(--audio-track-selectmenu, var(--center-audio-track-selectmenu));\n  --media-airplay-button-display: var(--airplay-button, var(--center-airplay-button));\n  --media-pip-button-display: var(--pip-button, var(--center-pip-button));\n  --media-fullscreen-button-display: var(--fullscreen-button, var(--center-fullscreen-button));\n  --media-cast-button-display: var(--cast-button, var(--center-cast-button));\n  --media-playback-rate-button-display: var(--playback-rate-button, var(--center-playback-rate-button));\n  --media-playback-rate-selectmenu-display: var(\n    --playback-rate-selectmenu,\n    var(--media-playback-rate-button-display, var(--center-playback-rate-selectmenu))\n  );\n  --media-volume-range-display: var(--volume-range, var(--center-volume-range));\n  --media-time-range-display: var(--time-range, var(--center-time-range));\n  --media-time-display-display: var(--time-display, var(--center-time-display));\n  --media-duration-display-display: var(--duration-display, var(--center-duration-display));\n}\n\n::part(bottom),\n[part~='bottom'] {\n  --media-control-display: var(--controls, var(--bottom-controls));\n  --media-play-button-display: var(--play-button, var(--bottom-play-button));\n  --media-live-button-display: var(--live-button, var(--bottom-live-button));\n  --media-seek-backward-button-display: var(--seek-backward-button, var(--bottom-seek-backward-button));\n  --media-seek-forward-button-display: var(--seek-forward-button, var(--bottom-seek-forward-button));\n  --media-mute-button-display: var(--mute-button, var(--bottom-mute-button));\n  --media-captions-button-display: var(--captions-button, var(--bottom-captions-button));\n  --media-captions-selectmenu-display: var(\n    --captions-selectmenu,\n    var(--media-captions-button-display, var(--bottom-captions-selectmenu))\n  );\n  --media-rendition-selectmenu-display: var(--rendition-selectmenu, var(--bottom-rendition-selectmenu));\n  --media-audio-track-selectmenu-display: var(--audio-track-selectmenu, var(--bottom-audio-track-selectmenu));\n  --media-airplay-button-display: var(--airplay-button, var(--bottom-airplay-button));\n  --media-pip-button-display: var(--pip-button, var(--bottom-pip-button));\n  --media-fullscreen-button-display: var(--fullscreen-button, var(--bottom-fullscreen-button));\n  --media-cast-button-display: var(--cast-button, var(--bottom-cast-button));\n  --media-playback-rate-button-display: var(--playback-rate-button, var(--bottom-playback-rate-button));\n  --media-playback-rate-selectmenu-display: var(\n    --playback-rate-selectmenu,\n    var(--media-playback-rate-button-display, var(--bottom-playback-rate-selectmenu))\n  );\n  --media-volume-range-display: var(--volume-range, var(--bottom-volume-range));\n  --media-time-range-display: var(--time-range, var(--bottom-time-range));\n  --media-time-display-display: var(--time-display, var(--bottom-time-display));\n  --media-duration-display-display: var(--duration-display, var(--bottom-duration-display));\n  --media-title-display-display: var(--title-display, var(--bottom-title-display));\n}\n"}
  </style>
  ${Bw(e)}
`)(function (e, t) {
			var i;
			return {
				src: !e.playbackId && e.src,
				playbackId: e.playbackId,
				hasSrc: !!e.playbackId || !!e.src,
				poster: e.poster,
				storyboard: e.storyboard,
				storyboardSrc: e.getAttribute(qw.STORYBOARD_SRC),
				placeholder: e.getAttribute("placeholder"),
				themeTemplate: jw(e),
				thumbnailTime: !e.tokens.thumbnail && e.thumbnailTime,
				autoplay: e.autoplay,
				crossOrigin: e.crossOrigin,
				loop: e.loop,
				noHotKeys: e.hasAttribute(qw.NOHOTKEYS),
				hotKeys: e.getAttribute(qw.HOTKEYS),
				muted: e.muted,
				paused: e.paused,
				preload: e.preload,
				envKey: e.envKey,
				preferCmcd: e.preferCmcd,
				debug: e.debug,
				disableTracking: e.disableTracking,
				disableCookies: e.disableCookies,
				tokens: e.tokens,
				beaconCollectionDomain: e.beaconCollectionDomain,
				maxResolution: e.maxResolution,
				minResolution: e.minResolution,
				renditionOrder: e.renditionOrder,
				metadata: e.metadata,
				playerSoftwareName: e.playerSoftwareName,
				playerSoftwareVersion: e.playerSoftwareVersion,
				startTime: e.startTime,
				preferPlayback: e.preferPlayback,
				audio: e.audio,
				defaultStreamType: e.defaultStreamType,
				targetLiveWindow: e.getAttribute(Mk.TARGET_LIVE_WINDOW),
				streamType: Zk(e.getAttribute(Mk.STREAM_TYPE)),
				primaryColor: e.getAttribute(qw.PRIMARY_COLOR),
				secondaryColor: e.getAttribute(qw.SECONDARY_COLOR),
				accentColor: e.getAttribute(qw.ACCENT_COLOR),
				forwardSeekOffset: e.forwardSeekOffset,
				backwardSeekOffset: e.backwardSeekOffset,
				defaultHiddenCaptions: e.defaultHiddenCaptions,
				defaultDuration: e.defaultDuration,
				defaultShowRemainingTime: e.defaultShowRemainingTime,
				hideDuration: zw(e),
				playbackRates: e.getAttribute(qw.PLAYBACK_RATES),
				customDomain: null != (i = e.getAttribute(Mk.CUSTOM_DOMAIN)) ? i : void 0,
				title: e.getAttribute(qw.TITLE),
				novolumepref: e.hasAttribute(qw.NO_VOLUME_PREF), ...t,
				extraSourceParams: e.extraSourceParams
			}
		}(this, {...t(this, tL), ...e})), this.shadowRoot)
	}, uL = new WeakSet, hL = function () {
		let e = e => {
			var t, i;
			if (null == e || !e.startsWith("theme-")) return;
			let a = e.replace(/^theme-/, "");
			if (Yw.includes(a)) return;
			let r = this.getAttribute(e);
			null != r ? null == (t = this.mediaTheme) || t.setAttribute(a, r) : null == (i = this.mediaTheme) || i.removeAttribute(a)
		};
		new MutationObserver((t => {
			for (let {attributeName: i} of t) e(i)
		})).observe(this, {attributes: !0}), this.getAttributeNames().forEach(e)
	}, cL = new WeakSet, mL = function () {
		var e;
		this.addEventListener("error", (e => {
			let {detail: t} = e;
			if (t instanceof kT || (t = new kT(t.message, t.code, t.fatal)), null == t || !t.fatal) return sS(t), void (t.data && sS(`${t.name} data:`, t.data));
			let {dialog: i, devlog: a} = $w(t, !window.navigator.onLine, this.playbackId, this.playbackToken);
			a.message && lS(a), oS(t), t.data && oS(`${t.name} data:`, t.data), r(this, sL, oL).call(this, {
				isDialogOpen: !0,
				dialog: i
			})
		})), this.media && (this.media.errorTranslator = (e = {}) => {
			var t, i, a;
			if (!((null == (t = this.media) ? void 0 : t.error) instanceof kT)) return e;
			let {devlog: r} = $w(null == (i = this.media) ? void 0 : i.error, !window.navigator.onLine, this.playbackId, this.playbackToken, !1);
			return {
				player_error_code: null == (a = this.media) ? void 0 : a.error.code,
				player_error_message: r.message ? String(r.message) : e.player_error_message,
				player_error_context: r.context ? String(r.context) : e.player_error_context
			}
		}), null == (e = this.media) || e.addEventListener("error", (e => {
			var t, i;
			let {detail: a} = e;
			if (!a) {
				let {message: e, code: r} = null != (i = null == (t = this.media) ? void 0 : t.error) ? i : {};
				a = new kT(e, r)
			}
			null != a && a.fatal && this.dispatchEvent(new CustomEvent("error", {detail: a}))
		}))
	}, fL = new WeakSet, pL = function () {
		var e, t, i, a;
		let n = () => r(this, lL, dL).call(this);
		null == (t = null == (e = this.media) ? void 0 : e.textTracks) || t.addEventListener("addtrack", n), null == (a = null == (i = this.media) ? void 0 : i.textTracks) || a.addEventListener("removetrack", n)
	}, gL = new WeakSet, vL = function () {
		var e, i;
		if (!/Firefox/i.test(navigator.userAgent)) return;
		let r, n = new WeakMap,
			s = () => this.streamType === LT.LIVE && !this.secondaryColor && this.offsetWidth >= 800,
			o = (e, t, i = !1) => {
				s() || Array.from(e && e.activeCues || []).forEach((e => {
					if (!(!e.snapToLines || e.line < -5 || e.line >= 0 && e.line < 10)) if (!t || this.paused) {
						let t = e.text.split("\n").length, a = -3;
						this.streamType === LT.LIVE && (a = -2);
						let r = a - t;
						if (e.line === r && !i) return;
						n.has(e) || n.set(e, e.line), e.line = r
					} else setTimeout((() => {
						e.line = n.get(e) || "auto"
					}), 500)
				}))
			}, l = () => {
				var e, t;
				o(r, null != (t = null == (e = this.mediaController) ? void 0 : e.hasAttribute(Ve.USER_INACTIVE)) && t)
			}, d = () => {
				var e, i;
				let a = Array.from((null == (i = null == (e = this.mediaController) ? void 0 : e.media) ? void 0 : i.textTracks) || []).filter((e => ["subtitles", "captions"].includes(e.kind) && "showing" === e.mode))[0];
				a !== r && (null == r || r.removeEventListener("cuechange", l)), r = a, null == r || r.addEventListener("cuechange", l), o(r, t(this, Jw))
			};
		d(), null == (e = this.textTracks) || e.addEventListener("change", d), null == (i = this.textTracks) || i.addEventListener("addtrack", d), this.addEventListener("userinactivechange", (() => {
			var e, i;
			let n = null == (i = null == (e = this.mediaController) ? void 0 : e.hasAttribute(Ve.USER_INACTIVE)) || i;
			t(this, Jw) !== n && (a(this, Jw, n), o(r, t(this, Jw)))
		}))
	}, h.customElements.get("mux-player") || (h.customElements.define("mux-player", kL), h.MuxPlayerElement = kL)
})();
/*! Bundled license information:

mux-embed/dist/mux.mjs:
  (*!
  * JavaScript Cookie v2.1.3
  * https://github.com/js-cookie/js-cookie
  *
  * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
  * Released under the MIT license
  *)
*/
//# sourceMappingURL=/sm/375f6d69681947afafe1f0d9c07dbbe2304eb5c0fc8cac2806c2b746dbcaa8d4.map